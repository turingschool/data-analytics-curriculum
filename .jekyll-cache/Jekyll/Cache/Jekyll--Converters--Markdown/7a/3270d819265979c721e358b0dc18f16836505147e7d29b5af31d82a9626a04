I"~9<h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>Understand the concept of recursion</li>
  <li>Understand the limitations of recursion in JS &amp; Ruby</li>
  <li>Know the theory behind Tail Call Optimization</li>
  <li>Be able to solve problems using recursion</li>
</ul>

<h2 id="discussion-on-reading">Discussion on Reading</h2>

<p>Reflecting on the <a href="https://www.sitepoint.com/recursion-functional-javascript/">article</a> you read earlier, discuss the following questions with the person next to you:</p>

<ul>
  <li>Describe what recursion is? How does it compare to loops?</li>
  <li>What are some scenarios that recursion is best for?</li>
  <li>What performance issues does recursion have in languages like JavaScript &amp; Ruby?</li>
</ul>

<h2 id="reviewing-key-concepts">Reviewing Key Concepts</h2>

<p>Recursion is an important programming technique in which a function calls itself.</p>

<h3 id="advantages">Advantages</h3>

<ul>
  <li>Useful for iterative branching including:
    <ul>
      <li>fractal math</li>
      <li>sorting</li>
      <li>traversing nodes of complex/non-linear structures (binary or prefix tries)</li>
    </ul>
  </li>
  <li>Recursion is more functional in that it doesn’t keep track of state (no side effects)</li>
</ul>

<h3 id="disadvantages">Disadvantages</h3>
<ul>
  <li>Recursion is not optimized in many languages including JS &amp; Ruby
    <ul>
      <li>Execution contexts continue to get built on the callstack.</li>
      <li>With bigger datasets, this can be a problem.
        <ul>
          <li>Memory consumption can lead to the <code class="highlighter-rouge">maximum call stack size being exceeded</code>.</li>
          <li>Loops on the otherhand don’t need to add functions to the call stack. (better memory management)</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="the-anatomy-of-a-recursive-function">The anatomy of a recursive function</h2>

<p>Every recursive function (reminder, just a function that calls itself) must have these two pieces:</p>

<ol>
  <li>A simple <strong>base case</strong> (or cases): a terminating scenario that <em>does not use recursion</em> to produce an answer</li>
  <li>A <strong>recursive case</strong>: A set of instructions, moving closer towards the base case, that ends in a call to the same function</li>
</ol>

<p>Let’s see this in action with a function that takes a number as an argument and counts down to zero.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">countdown</span><span class="p">(</span> <span class="mi">3</span> <span class="p">);</span>

<span class="c1">// 3</span>
<span class="c1">// 2</span>
<span class="c1">// 1</span>
<span class="c1">// 0</span>
</code></pre></div></div>

<p><strong>Solution:</strong></p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">countdown</span> <span class="o">=</span> <span class="nx">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// check our base case, if statement</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">number</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">number</span><span class="p">);</span>
  
  <span class="c1">// recursive case moving towards base case</span>
  <span class="k">return</span> <span class="nx">countdown</span><span class="p">(</span><span class="nx">number</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="nx">countdown</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="c1">// 3, 2, 1, 0</span>
</code></pre></div></div>

<h2 id="diving-deeper-into-the-process">Diving Deeper Into The Process</h2>

<p>Let’s work through one more together and write out a function that takes in an argument of an array of numbers and adds them together.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">let</span> <span class="nx">numbers</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">];</span>

<span class="nx">getSum</span><span class="p">(</span><span class="nx">numbers</span><span class="p">);</span> <span class="c1">// 10</span>
</code></pre></div></div>

<p>One of the most basic patterns of recursion is when you can reduce a problem to a smaller one and then keep reducing until you can’t do it anymore. This is also known as natural recursion.</p>

<p>It can be helpful to break down what each step of this problem looks like. Here’s one way to visualize the call stack:</p>

<p><img src="https://i.imgur.com/Ly55ggk.png" alt="visualization of the recursive call stack" /></p>

<p><strong>Solution:</strong></p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getSum</span> <span class="o">=</span> <span class="nx">nums</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// base case</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="c1">// get closer to base case</span>
  <span class="kd">let</span> <span class="nx">firstNumber</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
  
  <span class="k">return</span> <span class="nx">firstNumber</span> <span class="o">+</span> <span class="nx">getSum</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="tail-call-optimization">Tail Call Optimization</h3>

<p>To get around the stack overflow issue, one can use <em>tail call optimization</em>.  A tail call refers to the last action that is <strong>executed</strong>. In this scenario, the recursive call must be the <em>last statement</em> of the recursive function.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Example:</span>
<span class="c1">// Create a getSum fn that adds all of the numbers in an array</span>

<span class="c1">// Example that is not optimized due to it returning an operation</span>
<span class="k">return</span> <span class="nx">firstNumber</span> <span class="o">+</span> <span class="nx">getSum</span><span class="p">(</span><span class="nx">nums</span><span class="p">);</span>

<span class="c1">// Example suited for tail call optimization</span>
<span class="k">return</span> <span class="nx">getSum</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">sum</span> <span class="o">+</span> <span class="nx">firstNumber</span><span class="p">);</span>
</code></pre></div></div>

<p>Notice with the first example, we are returning an operation.  In this scenario, this would need to be added to the callstack because this cannot be executed until we know what <code class="highlighter-rouge">getSum(allNumbers)</code> returns.  In the second example, we are only returning the recursive function and passing what arguments we need to keep track of the sum, making this perfect for Tail Call Optimization so that it can execute immediately instead of stacking in memory. Taking what we understand from this, let’s make some adjustments to the solution we just worked through!</p>

<p><strong>Solution with Tail Call Optimization:</strong></p>
<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getSum</span> <span class="o">=</span> <span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">sum</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="c1">// base case</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">nums</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">sum</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="c1">// get closer to base case</span>
  <span class="kd">let</span> <span class="nx">firstNumber</span> <span class="o">=</span> <span class="nx">nums</span><span class="p">.</span><span class="nx">shift</span><span class="p">();</span>
  
  <span class="k">return</span> <span class="nx">getSum</span><span class="p">(</span><span class="nx">nums</span><span class="p">,</span> <span class="nx">sum</span> <span class="o">+</span> <span class="nx">firstNumber</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Note that for Javascript, this optimization is only available in Safari.  (Chrome, FireFox, and other browsers are not optimized currently).  Read <a href="https://stackoverflow.com/questions/54719548/tail-call-optimization-implementation-in-javascript-engines">here</a> to understand more of the history about this.</p>

<p>In Ruby, this optimization is not available by default.  You <em>can</em> configure the Ruby compiler to enable tail call optimization however.  If you’re interested, follow the <a href="https://nithinbekal.com/posts/ruby-tco/">article</a> here!</p>

<h2 id="exercises">Exercises</h2>

<p>The best way to start understanding recursion is to just try doing it!  Feel free to work through these problems in either JavaScript or Ruby.</p>

<h3 id="exercise-1">Exercise 1</h3>

<p>Reverse a string.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// create a function which takes a string of characters and</span>
<span class="c1">// recursively calls itself to reverse the string</span>

<span class="c1">// e.g.</span>

<span class="kd">let</span> <span class="nx">reversedString</span> <span class="o">=</span> <span class="nx">reverse</span><span class="p">(</span><span class="dl">'</span><span class="s1">Ariel</span><span class="dl">'</span><span class="p">)</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">reversedString</span><span class="p">);</span> <span class="c1">// leirA</span>
</code></pre></div></div>

<h3 id="exercise-2">Exercise 2</h3>

<p>Calculate a number to a specific power.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// create a function which takes a number and an exponent and</span>
<span class="c1">// recursively calls itself to calculate the product</span>

<span class="c1">// e.g.</span>
<span class="kd">let</span> <span class="nx">base</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">exponent</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="kd">let</span> <span class="nx">product</span> <span class="o">=</span> <span class="nx">power</span><span class="p">(</span><span class="nx">base</span><span class="p">,</span> <span class="nx">exponent</span><span class="p">)</span>  <span class="c1">// 2 to the 4th power</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">product</span><span class="p">);</span>  <span class="c1">// 16</span>
</code></pre></div></div>

<h3 id="exercise-3">Exercise 3</h3>

<p>In mathematics, the factorial of a non-negative integer is the product of all positive integers less than or equal to n. For example, the factorial of 5 is 120.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="mi">5</span> <span class="nx">x</span> <span class="mi">4</span> <span class="nx">x</span> <span class="mi">3</span> <span class="nx">x</span> <span class="mi">2</span> <span class="nx">x</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">120</span>
</code></pre></div></div>

<p>Write a recursive function that calculates the factorial of a number.</p>

<h3 id="exercise-4">Exercise 4</h3>

<p>The Collatz conjecture applies to positive numbers and speculates that it is always possible to <code class="highlighter-rouge">get back to 1</code> if you follow these steps:</p>

<ul>
  <li>If <code class="highlighter-rouge">n</code> is 1, stop.</li>
  <li>Otherwise, if <code class="highlighter-rouge">n</code> is even, repeate this process on <code class="highlighter-rouge">n/2</code></li>
  <li>Otherise, if <code class="highlighter-rouge">n</code> is odd, repeat this process on <code class="highlighter-rouge">3n + 1</code></li>
</ul>

<p>Write a recursive function that calculates how many steps it takes to get to 1</p>

<table>
  <thead>
    <tr>
      <th>n</th>
      <th style="text-align: center">collatz(n)</th>
      <th>Steps</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2</td>
      <td style="text-align: center">1</td>
      <td>2 -&gt; 1</td>
    </tr>
    <tr>
      <td>3</td>
      <td style="text-align: center">7</td>
      <td>3 -&gt; 10 -&gt; 5 -&gt; 16 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1</td>
    </tr>
    <tr>
      <td>4</td>
      <td style="text-align: center">2</td>
      <td>4 -&gt; 2 -&gt; 1</td>
    </tr>
    <tr>
      <td>5</td>
      <td style="text-align: center">5</td>
      <td>5 -&gt; 16 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1</td>
    </tr>
    <tr>
      <td>6</td>
      <td style="text-align: center">8</td>
      <td>6 -&gt; 3 -&gt; 10 -&gt; 5 -&gt; 16 -&gt; 8 -&gt; 4 -&gt; 2 -&gt; 1</td>
    </tr>
  </tbody>
</table>

<h3 id="bonus">Bonus</h3>
<p>Now try and solve these problems with tail call optimization!</p>
:ET