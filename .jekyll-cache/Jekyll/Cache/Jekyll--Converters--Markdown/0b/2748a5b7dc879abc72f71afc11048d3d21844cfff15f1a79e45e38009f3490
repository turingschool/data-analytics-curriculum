I"—v<p><strong>Standards</strong></p>

<ul>
  <li>Understand the idea of a Stack as a general-purpose FILO data structure</li>
  <li>Review the standard method and control-flow patterns we‚Äôve encountered in programs</li>
  <li>Understand the ‚Äúinside-out‚Äù model of evaluating program arguments</li>
  <li>Understand how Ruby uses a stack to model flow-of-control between methods</li>
  <li>Understant how Ruby‚Äôs stack and bindings collaborate to control local scope</li>
</ul>

<h3 id="pre-work">Pre-work</h3>

<ul>
  <li>Watch <a href="https://www.youtube.com/watch?v=beqqGIdabrE">this video</a></li>
</ul>

<h2 id="section-1---the-stack-data-structure">Section 1 - The ‚ÄúStack‚Äù Data Structure</h2>

<ul>
  <li>Stack ‚Äì a fundamental Data Structure in computer science</li>
  <li>Stacks are a type of <strong>Queue</strong></li>
  <li>Follows ‚Äúfirst-in-last-out‚Äù semantics</li>
  <li>Important point about a stack: Things on top of the stack cover
or hide things on the bottom ‚Äì you can‚Äôt see or access lower elements
while there is a top element</li>
  <li>Great for modeling processes that ‚Äúnest‚Äù, such
that the inner (or top-most, depending how you look at it) portions
have to complete before the outer/bottom portions</li>
</ul>

<p>Terminology</p>

<ul>
  <li><strong>Top</strong> - Most recently added element (sometimes people will say ‚Äúbottom‚Äù if they are envisioning the stack growing from top down)</li>
  <li><strong>Pushing</strong> - adding a new element to the top of the stack</li>
  <li><strong>Popping</strong> - removing the top element from the stack</li>
</ul>

<p><strong>Exercise (Optional) (Hard)</strong></p>

<p>Here‚Äôs a common programming challenge that lends itself to
an elegant solution with a stack: <a href="https://github.com/turingschool/challenges/blob/master/well_formed_strings.markdown">Well-Formed Strings</a></p>

<h2 id="section-2---the-stack-as-program-execution-model">Section 2 - The ‚ÄúStack‚Äù as Program Execution Model</h2>

<ul>
  <li>Another ubiquitous application of stacks: managing flow of execution and context within a computer program</li>
  <li>A Stack vs. <strong>The Stack</strong> ‚Äì The program stack is so omnipresent we often refer to is as The Stack</li>
  <li>What are Stacks good at? Problems that require nesting or ordered execution</li>
  <li>Programs ‚Äúnest‚Äù from one method call or line of code into another</li>
  <li>Interpreter uses a Stack to model and manage this process</li>
</ul>

<p>Let‚Äôs kick off with a basic example. Open pry and execute the following code snippet:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">module_one</span>
  <span class="nb">puts</span> <span class="s2">"projects are:"</span>
  <span class="nb">puts</span> <span class="n">projects</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">projects</span>
  <span class="s2">"enigma, complete me, headcount"</span>
<span class="k">end</span>

<span class="n">module_one</span>
</code></pre></div></div>

<p><strong>Discussion:</strong> What happens when we evaluate this code?</p>

<p>Series of steps:</p>

<ol>
  <li>Define each method (ruby evaluates the definitions)</li>
  <li>Ruby invokes <code class="highlighter-rouge">module_one</code></li>
  <li><code class="highlighter-rouge">module_one</code> calls <code class="highlighter-rouge">puts</code>, passing to it a new string (<code class="highlighter-rouge">"projects are:"</code>)</li>
  <li><code class="highlighter-rouge">puts</code> evaluates, printing some text and then <strong>RETURNING</strong> a value back to the place from which it was called (<strong>Q:</strong> What is the return value of puts)</li>
  <li><code class="highlighter-rouge">module_one</code> wants to call <code class="highlighter-rouge">puts</code> again, <strong>but</strong> this time it needs to call <code class="highlighter-rouge">projects</code> first in order to get the value to provide to <code class="highlighter-rouge">puts</code>, so it first calls <code class="highlighter-rouge">projects</code></li>
  <li><code class="highlighter-rouge">module_one</code> now calls <code class="highlighter-rouge">puts</code> again, passing it the value it got from <code class="highlighter-rouge">projects</code></li>
  <li><code class="highlighter-rouge">puts</code> evaluates, printing some text and again returning a value back to the place from which it was called</li>
</ol>

<p>This small example illustrates 2 fundamental rules of program
execution:</p>

<ol>
  <li>An outer method is able to ‚Äúcall into‚Äù another method, and it will
wait until the inner method completes before continuing its
execution</li>
  <li>The inner method is able to generate a value and <strong>return</strong> it back
to the outer method, which can then access and use it.</li>
</ol>

<h2 id="exercise-thinking-about-return-values">Exercise: Thinking About Return Values</h2>

<p>In your notebook, write down the answers to these 2 questions:</p>

<ol>
  <li>What does it mean for a method to <em>return</em> a value to another method</li>
  <li>What are some of the things that can happen to a returned value (try to come up with at least 2)</li>
</ol>

<h2 id="illustrating-the-stack">Illustrating the Stack</h2>

<p><strong>Additional Terminology</strong></p>

<ul>
  <li><strong>Frame</strong> - When discussing the Stack in the context of program
execution, we refer to each ‚Äúelement‚Äù on the stack as a Frame.</li>
  <li><strong>Winding / Unwinding</strong> - Synonyms for Pushing / Popping</li>
</ul>

<p>With these ideas in mind, let‚Äôs dig into the previous example and illustrate
what‚Äôs happening.</p>

<p><strong>Materials</strong></p>

<p>(Instructor should provide arts &amp; crafts materials)</p>

<ul>
  <li>Index cards</li>
  <li>Markers or Colored Pencils</li>
</ul>

<h3 id="visualizing-stack-exercise-1---module-one">Visualizing Stack Exercise 1 - Module One</h3>

<p>Let‚Äôs walk through tracking the stack in the previous example. For now, we‚Äôre going to focus only on:</p>

<ul>
  <li>Which methods are called</li>
  <li>In what order</li>
</ul>

<p>As we walk through the code, each time a method is invoked, put an index card for it onto the stack.</p>

<p>When the method is finished, remove its card from the stack.</p>

<p><strong>Question:</strong> From a Stack perspective, how do you know when a program is ‚Äúdone‚Äù?</p>

<h2 id="section-3---the-stack-and-execution-context">Section 3 - The Stack and Execution Context</h2>

<h3 id="ruby-metaphysics-what-things-are-there">Ruby Metaphysics: What Things Are There?</h3>

<p>When we think about evaluating Ruby code, especially from a perspective of reading a chunk of code and trying to mentally evaluate it in our head, we can generally boil it down to the idea of performing operations of values.</p>

<p>‚ÄúOperations‚Äù generally come in the form of methods (defining some chunk of behavior we want to perform).</p>

<p>So what are ‚Äúvalues‚Äù? As we have seen, all values in Ruby are Objects of some sort. But where do they live? It turns out at any given time there are really a handful of places where values can be found. We will focus on 2:</p>

<ol>
  <li>Local Variables (<code class="highlighter-rouge">x = 7</code>, etc)</li>
  <li>The <strong>Current Object</strong> (i.e. <code class="highlighter-rouge">self</code>)</li>
</ol>

<p>From a structural perspective, evaluating a Ruby program requires us to do 2 things:</p>

<ol>
  <li>Track the sequential execution of methods in the order listed in the program (as we did in the previous stack example)</li>
  <li>Track which objects are currently available to our program: What <strong>local variables</strong> are defined and what is <strong>self</strong>.</li>
</ol>

<h3 id="stack-visualization-with-local-context">Stack Visualization With Local Context</h3>

<p>It turns out the stack is also used to manage these pieces of information. In the previous examples we showed the stack managing flow / progress through the program. Now let‚Äôs walk through an example that adds in these 2 important concepts of Local State and Current Object.</p>

<p><strong>Local Variable Definitions</strong></p>

<ul>
  <li>Local variables can be defined anywhere in a ruby program</li>
  <li>Variables are defined within a given ‚Äúscope‚Äù</li>
  <li>Common scopes we encounter: methods and blocks (each creates its own independent scope)</li>
  <li>Passing a method argument creates a new local variable with the name of the argument</li>
</ul>

<p><strong>Self</strong></p>

<ul>
  <li><code class="highlighter-rouge">self</code> is ruby‚Äôs way to identify the current object</li>
  <li>In reality there are 2 things we need to know about <code class="highlighter-rouge">self</code></li>
  <li>
    <ol>
      <li>What is its <strong>Class</strong> (since this gives it methods)</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>What are its <strong>Instance Variables</strong> (since this gives it state)</li>
    </ol>
  </li>
</ul>

<p>When thinking about how the stack tracks <code class="highlighter-rouge">self</code>, we‚Äôll show this by tracking
self as a reference to a Class and a collection of instance variables</p>

<h3 id="exercise-visualizing-the-stack-with-state-mixed-in">Exercise: Visualizing the Stack with State Mixed In</h3>

<p>Let‚Äôs use our index cards to look at another example.</p>

<p>This time, we‚Äôll use the cards to track 3 things:</p>

<ol>
  <li>What is the order of execution (shown by stacking cards)</li>
  <li>What are the current local variables (list these on each card)</li>
  <li>What is the current object (<code class="highlighter-rouge">self</code>) (list this on each card. include the object‚Äôs Class and any ivars it contains)</li>
</ol>

<p><strong>Setup</strong></p>

<p>On your desk, create space for 3 independent stacks of index cards. It would be ideal to label each space using a post-it note or something similar. It might come out looking somthing like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                       Current
 Locals      self      Method
--------   --------   --------
|      |   |      |   |      |
|      |   |      |   |      |
--------   --------   --------
</code></pre></div></div>

<p>As we step through the next simple program, we‚Äôre going to place a card on <em>each</em> Stack, representing the current state of that column.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Dog</span>
  <span class="nb">attr_reader</span> <span class="ss">:name</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
    <span class="vi">@name</span> <span class="o">=</span> <span class="nb">name</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">chase</span><span class="p">(</span><span class="n">cat</span><span class="p">)</span>
    <span class="n">dog_reaction</span> <span class="o">=</span> <span class="s2">"woof"</span>
	<span class="n">cat</span><span class="p">.</span><span class="nf">be_chased</span><span class="p">(</span><span class="nb">self</span><span class="p">)</span>
	<span class="nb">puts</span> <span class="n">dog_reaction</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">Cat</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">breed</span><span class="p">)</span>
    <span class="vi">@breed</span> <span class="o">=</span> <span class="n">breed</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">be_chased</span><span class="p">(</span><span class="n">dog</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="s2">"oh no being chased by this dog:"</span>
	<span class="nb">puts</span> <span class="n">dog</span><span class="p">.</span><span class="nf">name</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">sassy</span> <span class="o">=</span> <span class="no">Cat</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"Siamese"</span><span class="p">)</span>
<span class="n">chance</span> <span class="o">=</span> <span class="no">Dog</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"Chance"</span><span class="p">)</span>
<span class="n">chance</span><span class="p">.</span><span class="nf">chase</span><span class="p">(</span><span class="n">sassy</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="group-time-wrapup--why-bother">Group Time Wrapup ‚Äì Why Bother</h3>

<ul>
  <li>Most essential challenge in starting programming: Getting over the ‚ÄúMental Model‚Äù hump</li>
  <li>As beginners we tend to view a program in the way that we initially interact with it ‚Äì <strong>As Text</strong></li>
  <li>However the actual operation is much richer ‚Äì applying a series of complex but elegant rules to properly evaluate our instructions</li>
  <li>Experiences programmers learn to see behind the text and work with the underlying <strong>Mental Model</strong></li>
  <li>This is largely what accounts for the perceived gulf between a novice and even an intermediate developer</li>
  <li>Once we get over the hump of modeling how the program works in our mind, the manipulations we can perform become vastly more sophisticated</li>
</ul>

<h2 id="paired-exercises---stack-visualization">Paired Exercises - Stack Visualization:</h2>

<p>Now that we‚Äôve seen how this all works, let‚Äôs get some more practice in. For this section, you‚Äôll pair up with another student and walk through the remaining examples together, visualizing the 3 pieces of stack information as we looked at in the previous example.</p>

<p>However, this time, we have a tool to make things a bit easier. The inimitable Josh Cheek has made a sweet tool that can perform similar visualizations in the terminal. Run the following steps in your terminal:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem install hub
hub clone turingschool-examples/spelunk
cd spelunk
gem install rouge --no-rdoc --no-ri
./bin/spelunk examples/cook_pizza.rb
</code></pre></div></div>

<p>This will launch you into a simple interactive ruby program that will
allow you to step through the stack as the program executes.</p>

<p>Use the following keybindings:</p>

<ul>
  <li><code class="highlighter-rouge">Return</code> - step to the next method / line</li>
  <li><code class="highlighter-rouge">Up Arrow</code> - go back up the stack one step</li>
  <li><code class="highlighter-rouge">Down Arrow</code> - go back down the stack one step</li>
</ul>

<p>You‚Äôll use this program in the following exercises to evaluate your interpretation of the program‚Äôs execution <strong>AFTER</strong> you have walked through it once using Index Cards.</p>

<h3 id="exercise-1---making-pizza">Exercise 1 - Making Pizza</h3>

<p>Do each exercise twice: Once with index cards and once using the <code class="highlighter-rouge">spelunk</code> program you cloned earlier.</p>

<p>Each time, pay attention to:</p>

<ol>
  <li>Order of execution (what things go onto the stack and in what order)</li>
  <li>Local variable assignments (what are the values of local variables in each case)</li>
  <li><code class="highlighter-rouge">Class</code> and <code class="highlighter-rouge">ivars</code> of current <code class="highlighter-rouge">self</code> value</li>
</ol>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Pizza</span>
  <span class="nb">attr_reader</span> <span class="ss">:toppings</span><span class="p">,</span> <span class="ss">:cooked</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">toppings</span><span class="p">)</span>
    <span class="vi">@toppings</span> <span class="o">=</span> <span class="n">toppings</span>
    <span class="vi">@cooked</span> <span class="o">=</span> <span class="kp">false</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">cook!</span>
    <span class="vi">@cooked</span> <span class="o">=</span> <span class="kp">true</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">description</span>
    <span class="k">if</span> <span class="vi">@cooked</span>
      <span class="s2">"Pizza with </span><span class="si">#{</span><span class="n">toppings</span><span class="si">}</span><span class="s2"> that has been cooked."</span>
    <span class="k">else</span>
      <span class="s2">"Pizza with </span><span class="si">#{</span><span class="n">toppings</span><span class="si">}</span><span class="s2"> that has NOT been cooked."</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">PizzaOven</span>
  <span class="k">def</span> <span class="nf">cook_pizza</span><span class="p">(</span><span class="n">pizza</span><span class="p">)</span>
    <span class="n">pizza</span><span class="p">.</span><span class="nf">cook!</span>
    <span class="n">pizza</span><span class="p">.</span><span class="nf">description</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">za</span> <span class="o">=</span> <span class="no">Pizza</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"anchovies"</span><span class="p">)</span>
<span class="n">oven</span> <span class="o">=</span> <span class="no">PizzaOven</span><span class="p">.</span><span class="nf">new</span>
<span class="nb">puts</span> <span class="n">oven</span><span class="p">.</span><span class="nf">cook_pizza</span><span class="p">(</span><span class="n">za</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="exercise-2a---cooking-spaghetti">Exercise 2a - Cooking Spaghetti</h3>

<p><strong>For this section, choose one of 2a or 2b</strong></p>

<p>From the example file <a href="https://github.com/JoshCheek/object-model-with-lovisa/blob/master/examples/cook_spaghetti.rb">here</a></p>

<p>Once you‚Äôve gone through with index cards, try it with:
<code class="highlighter-rouge">bin/spelunk examples/cook_spaghetti.rb</code></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">cook_dinner</span><span class="p">(</span><span class="n">ingredients</span><span class="p">,</span> <span class="n">guests</span><span class="p">)</span>
  <span class="n">prepared_ingredients</span> <span class="o">=</span> <span class="n">get_ingredients</span><span class="p">(</span><span class="n">ingredients</span><span class="p">)</span>
  <span class="n">dish</span> <span class="o">=</span> <span class="n">mix</span><span class="p">(</span><span class="n">prepared_ingredients</span><span class="p">)</span>
  <span class="n">serve</span><span class="p">(</span><span class="n">dish</span><span class="p">,</span> <span class="n">guests</span><span class="p">)</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">get_ingredients</span><span class="p">(</span><span class="n">ingredients</span><span class="p">)</span>
  <span class="n">ingredients</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">ingredient</span><span class="o">|</span>
    <span class="n">prepare</span><span class="p">(</span><span class="n">ingredient</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">prepare</span><span class="p">(</span><span class="n">ingredient</span><span class="p">)</span>
  <span class="s2">"Preparing </span><span class="si">#{</span><span class="n">ingredient</span><span class="si">}</span><span class="s2">!"</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">mix</span><span class="p">(</span><span class="n">prepared_ingredients</span><span class="p">)</span>
  <span class="n">prepared_ingredients</span><span class="p">.</span><span class="nf">map</span> <span class="k">do</span> <span class="o">|</span><span class="n">prepared_ingredient</span><span class="o">|</span>
    <span class="n">add_to_dish</span><span class="p">(</span><span class="n">prepared_ingredient</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">add_to_dish</span><span class="p">(</span><span class="n">prepared_ingredient</span><span class="p">)</span>
  <span class="s2">"Adding </span><span class="si">#{</span><span class="n">prepared_ingredient</span><span class="si">}</span><span class="s2"> to the dish!"</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">serve</span><span class="p">(</span><span class="n">dish</span><span class="p">,</span> <span class="n">guests</span><span class="p">)</span>
  <span class="n">pretty_preparations</span> <span class="o">=</span> <span class="n">dish</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s2">", "</span><span class="p">)</span>
  <span class="n">pretty_guests</span> <span class="o">=</span> <span class="n">guests</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s2">", "</span><span class="p">)</span>
  <span class="s2">"To serve </span><span class="si">#{</span><span class="n">pretty_guests</span><span class="si">}</span><span class="s2"> "</span> <span class="o">&lt;&lt;</span>
    <span class="s2">"I had to </span><span class="si">#{</span><span class="n">pretty_preparations</span><span class="si">}</span><span class="s2">."</span>
<span class="k">end</span>

<span class="n">ingredients</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"spaghetti"</span><span class="p">,</span> <span class="s2">"onion"</span><span class="p">,</span>
               <span class="s2">"olive oil"</span><span class="p">,</span> <span class="s2">"tomatoes"</span><span class="p">,</span>
               <span class="s2">"garlic"</span><span class="p">,</span> <span class="s2">"basil"</span><span class="p">]</span>
<span class="n">guests</span>      <span class="o">=</span> <span class="p">[</span><span class="s2">"Deborah"</span><span class="p">,</span> <span class="s2">"Scott"</span><span class="p">,</span>
               <span class="s2">"Kimmie"</span><span class="p">,</span> <span class="s2">"Marina"</span><span class="p">,</span> <span class="s2">"Brennan"</span><span class="p">]</span>
<span class="nb">puts</span> <span class="n">cook_dinner</span><span class="p">(</span><span class="n">ingredients</span><span class="p">,</span> <span class="n">guests</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="exercise-2b---recursive-doubling">Exercise 2b - Recursive Doubling</h3>

<p>From the example file <a href="https://github.com/JoshCheek/object-model-with-lovisa/blob/master/examples/double.rb">here</a></p>

<p>Once you‚Äôve gone through with index cards, try it with: <code class="highlighter-rouge">bin/spelunk examples/double.rb</code></p>

<div class="language-pry highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="go">def double(n)
  if n == 0
    0
  elsif n &lt; 0
    -2 + double(n+1)
  else
    2 + double(n-1)
  end
end
</span><span class="err">
</span><span class="go">puts double 6
</span></code></pre></div></div>

<h3 id="advanced-usage-rubys-binding-class-optional">Advanced usage: Ruby‚Äôs <code class="highlighter-rouge">Binding</code> Class (Optional)</h3>

<p>The role of managing local scope and variable lookup is partly
managed by ruby‚Äôs <code class="highlighter-rouge">Binding</code> class. What is a binding?</p>

<ul>
  <li><code class="highlighter-rouge">Binding</code> is a class</li>
  <li><code class="highlighter-rouge">Binding</code> is ruby‚Äôs abstraction around local scopes within programs</li>
  <li><code class="highlighter-rouge">Binding</code> unifys 2 key ideas: <code class="highlighter-rouge">local_variables</code> and a <code class="highlighter-rouge">self</code> reference</li>
  <li>We can retrieve the current one using the special <code class="highlighter-rouge">binding</code> method</li>
</ul>

<p>Try the following examples in pry. We‚Äôre going to illustrate 3 points:</p>

<ul>
  <li><code class="highlighter-rouge">binding</code> stores local variables</li>
  <li><code class="highlighter-rouge">binding</code> can evaluate values within its context using <code class="highlighter-rouge">eval</code></li>
  <li><code class="highlighter-rouge">binding</code> stores a reference to the current <code class="highlighter-rouge">self</code> context</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="nb">binding</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Binding:0x007f86dd9c61c8&gt;</span>
<span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="nb">binding</span><span class="p">.</span><span class="nf">class</span>
<span class="o">=&gt;</span> <span class="no">Binding</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="nb">binding</span><span class="p">.</span><span class="nf">local_variables</span>
<span class="o">=&gt;</span> <span class="p">[</span><span class="ss">:__</span><span class="p">,</span> <span class="ss">:_</span><span class="p">,</span> <span class="ss">:_dir_</span><span class="p">,</span> <span class="ss">:_file_</span><span class="p">,</span> <span class="ss">:_ex_</span><span class="p">,</span> <span class="ss">:_pry_</span><span class="p">,</span> <span class="ss">:_out_</span><span class="p">,</span> <span class="ss">:_in_</span><span class="p">]</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
<span class="o">=&gt;</span> <span class="mi">10</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="s2">"pizza"</span>
<span class="o">=&gt;</span> <span class="s2">"pizza"</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="nb">binding</span><span class="p">.</span><span class="nf">local_variables</span>
<span class="o">=&gt;</span> <span class="p">[</span><span class="ss">:a</span><span class="p">,</span> <span class="ss">:x</span><span class="p">,</span> <span class="ss">:__</span><span class="p">,</span> <span class="ss">:_</span><span class="p">,</span> <span class="ss">:_dir_</span><span class="p">,</span> <span class="ss">:_file_</span><span class="p">,</span> <span class="ss">:_ex_</span><span class="p">,</span> <span class="ss">:_pry_</span><span class="p">,</span> <span class="ss">:_out_</span><span class="p">,</span> <span class="ss">:_in_</span><span class="p">]</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="nb">binding</span><span class="p">.</span><span class="nf">eval</span><span class="p">(</span><span class="s2">"a"</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="s2">"pizza"</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="nb">binding</span><span class="p">.</span><span class="nf">eval</span><span class="p">(</span><span class="s2">"x"</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="mi">10</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="nb">binding</span><span class="p">.</span><span class="nf">eval</span><span class="p">(</span><span class="s2">"self"</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="n">main</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="vi">@a</span> <span class="o">=</span> <span class="s2">"calzone"</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="nb">binding</span><span class="p">.</span><span class="nf">instance_variables</span>
<span class="o">=&gt;</span> <span class="p">[]</span>
<span class="n">pry</span><span class="p">(</span><span class="n">main</span><span class="p">)</span><span class="o">&gt;</span> <span class="nb">binding</span><span class="p">.</span><span class="nf">eval</span><span class="p">(</span><span class="s2">"self"</span><span class="p">).</span><span class="nf">instance_variables</span>
<span class="o">=&gt;</span> <span class="p">[</span><span class="ss">:@pizza</span><span class="p">,</span> <span class="ss">:@a</span><span class="p">]</span>
</code></pre></div></div>
:ET