I"fN<h2 id="higher-order-ruby--programming-with-blocks-procs-and-lambdas">Higher Order Ruby – Programming with Blocks, Procs, and Lambdas</h2>

<h3 id="learning-goals">Learning Goals</h3>

<ul>
  <li>Develop a mental model for what happens when we use a “block” in ruby</li>
  <li>Understand how to create new Proc and Lambda objects</li>
  <li>Understand how to call a Proc or Lambda</li>
  <li>Understand how to accept a block passed to your method and invoke it using <code class="highlighter-rouge">yield</code> and using the <code class="highlighter-rouge">&amp;block</code> syntax</li>
  <li>Take a first sip from the cup of functional programming arcana</li>
</ul>

<h3 id="warmup">Warmup</h3>

<p>Write a bit of ruby code to do the following:</p>

<ol>
  <li>Take the names of the 2 people sitting next to you</li>
  <li>Generate a new list of those names where all of the vowels are removed</li>
  <li>Write this once using an enumerable and once without (use for, a loop, etc)</li>
</ol>

<p>When you finish, take a few minutes to think about what the differences between these 2 pieces of code.</p>

<h3 id="discussion--blocks-procs-lambdas--oh-my">Discussion – Blocks, Procs, Lambdas – OH MY</h3>

<p>Discussion/Questions:</p>

<ul>
  <li>In what context have you used Blocks in ruby code?</li>
  <li>What does a Block represent?</li>
  <li>Give 3 code snippets using a block</li>
  <li>What would these snippets look like <strong>without</strong> a block?</li>
</ul>

<h3 id="terminology--blocks-vs-procslambdas">Terminology – Blocks vs. Procs/Lambdas</h3>

<ul>
  <li>blocks – <em>technically</em> a block is just part of the language’s syntax</li>
  <li>a “Block” is really just a block of code – a syntactically contained segment of source code</li>
  <li>“blocks” appear in other languages (Java, Javascript, etc) just as they do in ruby – to indicate a self-contained chunk of code. The <code class="highlighter-rouge">{ }</code> notation is very common for this, and you’ll see it in Java, JS, C, etc.</li>
  <li>Ruby borrows this notation, but also adds its own touch with the <code class="highlighter-rouge">do</code> / <code class="highlighter-rouge">end</code> variation</li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/block">Example JS Reference</a></li>
</ul>

<h4 id="technical-terminology-vs-common-usage">Technical Terminology vs. Common Usage</h4>

<ul>
  <li>However generally when people talk about “blocks” in ruby, they’re actually talking about what happens when you pass
a block to a method</li>
  <li>Remember – a <em>block</em> is technically just the textual indication that some chunk of code should stand on its own</li>
  <li>But what actually happens under the hood with the text that we are passing in?</li>
  <li>Consider a similar example: we often say “Array” to mean the syntactic convention of surrounding a list of comma-separated elements by square brackets (<code class="highlighter-rouge">[1,2,3,4]</code>)</li>
  <li>But <em>technically</em> <code class="highlighter-rouge">Array</code> is the thing (an Object) that ruby creates for us automatically when we type <code class="highlighter-rouge">[1,2,3,4]</code></li>
  <li>So what <strong>Object</strong> does ruby make for us when we type a <strong>Block</strong> of code surrounded by either <code class="highlighter-rouge">{ }</code> or <code class="highlighter-rouge">do</code> / <code class="highlighter-rouge">end</code>?</li>
  <li>Turns out this object is a <code class="highlighter-rouge">Proc</code> – <code class="highlighter-rouge">Proc</code> is the Ruby class which represents the idea of “a chunk of code saved for later use”</li>
</ul>

<h3 id="so-what-actually-happens-when-we-pass-a-block-to-a-method">So what actually happens when we pass a block to a method?</h3>

<p>Rules:</p>

<ol>
  <li>Ruby allows a Block to be passed to any method as an optional final argument</li>
  <li>It’s up to the methods implementation to determine how (or even if) to use the provided block</li>
</ol>

<p><strong>Exercise</strong></p>

<ol>
  <li>Define a method <code class="highlighter-rouge">print_name(name)</code> which takes a name as an argument and prints it</li>
  <li>Call that method using your name</li>
  <li>Call that name using your name <em>AND</em> a block of your choosing</li>
</ol>

<p>What happened to the block you provided? Why does ruby not complain when you pass the block even though it’s not being used? (<strong>Hint:</strong> see rules 1 and 2 above)</p>

<h3 id="using-a-block-passed-to-your-method">Using a block passed to your method</h3>

<p>There are 2 ways to do this</p>

<h4 id="1-yield-and-block_given-methods">1. <code class="highlighter-rouge">yield</code> and <code class="highlighter-rouge">block_given?</code> methods</h4>

<p><strong>Exercise – yielding from a method</strong></p>

<p>Revisit your <code class="highlighter-rouge">print_name</code>. From inside the method, add a line that simply calls the method <code class="highlighter-rouge">yield</code>. It may look something like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_name</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"HI, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">yield</span>
<span class="k">end</span>
</code></pre></div></div>

<p><strong>Exercise</strong></p>

<p>Now try your 2 examples from before:</p>

<ol>
  <li>Call this version of <code class="highlighter-rouge">print_name</code> with a block</li>
  <li>Call this version without passing a block</li>
</ol>

<p>Which works, which doesnt?</p>

<p><strong><code class="highlighter-rouge">block_given?</code></strong></p>

<p>Special method that lets us check if a block was actually provided to avoid LocalJumpErrors</p>

<h4 id="2-explicit-argument-capturing-using-the--operator">2. Explicit argument capturing using the <code class="highlighter-rouge">&amp;</code> operator</h4>

<p>We can also explicitly “capture” the block parameter:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_name</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"HI, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
  <span class="nb">puts</span> <span class="n">block</span><span class="p">.</span><span class="nf">class</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="proc-by-any-other-name">Proc by any other name</h3>

<p>In the previous example, what did we see? What object did ruby turn our “block” into?</p>

<ul>
  <li><code class="highlighter-rouge">Proc</code> – ruby’s class for representing stored collections fo ruby instructions – i.e. the output that is actually generated by a block</li>
  <li>Term <code class="highlighter-rouge">proc</code> comes from _proc_edure</li>
  <li>Tries to capture the idea of a proc as an actual process that is stored for later</li>
  <li>Other languages use other terms – function, lambda, routine, functor</li>
  <li>rubyists <em>create</em> and pass blocks all the time – e.g. every time you use an enumerable</li>
  <li>but not many people actually write code that <em>accepts</em> blocks</li>
  <li>even though ruby has great support for this type of programming (and it can be used to do powerful things) it’s not a very common part of the languages style</li>
</ul>

<h3 id="invoking-a-proc">Invoking a Proc</h3>

<p>If a proc represents the idea of a stored “procedure”, we need some way to “un-store” it – i.e. to evalate it</p>

<p>3 ways:</p>

<ol>
  <li><code class="highlighter-rouge">Proc#call</code></li>
  <li><code class="highlighter-rouge">Proc.()</code></li>
  <li><code class="highlighter-rouge">Proc[]</code></li>
</ol>

<p><strong>Exercise</strong></p>

<p><strong>First</strong>, define a simple proc in pry:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">my_proc</span> <span class="o">=</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">i</span><span class="o">|</span> <span class="nb">puts</span> <span class="s2">"you provided i: </span><span class="si">#{</span><span class="n">i</span><span class="si">}</span><span class="s2">"</span> <span class="p">}</span>
</code></pre></div></div>

<p><strong>Second</strong>, use the 3 methods described above to “invoke” the proc with an argument</p>

<p><strong>Third</strong>, revisit our example from above and use these techniques on the <code class="highlighter-rouge">block</code> variable that we captured as part of our method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_name</span><span class="p">(</span><span class="nb">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block_that_was_passed_in</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"HI, </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
  <span class="c1"># Use one of the 3 Proc methods to call the block here</span>
<span class="k">end</span>
</code></pre></div></div>

<p><strong>Note</strong> In practice, <code class="highlighter-rouge">Proc#call</code> is probably the most common of these.</p>

<h3 id="scope-local-variables-and-closures">Scope, local variables, and closures</h3>

<ul>
  <li>Recall how we describe an object: a collection of behavior combined with labels</li>
  <li>Procs have some similarities – they bind a chunk of code to a collection of local variables; we call this collection of variables a “lexical context”</li>
</ul>

<p>Block scope example. Ever wonder why this works?</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="o">=</span> <span class="mi">5</span>

<span class="k">def</span> <span class="nf">method_cant_see_surrounding_local_vars</span>
  <span class="nb">puts</span> <span class="n">x</span>
<span class="k">end</span>

<span class="mi">5</span><span class="p">.</span><span class="nf">times</span> <span class="k">do</span>
  <span class="nb">puts</span> <span class="s2">"but procs can </span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>So where does a block’s lexical context come from?</p>

<ul>
  <li>bindings – objects’ way of tracking local variable context</li>
  <li>when we create a new block, it takes on the binding of the context in which it was created.</li>
  <li>this lets a block share (and update – more on that in a second) the local variables that were defined in the context <em>in which it was created</em>.</li>
  <li>This behavior is what we describe as a <em>closure</em> – we say the block “closes over” the local variables, allowing it to take them with it</li>
  <li>Closures are portable just like procs – even if we pass the proc off to another method or place in code, it maintains its ability to access those local variables that were defined in the context that created it.</li>
</ul>

<h3 id="higher-order-functions">Higher-Order Functions</h3>

<ul>
  <li>Term in programming for functions (methods) that take other methods as arguments</li>
  <li>design pattern – allows us to generalize a common process in a way that users (other programmers) can very flexibly customize it to fit their various problems</li>
</ul>

<p>For example <code class="highlighter-rouge">map</code> – this method represents the <em>idea</em> of using some process (the block) to transform a collection of values into a new collection</p>

<p>We could hard code this in the standard way:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">nums</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">]</span>
<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">doubles</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="nf">length</span>
  <span class="n">doubles</span> <span class="o">&lt;&lt;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span>
  <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
<span class="k">end</span>

<span class="n">doubles</span>
<span class="o">=&gt;</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">6</span><span class="p">,</span><span class="mi">8</span><span class="p">]</span>
</code></pre></div></div>

<p>What could be improved about this code?</p>

<p>The pieces are rigidly connected together</p>

<h3 id="exercises">Exercises</h3>

<h4 id="1-each-with-a-proc">1. Each with a proc</h4>

<p>Write your own each method which takes 2 arguments: an array and a proc. Execute the proc for each element in the array using <code class="highlighter-rouge">call</code>. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_each</span><span class="p">(</span><span class="n">array</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="c1">#stuff</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Make sure your each method returns the original collection when it’s done</p>

<h4 id="2-map-with-a-proc">2. Map with a proc</h4>

<p>Do the same as above but this time for map</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">my_each</span><span class="p">(</span><span class="n">array</span> <span class="o">&amp;</span><span class="n">block</span><span class="p">)</span>
  <span class="c1">#stuff</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Make sure your map method returns the collection of new values when it’s done</p>

<h4 id="3-fire-fire-spicy--write-a-partial-application-method">3. :fire: :fire: Spicy – Write a Partial Application method</h4>

<p>Functional programming is a programming paradigm that focuses on, among other things, the idiomatic manipulation of functions as values. Functional programming languages generally include a primitive type for representing a function as a value, and the <code class="highlighter-rouge">Proc</code> is Ruby’s version of this.</p>

<p>Once common technique in FP languages is to take a function that accepts <code class="highlighter-rouge">N</code> arguments and “partially” evaluate it to generate a new function which takes <code class="highlighter-rouge">N - 1</code> arguments.</p>

<p>For example in Clojure we might see:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; add things</span><span class="w">
</span><span class="n">cljs.user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w">
</span><span class="mi">2</span><span class="w">
</span><span class="c1">;; add multiple things -- note that the "+" function takes any number of arguments</span><span class="w">
</span><span class="n">cljs.user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">+</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">
</span><span class="mi">10</span><span class="w">
</span><span class="c1">;; partially evaluate the + function to generate a new function, plus-five</span><span class="w">
</span><span class="n">cljs.user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">plus-five</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="mi">5</span><span class="p">))</span><span class="w">
</span><span class="c1">;; add 5 to something</span><span class="w">
</span><span class="n">cljs.user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">plus-five</span><span class="w"> </span><span class="mi">6</span><span class="p">)</span><span class="w">
</span><span class="mi">11</span><span class="w">
</span></code></pre></div></div>

<p>Can you achieve the same thing in ruby? I bet you can! See if you can write your own method, <code class="highlighter-rouge">partial</code>, which takes a Proc and an argument and generates a new Proc which works like the original one but <em>with the first argument already applied</em>.</p>

<p>For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">add_nums</span> <span class="o">=</span> <span class="no">Proc</span><span class="p">.</span><span class="nf">new</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="o">|</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span> <span class="p">}</span>
<span class="n">add_nums</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># =&gt; 3</span>

<span class="k">def</span> <span class="nf">partial</span><span class="p">(</span><span class="nb">proc</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
  <span class="c1"># stuff</span>
<span class="k">end</span>

<span class="n">add_five</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">add_nums</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>

<span class="n">add_five</span><span class="p">.</span><span class="nf">call</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># =&gt; 7</span>
</code></pre></div></div>

<h3 id="appendix-procs-vs-lambdas">Appendix: Procs vs Lambdas</h3>

<ul>
  <li>lambdas basically a subtype of proc</li>
  <li>only 2 differences</li>
</ul>

<ol>
  <li>Lambdas are strict about their number of arguments (fancy CS word – arity)</li>
  <li><code class="highlighter-rouge">return</code> keyword – in a lambda this will return only from the local context i.e the block itself; in a proc this will return from the surrounding method context</li>
</ol>
:ET