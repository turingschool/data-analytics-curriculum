I"é9<p>aka â€œData Structures Obstacle Courseâ€</p>

<h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>Introduce you to a few programming algorithms &amp; data structures</li>
  <li>Spark your curiosity to further explore these concepts</li>
  <li>You may see these concepts as part of your interview process</li>
</ul>

<h2 id="sorting-algorithms">Sorting Algorithms</h2>

<p>Sorting algorithms are used to organize an array or list of elements. For example, if you have a list of words and they need to be arranged in alphabetical order, or arranging numbers from least to greatest.</p>

<p>There are <em>multiple</em> different methods for sorting the information depending on how the elements are broken up or compared to other elements. <a href="https://www.geeksforgeeks.org/sorting-algorithms/">Here</a> you can find a list of various sorting algorithms; however, we are only going to look into three sorting algorithms.</p>

<h3 id="bubble-sort">Bubble Sort</h3>

<p>Bubble sort is completed by iterating over each element and comparing it to the <em>next</em> adjacent element and then swapping places if the elements are not in the correct order. It repeats this process until all elements in the array are sorted.</p>

<details open=""><summary><i>Bubble Sort Gone Wrong</i></summary>
  <iframe src="https://giphy.com/embed/A21xqd8A2RCko" width="480" height="270" frameborder="0" class="giphy-embed" allowfullscreen="">
  </iframe>
  <p>
    <a href="https://giphy.com/gifs/A21xqd8A2RCko">via GIPHY</a>
  </p>
</details>

<details open=""><summary><i>Bubble Sort Visual</i></summary>
  <a title="Swfung8, CC BY-SA 3.0 &lt;https://creativecommons.org/licenses/by-sa/3.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Bubble-sort-example-300px.gif"><img width="256" alt="Bubble-sort-example-300px" src="https://upload.wikimedia.org/wikipedia/commons/c/c8/Bubble-sort-example-300px.gif" /></a>
</details>

<p><em>Think About It</em></p>
<ul>
  <li>How long would it take to complete a bubble sort?</li>
  <li>Write pseudo code for how you might sort this array <code class="highlighter-rouge">[7, 3, 4, 9]</code>.</li>
</ul>

<h2 id="pseudo-solution">Pseudo Solution</h2>

<details><summary>Review Solution</summary>
<ol>
  <li> Starting Array [7, 3, 4, 9] </li>
  <li> Find length of Array</li>
  <li> Compare each adjacent element until end is reached</li>
  <li> Start with index 0 and continue until last index equals array</li> length -1
  <li> If element with smaller index is greater swap elements</li>
  <li> Repeat process until array is sorted</li>
</ol>
</details>

<h3 id="insertion-sort">Insertion Sort</h3>

<p>Insertion sort is done by sectioning the list or array into sorted and unsorted sections. Elements are then taken from the unsorted section and inserted into the correct position in the sorted section. The current element is compared to the <em>prior</em> element. The value that is greater is then shifted forward to make room for the smaller element.</p>

<details open=""><summary><i>Insertion Sort Visual</i></summary>
  <a title="Swfung8, CC BY-SA 3.0 &lt;https://creativecommons.org/licenses/by-sa/3.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Insertion-sort-example.gif"><img width="256" alt="Insertion-sort-example" src="https://upload.wikimedia.org/wikipedia/commons/9/9c/Insertion-sort-example.gif" /></a>
</details>

<p><em>Think About It</em></p>
<ul>
  <li>How long would it take to complete an insertion sort?</li>
  <li>How does insertion sort compare to bubble sort?</li>
</ul>

<h3 id="merge-sort">Merge Sort</h3>

<p>Merge sort takes the <strong>divide and conquer</strong> approach to sorting the list or array of elements. The array is continually split until only single elements of the array remain. Then the elements are compared to one another and merged in chunks. Once the elements have been broken into multiple single element arrays, the elements are then compared to make paired arrays. This process will continue by comparing the first element of the array to the first element of the other array until all the chunks are broken and combined to form a single array.</p>

<details open=""><summary><i>Merge Sort Visual</i></summary>
  <a title="Swfung8, CC BY-SA 3.0 &lt;https://creativecommons.org/licenses/by-sa/3.0&gt;, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Merge-sort-example-300px.gif"><img width="256" alt="Merge-sort-example-300px" src="https://upload.wikimedia.org/wikipedia/commons/c/cc/Merge-sort-example-300px.gif" /></a>
</details>

<p><em>Think About It</em></p>
<ul>
  <li>How long would it take to complete a merge sort?</li>
  <li>How does this sort compare to bubble and insertion?</li>
</ul>

<hr />

<h2 id="data-structures">Data Structures</h2>

<p>A data structure encompasses how the data is organized, managed, and what actions can be performed on the data. There are multiple types of data structures in programming and in order to determine the type of structure to use you might start by asking the following questions:</p>
<ul>
  <li>How does the data need to be stored?
    <ul>
      <li>The size of the data might help determine the answer to this question.</li>
    </ul>
  </li>
  <li>What is the relationship between the elements of the data?</li>
  <li>How is the data used? What type of operations need to be performed to the data?</li>
</ul>

<p>We are only going to explore some data structures, binary tree, linked list, and hash maps.</p>

<p>Binary Trees and Linked Lists are both â€œnodeâ€ based data structures, where each piece of data is a â€œnodeâ€ which contains a value of some kind and a reference to one or more â€œnextâ€ nodes; the first node in a both is typically called the â€˜headâ€™ or â€˜rootâ€™ node.</p>

<p>Hash Maps (commonly just called â€œhashesâ€ in Ruby) are the common key/value storage that weâ€™ve used a lot at Turing so far, and not thought of to be node-based, but weâ€™ll examine more about it in a moment.</p>

<p>If you want to research other data structures, <a href="https://www.geeksforgeeks.org/data-structures/">here</a> might be a good place to start.</p>

<h3 id="binary-tree">Binary Tree</h3>

<p>A binary tree is a type of data structure that organizes data in a way that allows for faster look-ups when searching through the data. There are 3 main operations that can be performed on the data: insertion, deletion, and search. The data is structured so that there is a <code class="highlighter-rouge">root</code> node, the starting point, and each node can point to two other nodes. In order to traverse the tree for a search, the element is compared to a node and determined whether it is greater than, less than, or equal to the element.</p>

<details open=""><summary><i>Binary Tree Search Compared to a Sorted Array Visual </i></summary>
  <iframe src="https://gfycat.com/ifr/GrandShortCowrie" frameborder="0" scrolling="no" allowfullscreen="" width="640" height="582"></iframe>
  <p>
    <a href="https://gfycat.com/grandshortcowrie">via Gfycat</a>
  </p>
</details>

<p>A Binary Tree gets itâ€™s â€œbinaryâ€ name from the notion that each â€œnodeâ€ points to two other nodes, typically programmed as a â€œleftâ€ and a â€œrightâ€ node.</p>

<p><em>Think About It</em></p>
<ul>
  <li>When might a binary tree be a beneficial structure to use?</li>
  <li>Why is it more advantageous to use a binary tree than an array?</li>
</ul>

<p>Work to do:</p>

<ol>
  <li>Open <a href="https://gist.github.com/iandouglas/21e56d1c07a65f66c23612a98ddca75e">this gist</a> and copy the contents into an appropriate folder structure:
    <ul>
      <li><code class="highlighter-rouge">node.rb</code> and <code class="highlighter-rouge">binarytree.rb</code> will go in a <code class="highlighter-rouge">lib/</code> folder</li>
      <li><code class="highlighter-rouge">binary_tree_test.rb</code> will go in a <code class="highlighter-rouge">test/</code> folder</li>
    </ul>
  </li>
  <li>Write some code to make the tests pass</li>
</ol>

<h3 id="linked-list">Linked List</h3>

<p>A linked list is a data structure that organizes the data as a linear collection (like a binary tree, but it doesnâ€™t branch into left/right). However, unlike arrays, linked lists do not need to be stored with the data all together in memory. It is able to achieve this because each node contains the element data (value) and a reference to the â€œnextâ€ node in the list. Linked list operations include appending, deleting, and inserting data. There are also different types of linked lists: singly linked, doubly linked, and circularly linked.</p>

<details open=""><summary><i>Singly Linked List Example</i></summary>
<br />
  <a title="Derrick Coetzee, Public domain, via Wikimedia Commons" href="https://commons.wikimedia.org/wiki/File:Singly_linked_list_insert_after.png"><img width="300" alt="Singly linked list insert after" src="https://upload.wikimedia.org/wikipedia/commons/0/00/Singly_linked_list_insert_after.png" /></a>
</details>
<p><br />
<em>Think About It</em></p>
<ul>
  <li>What is the advantage of using a linked list?</li>
  <li>What is the difference between a singly linked, doubly linked, and circularly linked list?</li>
</ul>

<p>Work to do:</p>

<ol>
  <li>Open <a href="https://gist.github.com/iandouglas/21479de34f46fc8955f7a7340b0187dc">this gist</a> and copy the contents into an appropriate folder structure:
    <ul>
      <li><code class="highlighter-rouge">node.rb</code> and <code class="highlighter-rouge">linkedlist.rb</code> will go in a <code class="highlighter-rouge">lib/</code> folder</li>
      <li><code class="highlighter-rouge">linked_list_test.rb</code> will go in a <code class="highlighter-rouge">test/</code> folder</li>
    </ul>
  </li>
  <li>Write some code to make the tests pass</li>
</ol>

<h3 id="hash-maps">Hash Maps</h3>

<p>Hashes, at a high level are â€œkey-valueâ€ data structures, but how do they actually work?</p>

<p>The â€œhashâ€ name comes from a mathematical formula about how the hash knows where to store each piece of data in memory. The more complex a â€œhashingâ€ algorithm is, the more easily things can be stored into â€œuniqueâ€ places in memory, but will take longer to actually do the calculation. Less-complex hashing algorithms are much faster, but risk more â€œcollisionsâ€ of data. (eg, if our â€œhashingâ€ algorithm was only storing strings, and we used the first letter of the string to define where it was put in memory, and our strings were student names, then â€œJamesâ€, â€œJamalâ€, â€œJackieâ€, etc would all â€œcollideâ€ in memory.</p>

<p>So, hash maps use an array (commonly referred to as â€œbucketsâ€), where each â€œbucketâ€ is a â€œheadâ€ node of a linked list. Back to our â€œstudent namesâ€ example, weâ€™d have 26 â€œbucketsâ€, one for each letter of the alphabet, and the â€œJâ€ bucket would be a linked list where each node contains the names for James, Jamal, Jackie, etc.. This is the â€œmapâ€ explanation of the name of â€œhash mapâ€, itâ€™s using a â€œhashâ€ algorithm to generate a â€œmapâ€ of where things get stored in memory. You might also hear the term â€œhash tableâ€.</p>

<p>In a typical Hash Map, if thereâ€™s a â€œcollisionâ€ (ie, the letter â€œJâ€), every value is shifted to the right and the newer data is stored as the new start of that bucketâ€™s linked list.</p>

<p>The main difference with this linked list, though, is that a hash has a name and a value.</p>

<p>In our students example, we might want to store the ages of our students like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span>
  <span class="s1">'James'</span><span class="p">:</span> <span class="mi">27</span><span class="p">,</span>
  <span class="s1">'Jamal'</span><span class="p">:</span> <span class="mi">31</span><span class="p">,</span>
  <span class="s1">'Jackie'</span><span class="p">:</span> <span class="mi">29</span><span class="p">,</span>
  <span class="n">etc</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Since our Linked List only has a value, if we just stored â€œ27â€, â€œ31â€, and â€œ29â€, we would lose track of which student had which age. So now our Hah Mapâ€™s Linked List â€œnodeâ€ has to be a little more advanced. We have to store the original â€œkeyâ€ value, plus that keyâ€™s â€œvalueâ€ (in this example, the student age).</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Node</span>
  <span class="nb">attr_reader</span> <span class="ss">:key</span><span class="p">,</span> <span class="ss">:value</span>
  <span class="nb">attr_accessor</span> <span class="ss">:next</span>

  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
    <span class="vi">@key</span> <span class="o">=</span> <span class="n">key</span>
    <span class="vi">@value</span> <span class="o">=</span> <span class="n">value</span>
    <span class="vi">@next</span> <span class="o">=</span> <span class="kp">nil</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>When we want to recall a studentâ€™s age, say Jamal, we run our hash algorithm on the â€œkeyâ€ (â€œJamalâ€), which would produce our â€œJâ€ value, go to our â€œJâ€ bucket, and then traverse that linked list until we find a node which has a payload which includes a â€œkeyâ€ attribute with â€œJamalâ€ in it, and then return the â€œvalueâ€.</p>

<p>Work to do:</p>
<ol>
  <li>Build some Ruby code that does a very rudimentary â€œhashingâ€ algorithm for a given string that just returns the first letter of the string, something like this should suffice:
    <div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">hash</span><span class="p">(</span><span class="n">string</span><span class="p">)</span>
  <span class="n">string</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div>    </div>
  </li>
  <li>Make an array of 26 Linked Lists, one for each letter of the alphabet, and write some code to insert and retrieve some key/value pairs from your hash.</li>
  <li>Hint: the word â€œHashâ€ will be reserved in Ruby, so call it something else</li>
</ol>

<hr />

<h2 id="looking-for-more">Looking for More?</h2>

<p><a href="https://github.com/turingschool/data_structures_and_algorithms">This repo</a> has several computer science exercises to deepen your understanding.</p>
:ET