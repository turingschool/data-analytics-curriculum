I"ƒ><h2 id="resources">Resources</h2>

<ul>
  <li><a href="https://www.youtube.com/watch?v=OccKyvGvLKE&amp;t=1329s">Video</a> from a past class and the core ideas</li>
</ul>

<h2 id="prior-to-class">Prior to Class</h2>

<ul>
  <li>Students need to have a solid understanding of inner joins, grouping, ordering, filtering, and aggregate functions in SQL.</li>
  <li><strong>Important:</strong> All students should spend 3 hours the evening prior to this class attempting to solve a business intelligence problem from their project. It will get them familiar with the schema and get them familiar with the types of challenges they will encounter.</li>
</ul>

<h2 id="completion-goals">Completion Goals</h2>

<ul>
  <li>The instructor will use class input to build an ActiveRecord query to find the <strong>top 5 most expensive invoices with successful transactions</strong>.</li>
  <li>The afternoon after the class is complete students should be working in groups to diagram one additional business intelligence challenge and work on solving it together.</li>
</ul>

<h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>Student can diagram the required connections needed for ActiveRecord and SQL queries</li>
  <li>Student can execute raw SQL in Rails</li>
  <li>Student can connect to a SQL interface in Rails to visualize query results</li>
  <li>Student can explain why GROUP BY is needed with aggregate functions</li>
  <li>Student can explain what a virtual attribute is in ActiveRecord and how it relates to a SQL alias</li>
</ul>

<hr />

<h2 id="warmup-5-mins">Warmup (5 mins)</h2>

<ul>
  <li>Have students read about Entity Relationship Diagrams</li>
</ul>

<hr />

<h2 id="intro-10-mins">Intro (10 mins)</h2>

<ul>
  <li>What are ER Diagrams?</li>
  <li>What are the advantages of this approach?</li>
  <li>What are the disadvantages?</li>
</ul>

<p>As we work on more difficult business intelligence it becomes more difficult to hold all of the moving parts in our head. A great strategy for managing this complexity is offloading the parts we care about to a visual representation. While ER Diagrams are an official way to do this, it is frequently easier to sketch something out on a whiteboard or in a notebook.</p>

<p>As a class weâ€™re going to start solving our ActiveRecord problem mentioned above by diagraming the problem.</p>

<h2 id="student-writing-5-mins">Student Writing (5 mins)</h2>

<p>Have each student create a visual representation of the tables and columns that will be necessary to solve the BI challenge mentioned above.</p>

<h2 id="break-5-mins">Break (5 mins)</h2>

<h2 id="diagraming-as-a-group-20-mins">Diagraming as a Group (20 mins)</h2>

<ul>
  <li>Using popsicle sticks (or some other method) select students to share out a column they believe is necessary to accomplish the goal mentioned above.</li>
  <li>After all columns and tables are present, continue selecting students to explain why we care about each column. Use the SQL functions names and write them on the board with relation to the column(s) they are relevant to.</li>
  <li>Be sure to note things such as <code class="highlighter-rouge">INNER JOIN</code>, <code class="highlighter-rouge">WHERE</code>, <code class="highlighter-rouge">GROUP</code>, <code class="highlighter-rouge">ORDER BY</code> etc., as well as aggregate functions on the board.</li>
</ul>

<h2 id="break-10-mins">Break (10 mins)</h2>

<h2 id="instructor-led-terminal-session-2-hours">Instructor Led Terminal Session (~2 hours)</h2>

<p>Start out in a Rails console.</p>

<p>Itâ€™s common for students to start their queries in a join table since they usually frequently touch the most tables directly. When using <code class="highlighter-rouge">ActiveRecord</code> this will usually lead to making two queries. For example: For this query, we are trying to return a collection of <code class="highlighter-rouge">Invoice</code>s. We could retrieve all of the invoice idâ€™s from the invoice_items table but then weâ€™d need to do a second lookup to the invoices table.</p>

<p>Generally itâ€™s best to start in the model that corresponds to the object(s) you are trying to return. If you are trying to return Invoices then start in the <code class="highlighter-rouge">Invoice</code> model.</p>

<h4 id="how-to-work-through">How to work through:</h4>

<ul>
  <li>Using the diagram created above, work through and make sure each piece is accounted for.</li>
  <li>Start with the easiest parts of the query.</li>
  <li>Only add complexity when you are sure what you have is working the way you expect it to.</li>
  <li>Read the SQL output as you execute the <code class="highlighter-rouge">ActiveRecord</code> queries.</li>
</ul>

<h2 id="cheatsheet-without-the-answers-">Cheatsheet (without the answers ;)</h2>

<p>Use the methods and tools below to work through the BI.</p>

<h3 id="to_sql">.to_sql</h3>

<p>Generates a string of the SQL that your <code class="highlighter-rouge">ActiveRecord</code> query generates.</p>

<h3 id="dbconsole">dbconsole</h3>

<p><code class="highlighter-rouge">$ rails dbconsole</code></p>

<p>Connects you to your database console defined in <code class="highlighter-rouge">database.yml</code>. This will allow you to execute and write SQL and see the typical table style output which can be really useful when troubleshooting. Paste in the results of <code class="highlighter-rouge">.to_sql</code> to visualize the results.</p>

<h3 id="joins">.joins()</h3>

<p>Cheatsheet:</p>

<ul>
  <li><code class="highlighter-rouge">Author.joins(:articles).distinct</code> - Returns unique authors who have articles</li>
  <li><code class="highlighter-rouge">Author.joins(articles: [:comments]).distinct</code> - Returns unique authors who have articles that have been commented on</li>
  <li><code class="highlighter-rouge">Author.joins(:articles, :writing_departments).where(articles: {tutorial: "true"}, writing_departments: {title: "Software Development"}).distinct</code> - Returns unique authors that have written tutorials for the Software Development department.</li>
</ul>

<h3 id="select">.select()</h3>

<p>Simple: Return 5 authors with only their id and name.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Author</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:id</span><span class="p">,</span> <span class="ss">:name</span><span class="p">).</span><span class="nf">limit</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
</code></pre></div></div>

<p>Complex: Return the authors with the most commented on articles limited to 10. We only need their name, id, and comment count.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Author</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">articles: </span><span class="p">[</span><span class="ss">:comments</span><span class="p">])</span>
  <span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"authors.id, authors.name, COUNT(comments) as total_comments"</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">group</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"total_comments DESC"</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</code></pre></div></div>

<p>Breaking down the query above:</p>
<ul>
  <li><code class="highlighter-rouge">select</code> - Grabs the id and name then runs an aggregate function to count how many comments this authors articles have received. It saves this count into an alias called <code class="highlighter-rouge">total_comments</code>. <code class="highlighter-rouge">ActiveRecord</code> will define a virtual attribute that shares the same name as the alias. e.g. <code class="highlighter-rouge">author.total_comments # =&gt; 178</code></li>
  <li><code class="highlighter-rouge">group</code> - Is required when we run an aggregate function since the resulting alias isnâ€™t clearly associated with anything. We need to specify how to organize the results. In this case: each authorâ€™s idâ€™s.</li>
  <li><code class="highlighter-rouge">order</code> - Weâ€™re ordering by the alias from the aggregate function. When ordering by something that is not stored on the starting table we need to do it as a string.</li>
</ul>

<h3 id="merge-and-scopes">.merge() and scopes</h3>

<p>Return the authors with the most commented on articles limited to 10. Only return articles marked as a tutorial.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Author</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">articles: </span><span class="p">[</span><span class="ss">:comments</span><span class="p">])</span>
  <span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"authors.* COUNT(comments) as total_comments"</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">group</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">articles: </span><span class="p">{</span><span class="ss">tutorial: </span><span class="kp">true</span><span class="p">})</span>
  <span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"total_comments DESC"</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</code></pre></div></div>

<p>Itâ€™s not great for the <code class="highlighter-rouge">Author</code> model to know about the inner workings of the articles table. And we might want to query for tutorials in other places. We can use <code class="highlighter-rouge">.merge</code> to share pull in logic from other places.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># article.rb</span>
<span class="k">class</span> <span class="nc">Article</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">scope</span> <span class="ss">:tutorials</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">tutorial: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

<span class="c1"># rails console</span>
<span class="no">Author</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">articles: </span><span class="p">[</span><span class="ss">:comments</span><span class="p">])</span>
  <span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"authors.* COUNT(comments) as total_comments"</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">group</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="no">Article</span><span class="p">.</span><span class="nf">tutorials</span><span class="p">)</span> <span class="c1"># this is where we merge</span>
  <span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"total_comments DESC"</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="default-scope">default scope</h3>

<p>What order does your database return the results when you run <code class="highlighter-rouge">Article.all</code>? Hint: take a look at the SQL that gets generated.</p>

<p>You can set a default order using a default scope:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Article</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">scope</span> <span class="ss">:tutorials</span><span class="p">,</span> <span class="o">-&gt;</span> <span class="p">{</span> <span class="n">where</span><span class="p">(</span><span class="ss">tutorial: </span><span class="kp">true</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">default_scope</span> <span class="p">{</span> <span class="n">order</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span> <span class="p">}</span>
<span class="c1"># ...</span>
<span class="k">end</span>
</code></pre></div></div>

<p>How does SQL generated from <code class="highlighter-rouge">Article.all</code> differ now?</p>

<p>Gotcha: What happens when we run this query now?</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Author</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">articles: </span><span class="p">[</span><span class="ss">:comments</span><span class="p">])</span>
  <span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"authors.* COUNT(comments) as total_comments"</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">group</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="no">Article</span><span class="p">.</span><span class="nf">tutorials</span><span class="p">)</span> <span class="c1"># the merge pulls in the default scope now</span>
  <span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"total_comments DESC"</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</code></pre></div></div>

<p>What SQL gets generated if we were to run: <code class="highlighter-rouge">Article.unscoped.all</code>?</p>

<p>Putting it all togetherâ€¦</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Author</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">articles: </span><span class="p">[</span><span class="ss">:comments</span><span class="p">])</span>
  <span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"authors.* COUNT(comments) as total_comments"</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">group</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">merge</span><span class="p">(</span><span class="no">Article</span><span class="p">.</span><span class="nf">unscoped</span><span class="p">.</span><span class="nf">tutorials</span><span class="p">)</span> <span class="c1"># unscoping our merge</span>
  <span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"total_comments DESC"</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="find_by_sql">.find_by_sql()</h3>

<h3 id="activerecordconnectionexecute">ActiveRecord.connection.execute()</h3>
:ET