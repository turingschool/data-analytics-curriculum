I"˝a<h2 id="learning--completion-goals">Learning &amp; Completion Goals</h2>

<ul>
  <li>Students can start their Rails application in production mode locally <em>(functional)</em></li>
  <li>Students can troubleshoot common Asset Pipeline errors locally instead of production servers (Heroku) <em>(functional)</em></li>
</ul>

<h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>Start your Rails app in production mode</li>
  <li>How Rails organizes client-side assets in your application</li>
  <li>How and why to use ActionView::Helpers and sass-rails helpers</li>
  <li>Understand how the Asset Pipeline behaves differently in production than in development</li>
  <li>Add assets to manifests to create asset bundles</li>
</ul>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="https://gist.github.com/jmejia/8f6507d3faa92ff21f0b">Starting a Rails app in production</a></li>
  <li><a href="https://github.com/rails/sprockets-rails">Sprockets</a></li>
  <li><a href="https://vimeo.com/256876292">Solutions</a> to the paired challenges below</li>
</ul>

<h2 id="prior-to-class">Prior to Class</h2>

<ul>
  <li>Clone down this <a href="https://github.com/turingschool-examples/hinny">Rails app</a>.</li>
  <li>Start the application in production mode using <a href="https://vimeo.com/255927334">this video</a>.</li>
</ul>

<h2 id="instructor-notes">Instructor Notes</h2>

<ul>
  <li>Lesson plan is intended to use pairs.</li>
  <li>To start the lesson, have students checkout the <code class="highlighter-rouge">debugging_the_asset_pipeline</code> branch.</li>
</ul>

<h2 id="warm-up">Warm Up</h2>

<p>With your partner:</p>

<ul>
  <li>Why do we need to run <code class="highlighter-rouge">rake assets:precompile</code> prior to running our application in production mode?</li>
  <li>Why don‚Äôt we need to do this in development mode?</li>
</ul>

<h2 id="group-discussion">Group Discussion</h2>

<p>Silently read the following excerpt from Rails Guides about The Asset Pipeline:</p>

<blockquote>
  <p>The first feature of the pipeline is to concatenate assets, which can reduce the number of requests that a browser makes to render a web page. Web browsers are limited in the number of requests that they can make in parallel, so fewer requests can mean faster loading for your application.</p>
</blockquote>

<blockquote>
  <p>Sprockets concatenates all JavaScript files into one master .js file and all CSS files into one master .css file. As you‚Äôll learn later in this guide, you can customize this strategy to group files any way you like. In production, Rails inserts an SHA256 fingerprint into each filename so that the file is cached by the web browser. You can invalidate the cache by altering this fingerprint, which happens automatically whenever you change the file contents.</p>
</blockquote>

<blockquote>
  <p>The second feature of the asset pipeline is asset minification or compression. For CSS files, this is done by removing whitespace and comments. For JavaScript, more complex processes can be applied. You can choose from a set of built in options or specify your own.</p>
</blockquote>

<blockquote>
  <p>The third feature of the asset pipeline is it allows coding assets via a higher-level language, with precompilation down to the actual assets. Supported languages include Sass for CSS, CoffeeScript for JavaScript, and ERB for both by default.</p>
</blockquote>

<p>What is the job of the Asset Pipeline? What does it do for us?</p>

<h2 id="lecture">Lecture</h2>

<p>Source files go in one end; if necessary, they get processed and compiled (think SASS or CoffeeScript); they get concatenated and compressed and spit out the other end as bundles.</p>

<p>The asset pipeline relies on a few technologies:</p>

<ul>
  <li><strong>Sprockets</strong> is a Rack-based asset packaging for compiling and serving web assets. It handles dependency management and preprocesses CoffeeScript, SASS, et cetera on your behalf.</li>
  <li><strong>Tilt</strong> is a wrapper around a number of Ruby template engines, giving them a common interface. You can take a look at all of the formats Tilt can handle by <a href="https://github.com/rtomayko/tilt/blob/master/README.md">checking out the documentation</a>.</li>
</ul>

<p>So, why should you use the asset pipeline? Inline JavaScript (mixed in your HTML/ERB code) blocks loading and rendering the page‚Äîwhich is not something we usually want to block. Plus it is messy to mix JavaScript, Ruby, and HTML in a view template. Let‚Äôs keep JavaScript in its own files in the Rails assets directories.</p>

<p>Rails will pick up new files in your <code class="highlighter-rouge">app/assets</code> directory, but you have to reset the server if you add a new <em>directory</em> to the <code class="highlighter-rouge">app/assets</code>.</p>

<p>Rails pulls in assets from the following locations:</p>

<ul>
  <li><code class="highlighter-rouge">app/assets</code></li>
  <li><code class="highlighter-rouge">lib/assets</code></li>
  <li><code class="highlighter-rouge">vendor/assets</code></li>
  <li>Gems with a <code class="highlighter-rouge">vendor/assets</code> directory.</li>
</ul>

<p><code class="highlighter-rouge">app/assets</code> are your application-specific assets. <code class="highlighter-rouge">lib/assets</code> is typically used for assets that are created by your team but used by multiple applications. <code class="highlighter-rouge">vendor/assets</code> is a good place for third-party JavaScript libraries that aren‚Äôt yours (e.g. Underscore.js, D3).</p>

<p>By default, Rails places three sub-directories in your <code class="highlighter-rouge">app/assets</code> directory. These are completely arbitrary. You can name these directories whatever you want or add other directories to your heart‚Äôs content.</p>

<p>Anything in the pipeline will be available at the <code class="highlighter-rouge">/assets</code> URL. So, the <code class="highlighter-rouge">app/assets/javascripts/application.js</code> in your asset pipeline will be available in development at <code class="highlighter-rouge">http://localhost:3000/assets/application.js</code>. <code class="highlighter-rouge">app/assets/stylesheets/application.css</code> will also be available at the root of your asset directory. The asset pipeline will completely flatten your directory structure when you spin up your development server or precompile your assets.</p>

<p><strong>In Pairs (3 mins)</strong></p>

<ul>
  <li>Create a directory in <code class="highlighter-rouge">app/assets</code> called <code class="highlighter-rouge">this_name_does_not_matter</code>.</li>
  <li>Add a text file‚Äîlet‚Äôs call it <code class="highlighter-rouge">hello.txt</code>‚Äîto <code class="highlighter-rouge">app/assets/this_name_does_not_matter</code> and give it some contents.</li>
  <li>Fire up the server and visit <code class="highlighter-rouge">http://localhost:3000/assets/hello.txt</code>.</li>
  <li>Move it to <code class="highlighter-rouge">app/assets/javascripts</code> and refresh the page.</li>
  <li>Discuss with your partner: What‚Äôs the purpose of separate directories?</li>
</ul>

<p><strong>As a class</strong></p>

<p>At it‚Äôs core, the asset pipeline is a list of load paths. You can see these load paths by firing up the Rails console.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">y</span> <span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">config</span><span class="p">.</span><span class="nf">assets</span><span class="p">.</span><span class="nf">paths</span>
</code></pre></div></div>

<p>(The <code class="highlighter-rouge">y</code> command just formats the hash as YAML.)</p>

<p>You‚Äôll typically see something like this:</p>

<div class="language-yaml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">---</span>
<span class="pi">-</span> <span class="s2">"</span><span class="s">/Users/michaelbolton/Projects/initech/app/assets/images"</span>
<span class="pi">-</span> <span class="s2">"</span><span class="s">/Users/michaelbolton/Projects/initech/app/assets/javascripts"</span>
<span class="pi">-</span> <span class="s2">"</span><span class="s">/Users/michaelbolton/Projects/initech/app/assets/stylesheets"</span>
<span class="pi">-</span> <span class="s2">"</span><span class="s">/Users/michaelbolton/Projects/initech/vendor/assets/javascripts"</span>
<span class="pi">-</span> <span class="s2">"</span><span class="s">/Users/michaelbolton/Projects/initech/vendor/assets/stylesheets"</span>
<span class="pi">-</span> <span class="s2">"</span><span class="s">/Users/michaelbolton/.rvm/gems/ruby-2.5.0/gems/less-rails-bootstrap-3.2.0/app/assets/fonts"</span>
<span class="pi">-</span> <span class="s2">"</span><span class="s">/Users/michaelbolton/.rvm/gems/ruby-2.5.0/gems/less-rails-bootstrap-3.2.0/app/assets/javascripts"</span>
<span class="pi">-</span> <span class="s2">"</span><span class="s">/Users/michaelbolton/.rvm/gems/ruby-2.5.0/gems/less-rails-bootstrap-3.2.0/app/assets/stylesheets"</span>
<span class="pi">-</span> <span class="s2">"</span><span class="s">/Users/michaelbolton/.rvm/gems/ruby-2.5.0/gems/turbolinks-2.2.2/lib/assets/javascripts"</span>
<span class="pi">-</span> <span class="s2">"</span><span class="s">/Users/michaelbolton/.rvm/gems/ruby-2.5.0/gems/jquery-rails-3.1.1/vendor/assets/javascripts"</span>
<span class="pi">-</span> <span class="s2">"</span><span class="s">/Users/michaelbolton/.rvm/gems/ruby-2.5.0/gems/coffee-rails-4.0.1/lib/assets/javascripts"</span>
</code></pre></div></div>

<p>The asset pipeline works its way through your load path starting at the top. The first asset with a given name wins. If you had an asset named <code class="highlighter-rouge">app/assets/stylesheet.css.scss</code> and another called <code class="highlighter-rouge">vendor/assets/stylesheet.css.scss</code>, the asset in your <code class="highlighter-rouge">app/assets</code> directory would win because it occurs first in the load path.</p>

<h2 id="loading-assets---our-journey-begins">Loading Assets - Our Journey Begins</h2>

<p>We‚Äôll be following our assets‚Äô journey through the Asset Pipeline. This journey can sometimes feel like a Rube Goldberg machine but there is a purpose behind each stage. Understanding the purpose is essential to controlling and troubleshooting this complex system. The call to load assets starts in the view so let‚Äôs start exploring there and discuss what is happening along the way.</p>

<h3 id="actionview-helpers">ActionView Helpers</h3>

<p>ActionView gives you a set of helper methods that you can use in your views to include assets.</p>

<p>With your partner, locate the two lines in your application that look something like this:</p>

<div class="language-erb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;%=</span> <span class="n">stylesheet_link_tag</span> <span class="s2">"application"</span><span class="p">,</span> <span class="ss">:media</span> <span class="o">=&gt;</span> <span class="s2">"all"</span> <span class="cp">%&gt;</span>
</code></pre></div></div>

<div class="language-erb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;%=</span> <span class="n">javascript_include_tag</span> <span class="s2">"application"</span> <span class="cp">%&gt;</span>
</code></pre></div></div>

<p>These two lines are responsible for loading all CSS and JS that are a part of the Asset Pipeline. We‚Äôll come back and look at more ActionView Helpers later. For now, let‚Äôs breakdown what these lines are doing.</p>

<p>Each of these lines points to a different manifest, one for our stylesheets and one for our JavaScript.</p>

<h3 id="manifests">Manifests</h3>

<p>When developing our application‚Äôs frontend, we like to separate our code into multiple files according to its function or responsibility. This helps keep things manageable and organized as our application grows, especially in Apps that involve a lot of JS or CSS.</p>

<p>However, when serving assets to an end user, this becomes problematic. In development, it is tedious to have to individually require a lot of small asset files in our templates. In production, having lots of asset files is even worse, since it bogs down the page with lots of HTTP requests.</p>

<p>Fortunately Rails gives us asset manifests to help with these issues. Manifests are a way to pull in groups of related files. So, if I request <code class="highlighter-rouge">application.js</code> and it requires <code class="highlighter-rouge">another.js</code> in it‚Äôs manifest, I will get both of them. It‚Äôs common to see a single large manifest (e.g. <code class="highlighter-rouge">application.js</code>) that pulls in everything, but we can also segment our assets into smaller manifests that are only used on specific portions of the site (e.g. <code class="highlighter-rouge">admin.js</code>).</p>

<p>When writing an asset manifest, we can use special ‚Äúdirectives‚Äù to tell Sprockets what to pull in to the bundle. Directives are written as comments in the appropriate manifest file. Here are a few examples (see below for a complete list):</p>

<ul>
  <li><code class="highlighter-rouge">// require_tree .</code> requires all of the files in that directory and all subdirectories.</li>
  <li><code class="highlighter-rouge">// require_directory .</code> loads all of the files in the directory but <em>not</em> the subdirectories.</li>
  <li>Alternatively, you can just take matters into you own hands and manually define the files you want to include.</li>
</ul>

<p>In this example, we‚Äôre looking at <code class="highlighter-rouge">application.js</code>; so, we‚Äôre using JavaScript comments. If you‚Äôre in <code class="highlighter-rouge">application.css</code> then it would be in CSS comments.</p>

<p>By default, the asset pipeline concatenates all of assets into one file (using <code class="highlighter-rouge">require_tree .</code>). Browsers can only make a limited number of requests in parallel. This technique allows you to get all of your assets with one request.</p>

<p>Here‚Äôs an example of an <code class="highlighter-rouge">application.js</code> manifest:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//= require jquery</span>
<span class="c1">//= require jquery_ujs</span>
<span class="c1">//= require turbolinks</span>
<span class="c1">//= require_tree .</span>
</code></pre></div></div>

<p><strong>Discussion/Question:</strong> Why are <code class="highlighter-rouge">jquery</code> and our other external JS libraries not picked up by <code class="highlighter-rouge">require_tree .</code></p>

<h4 id="manifest-directives">Manifest Directives</h4>

<ul>
  <li><code class="highlighter-rouge">require</code> grabs an asset and puts it in our bundle once.</li>
  <li><code class="highlighter-rouge">include</code> works a lot like <code class="highlighter-rouge">require</code>, but it will allow you to include a file more than once. (I have yet to find a practical use for this directive.)</li>
  <li><code class="highlighter-rouge">require_self</code> tells Sprockets to load the body of the current file before loading any of the dependencies. You would use this if you wrote any styles or JavaScript in <code class="highlighter-rouge">application.css</code> or <code class="highlighter-rouge">application.js</code> respectively and you wanted Sprockets to load that code before loading any of the required assets.</li>
  <li><code class="highlighter-rouge">require_directory</code> requires all of the source files of the same format in a given directory. It only goes one level deep.</li>
  <li><code class="highlighter-rouge">require_tree</code> works like <code class="highlighter-rouge">require_directory</code>, but it also traverses subdirectories.</li>
  <li><code class="highlighter-rouge">depend_on</code> announces that you depend on a file, but does not include it in the asset bundle.</li>
  <li><code class="highlighter-rouge">stub</code> blacklists a dependency from the bundle.</li>
</ul>

<p><strong>In Pairs (10 minutes)</strong></p>

<p><em>Instructor:</em> The order in your manifest matters. If you load the root page for the application in development mode you‚Äôll notice two hero images. This should be a carousel with the two images rotating but there‚Äôs a problem loading the JavaScript. If you load the console in your browser you should see an error.</p>

<ul>
  <li>Which file is causing the error?</li>
  <li>Using this <a href="http://kenwheeler.github.io/slick/#getting-started">setup documentation</a>: What is Slick dependent on?</li>
  <li>Try to update the manifest to get the carousel to work.</li>
  <li>If you figure it out, start the app in production and confirm it works there as well.</li>
</ul>

<h3 id="actionview-helpers-in-production-as-a-class">ActionView Helpers in Production (as a class)</h3>

<p>Start your application in production mode and inspect element in the browser. Locate the line that loads your application JavaScript. You should something that looks like this:</p>

<p><code class="highlighter-rouge">&lt;script src="/assets/application-c0168a95589ad557034a1e201a2b2dffef63124394d26187259600f77802d45a.js"&gt;&lt;/script&gt;</code></p>

<p>When you fixed the previous problem you edited a file named <code class="highlighter-rouge">application.js</code> and what we are seeing here is different. That strange looking string is referred to as a fingerprint.</p>

<h4 id="md5-fingerprints--asset-caching">MD5 Fingerprints / Asset Caching</h4>

<p>It‚Äôs beyond the scope of this discussion, but caching assets is a large topic in the field of web infrastructure. Retrieving assets over and over adds a lot of network overhead to web applications, so browsers (as well as network intermediaries like CDN‚Äôs) do everything they can to cache assets.</p>

<p>But if assets are being cached on the browser side, we need a way to update them when necessary. Otherwise our application might get loaded with out-of-date assets (for example, old javascript with a new set of incompatible markup).</p>

<p>If you look at the assets generated by a Rails application, you‚Äôll notice that each includes a string of letters and numbers as part of the filename. This string of numbers is a ‚Äúdigest‚Äù of all of the asset contents, which allows us to ensure that any change to the underlying asset will generate a completely new filename and URL, thus breaking any asset caches that might have been in place.</p>

<p>By default, this fingerprinting is only necessary in production mode.</p>

<h3 id="differences-in-development-and-production">Differences in Development and Production</h3>

<p>As we mentioned in the beginning, the whole idea of the asset pipeline is to concatenate everything into one file, because performance. But, we‚Äôll notice that when we spin up our application in development, we‚Äôll see many files listed in the resources tab of the Chrome Developer Tools.</p>

<p>This is because this functionality is disabled in <code class="highlighter-rouge">config/environments/development.rb</code>:</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># Debug mode disables concatenation and preprocessing of assets.</span>
<span class="c1"># This option may cause significant delays in view rendering with a large</span>
<span class="c1"># number of complex assets.</span>
<span class="n">config</span><span class="p">.</span><span class="nf">assets</span><span class="p">.</span><span class="nf">debug</span> <span class="o">=</span> <span class="kp">true</span>
</code></pre></div></div>

<p>This is useful for debugging JavaScript and CSS issues. It‚Äôs turned off in production.</p>

<h4 id="precompiling-assets">Precompiling Assets</h4>

<p>If you request an asset in development, Rails will check <code class="highlighter-rouge">public/assets</code> first. If your asset is not there, it will hit up the asset pipeline and compile it on the fly. This is useful in development because you‚Äôre likely to be making frequent changes and edits to those files. But, it would also be a performance bottleneck in production if Rails had to compile those files on every request.</p>

<p>If you want to use an asset in your application, it has to either be required by a file in your asset pipeline or precompiled.</p>

<p>Let‚Äôs say you had a stylesheet called <code class="highlighter-rouge">site.css.scss</code>. You could simply require it in <code class="highlighter-rouge">application.css</code>.</p>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">//</span> <span class="o">=</span> <span class="nt">require_self</span>
<span class="o">//</span> <span class="o">=</span> <span class="nt">require</span> <span class="s2">'site'</span>
</code></pre></div></div>

<p>Alternatively, you can add it to the precompile list similar to the way we added a load path earlier.</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">config</span><span class="p">.</span><span class="nf">assets</span><span class="p">.</span><span class="nf">precompile</span> <span class="o">+=</span> <span class="sx">%w( site.css )</span>
</code></pre></div></div>

<p>When you run <code class="highlighter-rouge">rake assets:precompile</code>, Rails goes through your assets and copies everything over to <code class="highlighter-rouge">public/assets</code>. It then creates fingerprinted versions of <code class="highlighter-rouge">application.js</code> and <code class="highlighter-rouge">application.css</code> by reading the manifests. It does not look at any other file unless you explicitly tell it to.</p>

<h3 id="why-assets-break-in-production">Why Assets Break in Production</h3>

<p><strong>In Pairs (25 minutes)</strong></p>

<p>For the next exercises we want to start our Rails app in both development and production at the same time üôÄ.</p>

<p><strong>development:</strong> Start your first server like normal using <code class="highlighter-rouge">rails s</code>.
<strong>production:</strong> Start your second server using the following <code class="highlighter-rouge">RAILS_ENV=production rails s -p 4000 -P ./tmp/pids/alternate_server.pid</code></p>

<p>As you know, <code class="highlighter-rouge">RAILS_ENV=production</code> tells it to start in production mode. <code class="highlighter-rouge">-p</code> allows us to specify which port to run on. <code class="highlighter-rouge">-P</code> Tells it to look for a different PID (process identifier). If it doesn‚Äôt exist it should create one.</p>

<ul>
  <li>Navigate to each environment in the browser.</li>
  <li>Pull up the docs for <code class="highlighter-rouge">ActionView::Helpers::AssetTagHelper</code>.</li>
  <li>The CSS isn‚Äôt loading properly in production mode. What is this filename missing that our application.js file has? (Hint: use Inspect Element or View Source in the browser)</li>
  <li>Find a helper to fix it. (REMINDER: Restart the production server anytime you make a change)</li>
  <li>Using a similar approach, can you find a helper to fix the broken logo?</li>
</ul>

<p><strong>As a Class</strong></p>

<ul>
  <li>What ended up being the problem?</li>
  <li>What other helpers are there out there?</li>
  <li>Currently the background images of the donkey cards are broken. What do you think the problem is?</li>
</ul>

<h4 id="some-notes-about-sassscss">Some Notes about SASS/SCSS</h4>

<p>Background images are loaded using stylesheets and require different helpers than our views. Check out the docs for sass-rails to see what helpers are available. They are the same in principle to <code class="highlighter-rouge">ActionView::Helpers</code>.</p>

<p><strong>In Pairs</strong></p>

<ul>
  <li>Find the sass-rails helper to load the background images in production.</li>
</ul>

<p><strong>As a Class</strong></p>

<p>You could require and concatenate multiple <code class="highlighter-rouge">.scss</code> files using manifest directives (eg <code class="highlighter-rouge">require</code>), but you probably shouldn‚Äôt. The asset pipeline is fairly agnostic to the special features of the assets you‚Äôre working with. SASS has an <code class="highlighter-rouge">@import</code> directive that works better for our purposes. In this case, it‚Äôs better to just include <code class="highlighter-rouge">@import</code> directives in your <code class="highlighter-rouge">application.sass</code> than it is to use manifest directives. This will end up being less buggy.</p>

<p>You can also do something similar with JavaScript, but it‚Äôs a little more intensive, so for now, we‚Äôll use manifests to concatenate our scripts.</p>

<h3 id="conclusion">Conclusion</h3>
:ET