I"®ì<h2 id="discussion">Discussion</h2>

<ul>
  <li>Overview of servers ‚Äì dedicated, metal, VPS</li>
  <li>Walk through what a VPS is and isn‚Äôt</li>
  <li>Key concepts of UNIX: ssh, users, groups, ownership, path, sudo</li>
  <li>Review the steps to setting up a server</li>
</ul>

<h3 id="key-components-for-a-rails-server">Key Components for a Rails Server</h3>

<ul>
  <li>Linux</li>
  <li>Ruby</li>
  <li>PostgreSQL</li>
  <li>Rails and supporting gems</li>
  <li>NGINX with Passenger</li>
</ul>

<h2 id="tutorial">Tutorial</h2>

<h3 id="first-login">First Login</h3>

<p>You should get an email with the root credentials for your server. You can login by:</p>

<ul>
  <li>opening your terminal</li>
  <li>running <code class="highlighter-rouge">ssh root@youripaddress</code></li>
  <li>enter the password from the email</li>
  <li>you‚Äôre in!</li>
</ul>

<h3 id="creating-a-new-user">Creating a New User</h3>

<p>Doing everything as <code class="highlighter-rouge">root</code> is a bad idea. With great power comes great responsibility. Power is great, but that‚Äôs a little too much responsibility. Let‚Äôs create a user that can access that power when it needs to, but acts like a regular user the rest of the time.</p>

<p>I‚Äôve named this user <code class="highlighter-rouge">deploy</code>, but you can name it anything you‚Äôd like.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Make a new user</span>
<span class="nb">sudo </span>adduser deploy

<span class="c"># The server is going to ask you a bunch of questions. Just hit enter to each.</span>

<span class="c"># Give that user administrative privileges</span>
<span class="nb">sudo </span>adduser deploy <span class="nb">sudo</span>

<span class="c"># Switch to your new user</span>
su deploy
</code></pre></div></div>

<p>We are no longer <code class="highlighter-rouge">root</code>. We‚Äôre now logged in as <code class="highlighter-rouge">deploy</code>.</p>

<p>We can connect to our server as the <code class="highlighter-rouge">deploy</code> user. Right now, we‚Äôre back to using a password. Let‚Äôs install our SSH keys for our new user so we can avoid entering a password.</p>

<p>You can find the public key you use for GitHub at <code class="highlighter-rouge">http://github.com/yourusername.keys</code>
or on your file system it‚Äôs typically in <code class="highlighter-rouge">~/.ssh/id_rsa.pub</code>.</p>

<p>Once you have your key you need to add it to <code class="highlighter-rouge">authorized_keys</code> file on your server:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd</span> ~
<span class="nb">mkdir</span> .ssh
nano .ssh/authorized_keys
<span class="c"># Paste in your public key with cmd-v and exit with ctrl-q</span>
</code></pre></div></div>

<p>If done correctly, you should now be able to log out of the vps (by running <code class="highlighter-rouge">exit</code> at the command line) and log in again without being prompted for your password.</p>

<h3 id="using-a-package-manager-to-install-basic-packages">Using a Package Manager to Install Basic Packages</h3>

<p>A Package Manager is a piece of software that automates the process of discovering and installing other software packages. Without a package manager, we would have to search out individual installation instructions for every package we want to install, often having to manually build them from source as well.</p>

<p>Working on our own machines, we‚Äôve frequently used Homebrew in this capacity. On Linux, the most popular package manager is called <code class="highlighter-rouge">apt-get</code>. We‚Äôll be using it throughout this tutorial.</p>

<p>First, let‚Äôs update our package repository and then we‚Äôll install some of the necessary packages to get rocking and rolling with downloading the rest of our setup.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt-get update
sudo apt-get install git-core curl zlib1g-dev build-essential libssl-dev libreadline-dev libyaml-dev libsqlite3-dev sqlite3 libxml2-dev libxslt1-dev libcurl4-openssl-dev python-software-properties libgdbm-dev libncurses5-dev automake libtool bison libffi-dev
</code></pre></div></div>

<h3 id="setting-up-git">Setting Up Git</h3>

<p>Okay, so now we have <code class="highlighter-rouge">git</code>. Let‚Äôs configure it.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cd ~
git config --global user.name "Your Name"
git config --global user.email your-email@address.com
</code></pre></div></div>

<h3 id="installing-ruby">Installing Ruby</h3>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Download RVM</span>
curl <span class="nt">-L</span> https://get.rvm.io | bash <span class="nt">-s</span> stable

<span class="c"># Load RVM into your current environment</span>
<span class="nb">source</span> ~/.rvm/scripts/rvm

<span class="c"># Load RVM into your future environments</span>
<span class="nb">echo</span> <span class="s2">"source ~/.rvm/scripts/rvm"</span> <span class="o">&gt;&gt;</span> ~/.bashrc

<span class="c"># Install a version of ruby</span>
rvm <span class="nb">install </span>2.2.1

<span class="c"># Switch to your new Ruby and set it as the default</span>
rvm use 2.2.1 <span class="nt">--default</span>

<span class="c"># Make sure you have the version of Ruby you think you do</span>
ruby <span class="nt">-v</span>
</code></pre></div></div>

<p><strong>Note:</strong> Your RVM installation script may fail the first time with a warning about importing a GPG public key for RVM‚Äôs author. If you get this, look for the GPG key import instructions, which will be something like:</p>

<p><code class="highlighter-rouge">gpg --keyserver hkp://keys.gnupg.net --recv-keys 409B6B1796C275462A1703113804BB82D39DC0E3</code></p>

<p>Run that command, then pick up the RVM install steps from the beginning.</p>

<h3 id="configuring-gem-installation">Configuring Gem Installation</h3>

<p>We probably don‚Äôt need to download documentation for each gem on our server, so let‚Äôs turn that off now.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>echo "gem: --no-ri --no-rdoc" &gt; ~/.gemrc
</code></pre></div></div>

<h3 id="hello-world">Hello World</h3>

<p>At this point, we‚Äôve put together enough of our server infrastructure to
be able to run a basic rails application.</p>

<p>Let‚Äôs install Rails with <code class="highlighter-rouge">gem install rails</code> and then create a new Rails
project with <code class="highlighter-rouge">rails new &lt;application-name&gt; --skip-spring</code>. Change into the directory
for your new project, and run <code class="highlighter-rouge">rails s</code> to start up our server.</p>

<p>Now, in a separate terminal tab or window, ssh to your VPS again (<code class="highlighter-rouge">ssh
deploy@your.ip.address</code>, assuming you used <code class="highlighter-rouge">deploy</code> as your username).</p>

<p>Try loading your application via curl: <code class="highlighter-rouge">curl localhost:3000</code>. This isn‚Äôt
the best interface for consuming an html web page, but if you look
closely you should see markup for the familiar ‚ÄúWelcome Aboard!‚Äù page.</p>

<p>Run <code class="highlighter-rouge">bundle install</code> and you should be ready to run <code class="highlighter-rouge">rails s</code> to start up your server. If that was successful, then head over to your IP address and port 3000 and you should see the default Rails starting page. Congratulations, your Rails application is on the Internet.</p>

<h3 id="hello-world-via-the-web">Hello World Via The Web?</h3>

<p>Why did we have to access our sample rails app from on the same box via
curl? Try accessing it from outside the machine by opening a web browser
and navigating to <code class="highlighter-rouge">&lt;your.ip.address&gt;:3000</code> <em>but it will fail</em>.</p>

<p>You‚Äôll probably get a ‚ÄúWebpage not available‚Äù error. We‚Äôve configured
our app to run locally on the VPS, but so far we haven‚Äôt configured the
VPS to expose the necessary port externally to the rest of the internet.</p>

<p>We‚Äôll be addressing this shortly, but for now, let‚Äôs install a few more
application dependencies.</p>

<h3 id="installing-postgresql">Installing PostgreSQL</h3>

<p>First, we‚Äôll install PostgreSQL.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>apt-get <span class="nb">install </span>postgresql postgresql-contrib libpq-dev
</code></pre></div></div>

<p>Installing PostgreSQL created a new user on our machine‚Äîconveniently named <code class="highlighter-rouge">postgres</code>. Let‚Äôs switch over to that user real quick.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>su - postgres
psql
</code></pre></div></div>

<p>Those commands switched us to the <code class="highlighter-rouge">postgres</code> user on our server and then dropped us into the PostgreSQL prompt (psql). Now that we‚Äôre the <code class="highlighter-rouge">postgres</code> user, let‚Äôs create a user in PostgreSQL (how meta).</p>

<p>First, set a password for the database using <code class="highlighter-rouge">\password</code>.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>create role deployment with createdb login password <span class="s1">'password1'</span><span class="p">;</span>
</code></pre></div></div>

<p>Hit <kbd>Control-D</kbd> to exit.</p>

<p>The third argument is the username for my PostgreSQL user. The last argument is a terrible, terrible password.</p>

<p>Type <code class="highlighter-rouge">exit</code> and you‚Äôll be dropped out of the <code class="highlighter-rouge">postgres</code> user and back into <code class="highlighter-rouge">deploy</code>.</p>

<p>Let‚Äôs go make sure this actually works. To check, we‚Äôll pop back into that Rails application we made a few minutes ago and edit the <code class="highlighter-rouge">database.yml</code> to look something like this:</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">development</span><span class="pi">:</span>
  <span class="na">adapter</span><span class="pi">:</span> <span class="s">postgresql</span>
  <span class="na">encoding</span><span class="pi">:</span> <span class="s">unicode</span>
  <span class="na">database</span><span class="pi">:</span> <span class="s">myapp_development</span>
  <span class="na">host</span><span class="pi">:</span> <span class="s">localhost</span>
  <span class="na">pool</span><span class="pi">:</span> <span class="m">5</span>
  <span class="na">username</span><span class="pi">:</span> <span class="s">deployment</span>
  <span class="na">password</span><span class="pi">:</span> <span class="s">password1</span>

<span class="na">test</span><span class="pi">:</span>
  <span class="na">adapter</span><span class="pi">:</span> <span class="s">postgresql</span>
  <span class="na">encoding</span><span class="pi">:</span> <span class="s">unicode</span>
  <span class="na">database</span><span class="pi">:</span> <span class="s">myapp_test</span>
  <span class="na">host</span><span class="pi">:</span> <span class="s">localhost</span>
  <span class="na">pool</span><span class="pi">:</span> <span class="m">5</span>
  <span class="na">username</span><span class="pi">:</span> <span class="s">deployment</span>
  <span class="na">password</span><span class="pi">:</span> <span class="s">password1</span>

<span class="na">production</span><span class="pi">:</span>
  <span class="na">adapter</span><span class="pi">:</span> <span class="s">postgresql</span>
  <span class="na">encoding</span><span class="pi">:</span> <span class="s">unicode</span>
  <span class="na">database</span><span class="pi">:</span> <span class="s">myapp</span>
  <span class="na">host</span><span class="pi">:</span> <span class="s">localhost</span>
  <span class="na">pool</span><span class="pi">:</span> <span class="m">5</span>
  <span class="na">username</span><span class="pi">:</span> <span class="s">deployment</span>
  <span class="na">password</span><span class="pi">:</span> <span class="s">password1</span>
</code></pre></div></div>

<p>Also, don‚Äôt forget to add <code class="highlighter-rouge">gem 'pg'</code> to your Gemfile.</p>

<p>You‚Äôll probably want to change <code class="highlighter-rouge">myapp</code> to the name of your application.</p>

<p>We‚Äôre only testing things out, so let‚Äôs rely on our old friend, the scaffold generator.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rails g scaffold Article title:string body:text
rake db:create db:migrate
</code></pre></div></div>

<p><strong>One More Thing:</strong></p>

<p>Now that we have some actual content in our application, we‚Äôll actually get an error if we try to view it.</p>

<p>We need to have a JavaScript runtime installed alongside our application. Use a text editor to add the following to your <code class="highlighter-rouge">Gemfile</code> (like <code class="highlighter-rouge">vim Gemfile</code> or <code class="highlighter-rouge">nano Gemfile</code>):</p>

<div class="language-rb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gem</span> <span class="s1">'execjs'</span>
<span class="n">gem</span> <span class="s1">'therubyracer'</span>
</code></pre></div></div>

<p>Fire up the Rails server and try loading <code class="highlighter-rouge">localhost:3000/articles</code> (from another ssh session).</p>

<p>Thanks to our trusty scaffold, you should see some boilerplate about
‚ÄúListing Articles‚Äù, indicating our app is now running and connected to
the database.</p>

<h3 id="putting-the-web-in-our-webserver">Putting the Web in Our Webserver</h3>

<p>So, we have a server successfully running a rails server process, but as
we mentioned before, we don‚Äôt yet have the ability to connect to it over
the web (hence all this <code class="highlighter-rouge">ssh</code> and <code class="highlighter-rouge">localhost</code> curling).</p>

<p>Let‚Äôs install a few more packages to help us get the server talking over
the web. For this we‚Äôll be using 2 pieces of software ‚Äì Phusion
Passenger as an ‚Äúapp server‚Äù to connect our Rails process over http, and
Nginx as a ‚Äúweb server‚Äù to allow our server to accept incoming HTTP
requests from the outside world.</p>

<h3 id="installing-passenger-a-web-application-server">Installing Passenger, a Web Application Server</h3>

<p>Ideally, we‚Äôd like to be sure we‚Äôre not installing something horrible on our brand new servers, so we‚Äôre going to grab some key‚Äôs to confirm we‚Äôre getting the software we think we are.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Install Phusion's PGP key to verify packages</span>
gpg <span class="nt">--keyserver</span> keyserver.ubuntu.com <span class="nt">--recv-keys</span> 561F9B9CAC40B2F7
gpg <span class="nt">--armor</span> <span class="nt">--export</span> 561F9B9CAC40B2F7 | <span class="nb">sudo </span>apt-key add -
</code></pre></div></div>

<p>We also want the ability to install Ubuntu packages over HTTP.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Add HTTPS support to APT</span>
<span class="nb">sudo </span>apt-get <span class="nb">install </span>apt-transport-https
</code></pre></div></div>

<p>Now, let‚Äôs download Passenger.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Add the passenger repository</span>
<span class="nb">sudo </span>sh <span class="nt">-c</span> <span class="s2">"echo 'deb https://oss-binaries.phusionpassenger.com/apt/passenger trusty main' &gt;&gt; /etc/apt/sources.list.d/passenger.list"</span>
<span class="nb">sudo chown </span>root: /etc/apt/sources.list.d/passenger.list
<span class="nb">sudo chmod </span>600 /etc/apt/sources.list.d/passenger.list
<span class="nb">sudo </span>apt-get update

<span class="c"># Install nginx and passenger</span>
<span class="nb">sudo </span>apt-get <span class="nb">install </span>nginx-full passenger
</code></pre></div></div>

<p>One reason for using Passenger as our app server is that it comes with
a pre-packaged installation designed to work easily with NGINX. This
last step installs both of these together.</p>

<p>Right on. Now let‚Äôs fire up this server:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>service nginx start
</code></pre></div></div>

<p>We have Nginx installed and running. In fact, you should now be able to
load your IP address in a browser and see a simple NGINX status message.</p>

<p>NGINX is running, but it currently doesn‚Äôt have enough information to
serve requests via our actual application. This next section can get a
little hairy, as we‚Äôll be editing some NGINX configuration files to tell
them which application process to use when serving requests.</p>

<h3 id="configuring-nginx">Configuring NGINX</h3>

<p>First, we‚Äôre going to need to know where to tell Passenger to look for an installed version of Ruby.
Fortunately passenger includes a script for finding this information, which we can use like so:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>passenger-config <span class="nt">--ruby-command</span>

passenger-config was invoked through the following Ruby interpreter:
  Command: /home/deploy/.rvm/gems/ruby-2.2.1/wrappers/ruby
  Version: ruby 2.2.1p85 <span class="o">(</span>2015-02-26 revision 49769<span class="o">)</span> <span class="o">[</span>x86_64-linux]
  To use <span class="k">in </span>Apache: PassengerRuby /home/deploy/.rvm/gems/ruby-2.2.1/wrappers/ruby
  To use <span class="k">in </span>Nginx : passenger_ruby /home/deploy/.rvm/gems/ruby-2.2.1/wrappers/ruby
  To use with Standalone: /home/deploy/.rvm/gems/ruby-2.2.1/wrappers/ruby /usr/bin/passenger start


<span class="c">## Notes for RVM users</span>
Do you want to know which <span class="nb">command </span>to use <span class="k">for </span>a different Ruby interpreter? <span class="s1">'rvm use'</span> that Ruby interpreter, <span class="k">then </span>re-run <span class="s1">'passenger-config --ruby-command'</span><span class="nb">.</span>
</code></pre></div></div>

<p>We want the portion for use in NGINX: <code class="highlighter-rouge">/home/deploy/.rvm/gems/ruby-2.2.1/wrappers/ruby</code>. Make note
of that so we can use it in our NGINX config in a moment.</p>

<p>Now let‚Äôs use a text editor to edit the NGINX config, located at <code class="highlighter-rouge">/etc/nginx/nginx.conf</code>.</p>

<p>We can use everyone‚Äôs favorite micro editor:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>nano /etc/nginx/nginx.conf
</code></pre></div></div>

<p>Or, if you‚Äôre comfortable with vim:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo vim /etc/nginx/nginx.conf
</code></pre></div></div>

<p>We‚Äôre looking for the settings for Phusion Passenger. If you‚Äôre using Vim, you can skip down to the settings by typing <code class="highlighter-rouge">/Phusion</code>. We want to uncomment the line with <code class="highlighter-rouge">passenger_root</code> to enable Passenger. We also want to use the Ruby we installed with RVM as the <code class="highlighter-rouge">passenger_ruby</code>. When all is said and done, that section should look something like this:</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">##</span>
<span class="c"># Phusion Passenger config</span>
<span class="c">##</span>
<span class="c"># Uncomment it if you installed passenger or passenger-enterprise</span>
<span class="c">##</span>

passenger_root /usr/lib/ruby/vendor_ruby/phusion_passenger/locations.ini<span class="p">;</span>
passenger_ruby /home/deploy/.rvm/gems/ruby-2.2.1/wrappers/ruby<span class="p">;</span>
</code></pre></div></div>

<p>Let‚Äôs restart our server.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>service nginx restart
</code></pre></div></div>

<p>This should give NGINX the tools it needs to run a Rails server process.
Next we need to tell it specifically which one to run.</p>

<h3 id="connecting-nginx-to-our-rails-application">Connecting NGINX to our Rails Application</h3>

<p>Let‚Äôs configure Nginx to know about our new Rails application.</p>

<p>Using either <code class="highlighter-rouge">vim</code> or <code class="highlighter-rouge">nano</code>, edit <code class="highlighter-rouge">/etc/nginx/sites-enabled/default</code> with <code class="highlighter-rouge">sudo</code>.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo </span>vim /etc/nginx/sites-enabled/default
</code></pre></div></div>

<p>Replace <code class="highlighter-rouge">example-app</code> with the name of your application. Notice that we link to the <code class="highlighter-rouge">public</code> folder in our Rails application. When you‚Äôre done, your <code class="highlighter-rouge">sites-enabled/default</code> file should look something like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server {
        listen 80 default_server;
        listen [::]:80 default_server ipv6only=on;

        server_name mydomain.com;
        passenger_enabled on;
        rails_env    production;
        root         /home/deploy/example-app/public;

        # redirect server error pages to the static page /50x.html
        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }
}
</code></pre></div></div>

<p>We‚Äôre almost ready to go. Let‚Äôs setup our production database.</p>

<div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rake db:create db:migrate <span class="nv">RAILS_ENV</span><span class="o">=</span><span class="s2">"production"</span>
</code></pre></div></div>

<p>We also need to set a production secret in <code class="highlighter-rouge">config/secrets.yml</code>. For our little ‚ÄúHello World‚Äù application, we‚Äôll just replace <code class="highlighter-rouge">&lt;%= ENV["SECRET_KEY_BASE"] %&gt;</code> with a static value. Generally, you want to keep secret keys out of version control and store them in the environment.</p>

<p>You can read more about setting environment variables in Phusion Passenger <a href="https://www.phusionpassenger.com/documentation/Users%20guide%20Apache.html#env_vars_passenger_apps">here</a>.</p>

<h2 id="installing-nodejs">Installing node.js</h2>

<h3 id="1-instaling-nvm-a-node-version-manager-similar-to-rvm">1. Instaling NVM, a node version manager (similar to RVM)</h3>

<p>Use this install script:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>curl -o- https://raw.githubusercontent.com/creationix/nvm/v0.25.4/install.sh | bash
</code></pre></div></div>

<p>When that‚Äôs done, <code class="highlighter-rouge">exit</code> your box and re-connect to make NVM init
itself. Then you can install a node version:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nvm install 0.12.4
</code></pre></div></div>

<p>After running this, you should be able to check your current node
version with <code class="highlighter-rouge">node -v</code> and see that it‚Äôs using <code class="highlighter-rouge">0.12.4</code>.</p>

<p>Additionally, set this as your default node version to avoid having to
re-set it later:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nvm alias default 0.12.4
</code></pre></div></div>

<h3 id="2-installing-express">2. Installing Express</h3>

<p>We‚Äôll use Express to set up a sample Node app, so install that package:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install -g express
</code></pre></div></div>

<p>And also the associated generator tool:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install express-generator -g
</code></pre></div></div>

<h3 id="3-generating-a-sample-app">3. Generating a Sample App</h3>

<p>Now let‚Äôs make an empty node app with the express command:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>express hello-node
</code></pre></div></div>

<p>This should give you a basic node app running on port 3000. Try curling
it to see if you get a response.</p>

<h3 id="4-serving-our-node-app-alongside-the-pre-existing-rails-app">4. Serving our Node App Alongside the Pre-Existing Rails App</h3>

<p>Getting that basic node app setup wasn‚Äôt too bad, but now we‚Äôve got to
address an additional challenge introduced by a Service Architecture ‚Äì
routing at the application level.</p>

<p>Ideally, we‚Äôd like both of our apps to run alongside one another on the
same ports (80 and 81 for http and https, respectively). But we also
need to be able to distinguish them in some way so that we can
decide whether an incoming request needs to go to App A or App B.</p>

<p>Two common techniques for this are subdomain-based-routing and
path-based-routing. With subdomain routing, requests to
<code class="highlighter-rouge">messages.mydomain.com</code> might go to our chat server, while requests to
just <code class="highlighter-rouge">mydomain.com</code> go to the main application.</p>

<p>With path routing, we‚Äôll use url fragments so that
<code class="highlighter-rouge">mydomain.com/messages</code> goes to one app while all other requests go to the
other.</p>

<p>For this example, let‚Äôs use paths. We‚Äôll set everything up to route
requests under <code class="highlighter-rouge">/messages</code> to the new node app we created.</p>

<p>To make this happen, we need to return to our nginx routing
configuration currently living at <code class="highlighter-rouge">/etc/nginx/sites-enabled/default</code>.</p>

<p>Edit this file using <code class="highlighter-rouge">sudo (vim/nano) /etc/nginx/sites-enabled/default</code>.</p>

<p>We‚Äôll be making 2 main changes:</p>

<ol>
  <li>Adding a new ‚Äúlocation‚Äù block to serve our node app under a specific
path set.</li>
  <li>Reording some of the elements so that the new location block appears
before the ‚Äúcatch-all‚Äù passenger routing.</li>
</ol>

<p>Edit your <code class="highlighter-rouge">/etc/nginx/sites-enabled/default</code> so it looks similar to
this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code># Default server configuration
#
server {
	listen 80 default_server;
	listen [::]:80 default_server;

	server_name 104.236.170.113;

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

	location /messages/ {
		proxy_set_header X-Real-IP $remote_addr;
		proxy_set_header HOST $http_host;
	        proxy_set_header X-NginX-Proxy true;

	        proxy_pass http://127.0.0.1:3000;
	        proxy_redirect off;
	        rewrite ^/messages/(.*)$ /$1 break;
	}

	passenger_enabled on;
	rails_env production;
	root /home/deploy/hello_world/public;

	# Add index.php to the list if you are using PHP
	index index.html index.htm index.nginx-debian.html;
}
</code></pre></div></div>

<p>Notice that our original rails/passenger configuration now appears lower
than the /messages section we just added. This allows routes under /messages to take
priority over the generic/default routing.</p>

<p>Also notice the <code class="highlighter-rouge">rewrite</code> rule unside of the <code class="highlighter-rouge">/messages/</code> routing
namespace. This lets us treat <code class="highlighter-rouge">/messages</code> as the ‚Äúroot‚Äù (<code class="highlighter-rouge">/</code>) relative
to our node app.</p>

<h3 id="5-running-our-node-app-as-a-daemon">5. Running Our Node App as a Daemon</h3>

<p>One thing we haven‚Äôt had to deal with for our Rails app is starting and
stopping the server process. This is because passenger is actually
handling that for us, and we‚Äôre using passenger integrated with NGINX.</p>

<p>For our new node server app, we need a mechanism to start our app
without us having to manually start it, and make sure it stays running
even when we aren‚Äôt connected to the box via ssh.</p>

<p>One useful tool for this is a node package called <code class="highlighter-rouge">forever</code></p>

<p>Let‚Äôs install it:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>npm install forever -g
</code></pre></div></div>

<p>And start our app with it (from the <code class="highlighter-rouge">hello-node</code> directory we created
earlier):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>forever start ./bin/www
</code></pre></div></div>

<p><code class="highlighter-rouge">./bin/www</code> is a script included by express for booting the server
process. This command might differ if you are using a different node
server.</p>

<p>It may seem like this command did nothing, but you can check on your
process using the <code class="highlighter-rouge">forever list</code> command:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ forever list
info:    Forever processes running
data:        uid  command                                          script  forever pid   id logfile                        uptime
data:    [0] XytQ /home/deploy/.nvm/versions/node/v0.12.4/bin/node bin/www 10629   10630    /home/deploy/.forever/XytQ.log 0:0:0:4.182
</code></pre></div></div>

<p>This gives a list of all the processes currently being run by forever.</p>

<p>Additionally, you should be able to verify your node app is still
running by loading the webserver just as before: `curl</p>
<my.ip.address>/messages`

You may need to vary portions of this configuration depending on your
needs, but this section provides a basic skeleton for running multiple
web applications side-by-side using NGINX as a proxy.

### Deploying Your Own Applications

What we've set up is all well and good if we want to hand-write our applications on
the server using un-configured vim or nano...but what about launching our own applications?

There are a variety of sophisticated tools we could use for this
([Capistrano](http://capistranorb.com/) is especially popular), but for a simple deployment
workflow, we can actually get pretty far with git.

In this section, we'll walk through using git to clone our apps onto the server and pull
subsequent updates.

__Step 1: Clone Your App Onto the VPS__

Assuming your app is already pushed to github, we can get an initial copy of it by cloning it:

```
# ssh to the vps
ssh deploy@<your-vps>
# make sure you're in deploy's home directory
cd ~
# clone your app (replace git url with your git url)
git clone https://github.com/worace/chat.git
# enter the app directory
cd chat
bundle
```

__Step 2: Update database.yml__

Currently our database.yml has a default configuration, but we need it to get
it working with our production db config and password.

User vim/nano to edit `config/database.yml` to look like:

```
default: &amp;default
  adapter: postgresql
  encoding: unicode
  pool: 5

development:
  &lt;&lt;: *default
  database: chat_development

production:
  adapter: postgresql
  encoding: unicode
  database: chat_production
  host: localhost
  pool: 5
  username: deployment
  password: password1
```

Then migrate the database:

```
RAILS_ENV=production rake db:create db:migrate
```

__Step 3: More Configs -- secrets.yml and Precompile Assets__

* Edit `config/secrets.yml` and provide a production secret key
* In production, we need to precompile our assets. Do this in your app directory
  with `RAILS_ENV=production rake assets:precompile`
* Edit `config/application.yml` to include the appropriate "socket_url" for your production environment.
  this should be your server's ip with port 4200.

E.G.:

```
defaults: &amp;defaults
  socket_url: http://localhost:4200

development:
  &lt;&lt;: *defaults

test:
  &lt;&lt;: *defaults

production:
  &lt;&lt;: *defaults
  socket_url: "http://<YOUR_IP_HERE>:4200"
```

__Step 4: Move Passenger Config to Your New App__

Remember when we configured NGINX to point at the dummy application we created?

In order to get our new (real) app running, we'll need to move that configuration
to point at it instead of the placeholder.

To do this, edit `/etc/nginx/sites-enabled/default` and change the
line containing `root` to point to the public directory in your new application:

```
sudo vim /etc/nginx/sites-enabled/default
```

After editing this file should look something like:

```
server {
        listen 80 default_server;
        listen [::]:80 default_server;

        server_name 104.236.170.113;

        error_page   500 502 503 504  /50x.html;
        location = /50x.html {
            root   html;
        }

        passenger_enabled on;
        rails_env production;
        root /home/deploy/chat/public;

        # Add index.php to the list if you are using PHP
        index index.html index.htm index.nginx-debian.html;
}
```

### Deploying Redis

In a second, we'll deploy another of our own applications -- the node chat server. But for starters,
let's add redis to our box, since that's a dependency for our pubsub setup.

```
sudo apt-get install redis-server
# edit your redis.conf
sudo nano /etc/redis/redis.conf
```

Update your `/etc/redis/redis.conf` to look like:

```
daemonize yes
pidfile /var/run/redis.pid
logfile /var/log/redis.log

port 6379
bind 127.0.0.1
timeout 300

loglevel notice

## Default configuration options
databases 16

save 900 1
save 300 10
save 60 10000

rdbcompression yes
dbfilename dump.rdb

appendonly no
```

Confirm you can connect to redis with:

```
redis-cli
```

### Deploying Your Own Applications -- Node Edition

Since we're here, we may as well deploy a node app to. We'll be following mostly the same procedure,
although there's fortunately less configuration to worry about for this one.

__Step 1: Clone via Git__

```
cd ~
git clone https://github.com/worace/chat-sockets.git
cd chat-sockets
npm install
```

__Step 2: Run App via Forever.js__

```
# first stop your forever processes that may have been running before (our old app)
forever stopall
# start this app with forever
forever start bin/www
```

## Addenda

### Restarting your Rails application

When you deploy or otherwise need to restart your app, you can do so by touching a file called `tmp/restart.txt` from the application's root directory. Passenger (the app server) watches for this file to update, and whenver it does, reboots the app. (Note: if your app doesn't have a `tmp` directory on production you will need to make it.) EG:

```
cd ~/path/to/my/app
touch tmp/restart.txt
```

### An Aside: Making Logging into Your Server Easier

Trying to remember your server's IP address. I always forget to prefix the IP address with the username. You can actually make this a lot easier on yourself by setting up a shortcut on your local machine.

From your home directory:

```sh
vim .ssh/config
```

Add the following to the buffer:

```sh
host ocean
    hostname <Server IP="" Address="">
    port 22
    user deploy
```

Now you can connect with `ssh ocean` and it will just work.

### Disabling the Root User

(Talk about how disable the root user.)

### Setting Up and Installing an SSH Key

SSH keys allow us to log in to remote servers without having to use a password. You use an SSH key when you push to Github (usually).

The way it works is that you create a private key on your machine. From that private key, you generate a public key. You can hand out your public key‚Äîumm, publicly. Only your private key can generate that public key. When you connect to a server, your private key shows that it can generate one of the public keys on file and‚Äîif that's successful‚Äîyou're allowed to log in.

We can create a new public key, or we can just use the one you have on file at Github. To view your public key, go to your Github profile and add `.keys` to the end of it. Let's say‚Äîhypothetically‚Äîthat your username is `stevekinney`. You could go to `http://github.com/stevekinney.keys` to retrieve the public key that Github has on file for you.

You can now go to your Digital Ocean profile and add your public key.

If for some reason, you opted not to use an SSH you'll receive an email with the IP address and the password for the `root` user. Otherwise, you're ready to log in to your server.

`root` is the master user and can do pretty much anything on the system.

Let's log in as `root`:

```sh
ssh root@<your-digital-ocean-ip-address>
```

If all went well, you should now be logged into your brand new server on the Internet.

### Hackpad from the Past

During a previous class we put together these notes: https://hackpad.com/Provisioning-a-VPS-RgXRnvmZJcO
</your-digital-ocean-ip-address></Server></YOUR_IP_HERE></your-vps></my.ip.address>
:ET