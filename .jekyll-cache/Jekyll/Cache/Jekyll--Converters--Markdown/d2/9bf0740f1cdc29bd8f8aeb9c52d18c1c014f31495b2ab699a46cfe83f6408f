I"®©<h2 id="notes-to-instructor">Notes to Instructor</h2>

<ul>
  <li>Make sure to cover and explain <code class="highlighter-rouge">Omniauth.mock_auth</code> for testing toward the end of the lesson. There has been a good amount of confusion and time lost with students related to a lack of understanding on the subject.</li>
  <li>This lesson can also be taught with a whole new rails app, in case you want more practice starting apps from scratch. Just check the history.</li>
</ul>

<h2 id="prework">Prework</h2>

<p>Start by watching this <a href="https://www.youtube.com/watch?v=tFYrq3d54Dc">video</a>. Which explains the oauth process at a high level.</p>

<p>Then watch this <a href="https://vimeo.com/173947281">video</a> which actually demonstrates the process live with Github.</p>

<p>Then draw a diagram of the OAuth handshaking process that takes place between your app and and an external API (Twitter, Facebook, Github etc)</p>

<h2 id="tutorial-getting-started-with-oauth">Tutorial: Getting Started With OAuth</h2>

<p>Authentication is a ubiquitous problem in web applications. So
ubiquitous, in fact, that we might be inclined to think of ways
to ‚Äúoutsource‚Äù the problem of authentication to an external provider.</p>

<p>Solving these problems is one of the major focuses of OAuth. Using OAuth,
we can allow users to authenticate with our app via a 3rd-party service
provider (often a large online or social media service).</p>

<p>In this tutorial, we‚Äôll discuss the ideas behind OAuth, and walk
through an example of implementing it in a project.</p>

<h3 id="benefits-of-oauth">Benefits of OAuth</h3>

<p>There are a lot of potential advantages to outsourcing our Authentication
via Oauth.</p>

<p><strong>Removing Security Complexities</strong></p>

<p>Authentication is a tricky problem with a high cost of failure. It can often be tedious
to re-implement on one application after another, but any small mistake
can still have dire consequences.</p>

<p>With OAuth, the user never has to provide sensitive credentials to our application.
Instead, they send these details to the OAuth provider (e.g. Google), who sends
us an authentication token and some basic details on the user‚Äôs behalf.</p>

<p>Since the provider stores the user‚Äôs actual credentials, we no longer have to worry about the
security considerations of storing and encrypting user passwords.</p>

<p><strong>Service Authorization / Authentication</strong></p>

<p>Another benefit of having users authenticate with OAuth is that it gives us
authenticated access (on their behalf) to any APIs available from the OAuth
provider. API Providers frequently limit your access to their platform, and
having a user authenticate with the provider can get you access to more
resources or to an additional volume of requests.</p>

<p>This can be a big help with API rate limiting, for example, since each authenticated user will usually
be allowed their own supply of requests.</p>

<h3 id="disadvantages-of-oauth">Disadvantages of OAuth</h3>

<p>Like everything in technology, using OAuth isn‚Äôt without tradeoffs. Often the benefits
outweigh the costs, but let‚Äôs look at a few things to be aware of.</p>

<p><strong>Loss of Control</strong></p>

<p>With OAuth, we‚Äôre no longer entirely in control of the user‚Äôs login process. We
might like to collect additional information in the signup process that the
3rd party doesn‚Äôt provide to us, or design our own onboarding flow, but with OAuth
we‚Äôll be locked into whatever our provider makes available.</p>

<p><strong>Account Requirement</strong></p>

<p>This one may seem obvious, but if we‚Äôre using OAuth with twitter, then our users
will be required to have a twitter account in order to use the app. Many services
are so ubiquitous these days that this may not be a large disadvantage, but it is
something to be aware of.</p>

<p>Particularly, we may want to consider our target userbase when determining which
OAuth provider to rely on. If your app is a hip social network for tweens, requiring
users to log in with LinkedIn may not be the best choice.</p>

<p><strong>Data Duplication</strong></p>

<p>One challenge OAuth imposes on our application design is deciding how much data
to copy from the external service and where to store it. Do we duplicate the user‚Äôs
basic profile info into a table in our own DB? Or just read it from the API whenever
we need it? These types of dilemmas are very common when dealing with remote data, and
OAuth data is no exception.</p>

<h2 id="workshop--implementing-oauth-with-twitter">Workshop ‚Äì Implementing OAuth with Twitter</h2>

<p>Let‚Äôs get some practice with OAuth by implementing it in a simple rails project.</p>

<h3 id="step-1---registering-with-the-provider">Step 1 - Registering with the Provider</h3>

<p>For this exercise, we‚Äôll be authenticating with Twitter. As a first step,
we need to register an application with Twitter, which will allow us
to obtain the credentials we‚Äôll need in order for Twitter to authenticate
users on our behalf.</p>

<p><strong>Note:</strong> During the registration process, you may be required to verify your account
by adding a mobile phone number. Follow the steps outlined <a href="https://support.twitter.com/articles/110250-adding-your-mobile-number-to-your-account-via-web">here</a> to do this.</p>

<p>To register a new application, follow these steps:</p>

<ol>
  <li>Make sure you‚Äôre logged in to Twitter</li>
  <li>Visit <a href="https://apps.twitter.com/">https://apps.twitter.com/</a></li>
  <li>Click the button for ‚ÄúRegister New App‚Äù</li>
  <li>For description you can enter whatever you want, but for ‚ÄúWebsite‚Äù, you‚Äôll want
to enter ‚Äúhttp://127.0.0.1:3000‚Äù, and for ‚ÄúCallback URL‚Äù ‚Äúhttp://127.0.0.1:3000/auth/twitter/callback‚Äù</li>
  <li>You should end up on a url like ‚Äúhttps://apps.twitter.com/app/my-app-id‚Äù. Save this link
as we‚Äôll want to use the credentials from it later in the tutorial.</li>
</ol>

<h3 id="step-2---setting-up-our-application">Step 2 - Setting up our Application</h3>

<p>Let‚Äôs add ‚ÄúSign in with Twitter‚Äù to our favorite rails app, Storedom:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/turingschool-examples/storedom.git oauth-workshop
cd oauth-workshop
bundle
rake db:setup
</code></pre></div></div>

<h3 id="step-3---adding-omniauth">Step 3 - Adding Omniauth</h3>

<p>OmniAuth is a popular ruby library for integrating OAuth into a rails application,
and we‚Äôll be using it in our app to connect with Twitter‚Äôs OAuth service.</p>

<p>In fact we‚Äôll actually be using 2 pieces here: the <code class="highlighter-rouge">omniauth</code> core library which is implemented
as a Rack Middleware (an intermediate ‚Äúlayer‚Äù in our application stack), and the <code class="highlighter-rouge">omniauth-twitter</code>
library, which adds specific provider support for Twitter.</p>

<p>One great thing about OAuth is that it‚Äôs open for extensibility ‚Äì anyone who wants to implement
the protocol on their own servers can become a provider. For this reason the OmniAuth gem is designed
to accept provider-specific ‚Äústrategies‚Äù, such as the ‚ÄúTwitter Strategy‚Äù which we‚Äôll be using.</p>

<p><code class="highlighter-rouge">omniauth</code> is a dependency of the <code class="highlighter-rouge">omniauth-twitter</code> library, so we can get started by just adding this gem
to our <code class="highlighter-rouge">Gemfile</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In Gemfile</span>
<span class="n">gem</span> <span class="s2">"omniauth-twitter"</span>
</code></pre></div></div>

<p>Then <code class="highlighter-rouge">bundle</code> your application.</p>

<h3 id="step-4---configuring-omniauth">Step 4 - Configuring OmniAuth</h3>

<p>Now that we have omniauth installed, we need to configure it to recognize our specific application.
We‚Äôll do this by telling OmniAuth to use the credentials we acquired from twitter when we registered
our application in Step 1.</p>

<ol>
  <li>Go back to your twitter application page and click on the tab labeled ‚ÄúKeys and Access Tokens‚Äù.</li>
  <li>Retrieve the 2 keys labeled ‚ÄúConsumer Key (API Key)‚Äù and ‚ÄúConsumer Secret (API Secret)‚Äù, respectively.</li>
  <li>Create a new <code class="highlighter-rouge">initializer</code> in your application at <code class="highlighter-rouge">config/initializers/omniauth.rb</code></li>
  <li>Configure OmniAuth in the initializer by adding the following lines:</li>
</ol>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># in config/initializers/omniauth.rb</span>

<span class="no">Rails</span><span class="p">.</span><span class="nf">application</span><span class="p">.</span><span class="nf">config</span><span class="p">.</span><span class="nf">middleware</span><span class="p">.</span><span class="nf">use</span> <span class="no">OmniAuth</span><span class="o">::</span><span class="no">Builder</span> <span class="k">do</span>
  <span class="n">provider</span> <span class="ss">:twitter</span><span class="p">,</span> <span class="s2">"YOUR_CONSUMER_API_KEY"</span><span class="p">,</span> <span class="s2">"YOUR_CONSUMER_API_SECRET"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Make sure you restart your application after adding this, since initializers only get run
on application startup.</p>

<p><strong>Note</strong> that you should extract these values as environment-provided keys before deploying your
application or committing it to version control.</p>

<h3 id="step-5---adding-our-sign-in-with-twitter-button">Step 5 - Adding our ‚ÄúSign in with Twitter‚Äù button</h3>

<p>We have our basic omniauth configuration in place, but so far there‚Äôs not much to do with it. Let‚Äôs fix this by filling in routing and adding our button:</p>

<ul>
  <li>Add a <code class="highlighter-rouge">get</code> route for <code class="highlighter-rouge">/auth/twitter</code> (this is a special route used by omniauth) and specify <code class="highlighter-rouge">:twitter_login</code> as the value for the <code class="highlighter-rouge">:as</code> key. You don‚Äôt need to specify the <code class="highlighter-rouge">:to</code> key.</li>
  <li>Add a ‚ÄúLogin‚Äù link to <code class="highlighter-rouge">app/views/layouts/_navbar.html.erb</code> which points to the <code class="highlighter-rouge">twitter_login_path</code> we just established.
    <ul>
      <li>Refer to the <a href="https://getbootstrap.com/components/#navbar">bootstrap docs to add to the navbar</a></li>
    </ul>
  </li>
</ul>

<p>Test your work by loading the root path. The login link should now be in the navbar.
Now click the login link. If your application is configured correctly, you should be taken off to a twitter-hosted
url and shown the standard ‚ÄúSign in with Twitter‚Äù screen.</p>

<p>Accept the login and see what happens.</p>

<h3 id="step-6---handling-the-oauth-callback">Step 6 - Handling the OAuth Callback</h3>

<p>OAuth uses a callback-redirect system to allow communication between the provider
and our application. When we want to authenticate a user with twitter, we will redirect them
to a special twitter URL used for this purpose (actually OmniAuth will do this for us, but this
is what‚Äôs going on under the covers).</p>

<p>Once the user has approved our application, Twitter will redirect the user back to our application.
We‚Äôre currently <em>not</em> handling this ‚Äúcallback‚Äù request, which is why we got a routing error after
we logged in with twitter in the previous example.</p>

<p>Let‚Äôs add a route to handle that now. But where do we put it? Conceptually, the purpose of this
request is to log the user in to our application. Twitter has said they are OK, so we‚Äôll need
to cookie them in some way so that we can identify them on future requests.</p>

<p>Where have we put that type of logic in the past? That‚Äôs right ‚Äì <code class="highlighter-rouge">SessionsController#create</code>.
Set up a controller and route to handle this request:</p>

<ol>
  <li>Create a <code class="highlighter-rouge">SessionsController</code> with a <code class="highlighter-rouge">create</code> action</li>
  <li>Add a route that maps a <code class="highlighter-rouge">get</code> request for <code class="highlighter-rouge">/auth/twitter/callback</code> to <code class="highlighter-rouge">sessions#create</code></li>
</ol>

<p>Return to the root page and click the ‚Äúlogin‚Äù link again. You‚Äôll likely get an <code class="highlighter-rouge">ActionView::Template</code> error
since we haven‚Äôt actually filled in any view or route handling for this endpoint yet.</p>

<h3 id="step-7---capturing-user-data-from-the-oauth-callback">Step 7 - Capturing User Data from the OAuth Callback</h3>

<p>We can now see that users are getting back to our application after authenticating
with twitter, but there‚Äôs still a big question we haven‚Äôt solved ‚Äì how do we know
who the user is when they arrive?</p>

<p>We mentioned earlier that one of the important points about OAuth is that providers
can send us some basic data about the user once they‚Äôve authenticated. This is actually
done by embedding data in the request headers, and fortunately omniauth gives
us an easy way to access this data.</p>

<p>Let‚Äôs update our <code class="highlighter-rouge">SessionsController#create</code> action with the following implementation:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># in app/controllers/sessions_controller.rb</span>
<span class="k">def</span> <span class="nf">create</span>
  <span class="n">render</span> <span class="ss">text: </span><span class="n">request</span><span class="p">.</span><span class="nf">env</span><span class="p">[</span><span class="s2">"omniauth.auth"</span><span class="p">].</span><span class="nf">inspect</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Calling <code class="highlighter-rouge">render :text</code> from a controller does just what it sounds like: renders raw text as the response
instead of the standard html template.</p>

<p>This can be a handy debugging technique when we just want to inspect some data ‚Äì in this case the auth data
that twitter sent back to us packaged up under the <code class="highlighter-rouge">omniauth.auth</code> header.</p>

<p>If we look closely we can see that this <code class="highlighter-rouge">omniauth.auth</code> object is a hash-like data structure, and embedded within it are
a handful of user details, including their screen_name, follower count, location, name, user id (on twitter),
as well as an oauth token, which can be used to make authenticated requests to twitter on the user‚Äôs
behalf.</p>

<p>So what do we do with this information? Remember part of the purpose of using OAuth is that this
flow replaces our standard user ‚Äúsign up‚Äù flow. To that end, we‚Äôd like to capture
these user details and store them somewhere. Typically this would be done in
a database, although we could also imagine saving the information in a cookie or some
other storage medium.</p>

<p>Now that we‚Äôve identified the mechanism by which Twitter sends us information about the
authenticated user, in the next step we‚Äôll look at how we might save this into our own
database.</p>

<h3 id="step-8---adding-oauth-to-the-user-model">Step 8 - Adding oAuth to the User model</h3>

<p>Assuming we‚Äôd like to save our OAuth user details in the DB, let‚Äôs consider the
new user information we‚Äôd like to save to our new <code class="highlighter-rouge">User</code> model:</p>

<ul>
  <li><code class="highlighter-rouge">screen_name</code></li>
  <li><code class="highlighter-rouge">user_id</code> (by convention, we often save this into a column called <code class="highlighter-rouge">uid</code>)</li>
  <li><code class="highlighter-rouge">oauth_token</code></li>
  <li><code class="highlighter-rouge">oauth_token_secret</code></li>
</ul>

<p>We could grab more information out of the omniauth auth hash, but this is probably
enough to start.</p>

<p>Let‚Äôs generate a user model with columns to store all this new information:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rails g migration AddOAuthFieldsToUser screen_name:string uid:string oauth_token:string oauth_token_secret:string
rake db:migrate
</code></pre></div></div>

<p>Notice that we‚Äôre saving all this information as strings, even the <code class="highlighter-rouge">uid</code> which often takes
the form of an integer. Storing this field as a string is relatively conventional,
since it leaves us the flexibility to potentially handle more providers in the future
whose <code class="highlighter-rouge">uid</code> might not be formatted as an integer.</p>

<h3 id="step-9---creating-users">Step 9 - Creating Users</h3>

<p>So what does it mean when a user arrives at our OAuth callback url (i.e. <code class="highlighter-rouge">SessionsController#create</code>).</p>

<p>Well it actually could mean one of 2 things: either it is a new user on their
first visit to the site <em>or</em> it is a returning user who had been logged out
somehow.</p>

<p>When managing our own user signup / auth flow, we typically have separate paths for new users
and returning ones. But with OAuth everyone goes through the same path, since everyone needs
to pass through the external OAuth provider.</p>

<p>Because of this, let‚Äôs consider what we need to do in our <code class="highlighter-rouge">Sessions#create</code> action:</p>

<ol>
  <li>If the user does not exist, we should create a record for them, and cookie them so
they will remain logged in.</li>
  <li>If the user does exist, we should recognize their existing record, and cookie them
with that record so they will remain logged in.</li>
</ol>

<p>So how do we know if the user exists? The key lies in the <code class="highlighter-rouge">omniauth.auth</code> information
that twitter sent to us on the callback redirect. Fortunately they include an
identifying <code class="highlighter-rouge">user_id</code>, which will be unique among twitter‚Äôs system. Thus if
there is an existing user in the DB with the provided twitter <code class="highlighter-rouge">user_id</code>, we
can assume it is the same user, and re-use that record.</p>

<p>Otherwise we‚Äôll want to create a new record with all the appropriate information.</p>

<p>Let‚Äôs define a method to handle all of this logic in our <code class="highlighter-rouge">User</code> model:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># in app/models/user.rb</span>

<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">from_omniauth</span><span class="p">(</span><span class="n">auth_info</span><span class="p">)</span>
  <span class="n">where</span><span class="p">(</span><span class="ss">uid: </span><span class="n">auth_info</span><span class="p">[</span><span class="ss">:uid</span><span class="p">]).</span><span class="nf">first_or_create</span> <span class="k">do</span> <span class="o">|</span><span class="n">new_user</span><span class="o">|</span>
    <span class="n">new_user</span><span class="p">.</span><span class="nf">uid</span>                <span class="o">=</span> <span class="n">auth_info</span><span class="p">.</span><span class="nf">uid</span>
    <span class="n">new_user</span><span class="p">.</span><span class="nf">name</span>               <span class="o">=</span> <span class="n">auth_info</span><span class="p">.</span><span class="nf">extra</span><span class="p">.</span><span class="nf">raw_info</span><span class="p">.</span><span class="nf">name</span>
    <span class="n">new_user</span><span class="p">.</span><span class="nf">screen_name</span>        <span class="o">=</span> <span class="n">auth_info</span><span class="p">.</span><span class="nf">extra</span><span class="p">.</span><span class="nf">raw_info</span><span class="p">.</span><span class="nf">screen_name</span>
    <span class="n">new_user</span><span class="p">.</span><span class="nf">oauth_token</span>        <span class="o">=</span> <span class="n">auth_info</span><span class="p">.</span><span class="nf">credentials</span><span class="p">.</span><span class="nf">token</span>
    <span class="n">new_user</span><span class="p">.</span><span class="nf">oauth_token_secret</span> <span class="o">=</span> <span class="n">auth_info</span><span class="p">.</span><span class="nf">credentials</span><span class="p">.</span><span class="nf">secret</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Let‚Äôs walk through what we‚Äôre doing here:</p>

<ol>
  <li>Take in the provided omniauth authentication info</li>
  <li>Read the <code class="highlighter-rouge">user_id</code> from the <code class="highlighter-rouge">auth_info</code>. If a user already exists with the
<code class="highlighter-rouge">uid</code> value of that <code class="highlighter-rouge">user_id</code>, then we‚Äôve found who we‚Äôre looking for,
and can return her.</li>
  <li>Otherwise, we need to create this user. The next section parses
out the various pieces of information needed to create a user from the
auth hash.</li>
</ol>

<p>Now that we have this in place, let‚Äôs look at using it from
our <code class="highlighter-rouge">SessionsController</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># in app/controllers/sessions_controller.rb</span>
  <span class="k">def</span> <span class="nf">create</span>
    <span class="k">if</span> <span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">from_omniauth</span><span class="p">(</span><span class="n">request</span><span class="p">.</span><span class="nf">env</span><span class="p">[</span><span class="s2">"omniauth.auth"</span><span class="p">])</span>
      <span class="n">session</span><span class="p">[</span><span class="ss">:user_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">user</span><span class="p">.</span><span class="nf">id</span>
    <span class="k">end</span>
    <span class="n">redirect_to</span> <span class="n">root_path</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>Here we generate a user from the provided omniauth information.
Assuming one is created, we cookie them so we can identify them on future requests.
Then we simply redirect them. All in one signup/login flow.</p>

<p>Return to the root of your app once more, and click the login button.
If all goes well, this time you will end up back on the root page!</p>

<p>We so far have no visible evidence that the process works, but we will
fix that shortly.</p>

<h3 id="step-10---identifying-logged-in-users">Step 10 - Identifying Logged In Users</h3>

<p>Now that we‚Äôve created a user and (hopefully) cookied them appropriately,
let‚Äôs look at displaying some feedback that this whole process actually
worked.</p>

<p>Let‚Äôs start by adding a familial <code class="highlighter-rouge">current_user</code> helper method in our
<code class="highlighter-rouge">ApplicationController</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># in app/controllers/application_controller.rb</span>
<span class="n">helper_method</span> <span class="ss">:current_user</span>

<span class="k">def</span> <span class="nf">current_user</span>
  <span class="vi">@current_user</span> <span class="o">||=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find_by</span><span class="p">(</span><span class="ss">id: </span><span class="n">session</span><span class="p">[</span><span class="ss">:user_id</span><span class="p">])</span> <span class="k">if</span> <span class="n">session</span><span class="p">[</span><span class="ss">:user_id</span><span class="p">]</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now let‚Äôs use this back in our welcome template:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="sx">%# in app/views/layouts/_navbar.html.erb %&gt;

&lt;% if current_user %&gt;
  Hello, &lt;%= current_user.name %&gt;
&lt;% else %&gt;
  &lt;%= link_to "Sign in with Twitter", twitter_login_path %&gt;
&lt;% end %&gt;
</span></code></pre></div></div>

<p>Refresh the page. If all goes well, you should see a small message welcoming you
to our very simple (but thoroughly OAuth-ed) site.</p>

<h3 id="step-11---logging-out">Step 11 - Logging Out</h3>

<p>As a simple enhancement, let‚Äôs also add a link that let‚Äôs our users log out once logged in.</p>

<p>First, add a route which connects a <code class="highlighter-rouge">delete</code> request to <code class="highlighter-rouge">/logout</code> to <code class="highlighter-rouge">SessionsController#destroy</code>
and name it as <code class="highlighter-rouge">logout</code>.</p>

<p>Then, update your <code class="highlighter-rouge">app/views/layouts/_navbar.html.erb</code> template to include the logout link:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="sx">% if </span><span class="n">current_user</span> <span class="sx">%&gt;
  hello, &lt;%= current_user.name %&gt;</span><span class="p">.</span>
  <span class="nf">&lt;</span><span class="o">%=</span> <span class="n">link_to</span> <span class="s2">"Logout"</span><span class="p">,</span> <span class="n">logout_path</span><span class="p">,</span> <span class="ss">method: :delete</span> <span class="o">%&gt;</span>
<span class="o">&lt;</span><span class="sx">% else </span><span class="o">%&gt;</span>
  <span class="o">&lt;</span><span class="sx">%= link_to "Sign in with Twitter", twitter_login_path %&gt;
&lt;% end %&gt;
</span></code></pre></div></div>

<p>Finally, add a <code class="highlighter-rouge">#destroy</code> method to your <code class="highlighter-rouge">SessionsController</code>, which clears
the user‚Äôs session and redirects them back to the root path.</p>

<p>At this point, you should have a basic login/logout system working with OAuth!</p>

<h3 id="step-12---testing">Step 12 - Testing</h3>

<p>One thing we haven‚Äôt addressed yet is testing. Now that we have a basic idea of what
the OAuth process entails, let‚Äôs discuss some topics to incorporate it into our application‚Äôs
test suite.</p>

<p>The basic challenge here is that OAuth does add some additional complexity into our
application. Specifically, it adds a network dependency on an external service.
When a user wants to log in, we have to bounce them to the external provider‚Äôs auth
infrastructure and back.</p>

<p>This external network dependency is especially frustrating in our test suite. We‚Äôd
ideally like our test suite to run quickly and in total isolation, which using a real
OAuth connection would make relatively impossible.</p>

<p>In addition, we‚Äôd prefer not to need to create real Twitter (or whatever service provider
we are using) accounts that will be used in our test suite.</p>

<p>In short, for testing purposes, we‚Äôd like to ‚Äúmock out‚Äù the OAuth process. Fortunately
OmniAuth includes some useful tools for doing this. In this section, we‚Äôll look at
using OmniAuth‚Äôs built-in mocking facilities to fake out a Twitter user in our
test suite.</p>

<h3 id="step-13---testing-setup">Step 13 - Testing Setup</h3>

<p>First, let‚Äôs add some basic tools to our project. In your <code class="highlighter-rouge">Gemfile</code>, in the development
and test groups, add the <code class="highlighter-rouge">capybara</code> gem:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># in Gemfile</span>
<span class="n">group</span> <span class="ss">:development</span><span class="p">,</span> <span class="ss">:test</span> <span class="k">do</span>
  <span class="n">gem</span> <span class="s1">'capybara'</span>
<span class="k">end</span>
</code></pre></div></div>

<p>and bundle.</p>

<p>Next, let‚Äôs make a new integration test file called <code class="highlighter-rouge">user_logs_in_with_twitter_test.rb</code>.</p>

<p>Fill it with some basic test set up:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># in test/integration/user_logs_in_with_twitter_test.rb</span>
<span class="nb">require</span> <span class="s2">"test_helper"</span>
<span class="k">class</span> <span class="nc">UserLogsInWithTwitterTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
  <span class="kp">include</span> <span class="no">Capybara</span><span class="o">::</span><span class="no">DSL</span>
  <span class="k">def</span> <span class="nf">setup</span>
    <span class="no">Capybara</span><span class="p">.</span><span class="nf">app</span> <span class="o">=</span> <span class="no">OauthWorkshop</span><span class="o">::</span><span class="no">Application</span>
  <span class="k">end</span>

  <span class="nb">test</span> <span class="s2">"logging in"</span> <span class="k">do</span>
    <span class="n">visit</span> <span class="s2">"/"</span>
    <span class="n">assert_equal</span> <span class="mi">200</span><span class="p">,</span> <span class="n">page</span><span class="p">.</span><span class="nf">status_code</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p><strong>Note</strong> that the name of your application may be different if you used a different
name when you generated it. You can find the proper name to use here by looking
in <code class="highlighter-rouge">config/application.rb</code> for the name of the <code class="highlighter-rouge">module</code> which wraps your
Rails application definition.</p>

<p>Run your tests with <code class="highlighter-rouge">rake</code> and make sure you have a single passing test,
indicating that our test infrastructure is configured correctly.</p>

<h3 id="step-14---filling-in-user-flow">Step 14 - Filling in User Flow</h3>

<p>Next let‚Äôs start to fill in the details for this test. Consider the user‚Äôs flow
through our app:</p>

<ul>
  <li>User visits the homepage</li>
  <li>User clicks the login link</li>
  <li>User should be redirected via twitter Oauth flow (which we will be stubbing out)</li>
  <li>User should end up on the homepage again</li>
  <li>User should now see their name displayed, along with a logout link</li>
</ul>

<p>Let‚Äôs fill in some test code to make this happen:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># in test/integration/user_logs_in_with_twitter_test.rb</span>
<span class="nb">require</span> <span class="s2">"test_helper"</span>
<span class="k">class</span> <span class="nc">UserLogsInWithTwitterTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
  <span class="kp">include</span> <span class="no">Capybara</span><span class="o">::</span><span class="no">DSL</span>
  <span class="k">def</span> <span class="nf">setup</span>
    <span class="no">Capybara</span><span class="p">.</span><span class="nf">app</span> <span class="o">=</span> <span class="no">OauthWorkshop</span><span class="o">::</span><span class="no">Application</span>
  <span class="k">end</span>

  <span class="nb">test</span> <span class="s2">"logging in"</span> <span class="k">do</span>
    <span class="n">visit</span> <span class="s2">"/"</span>
    <span class="n">assert_equal</span> <span class="mi">200</span><span class="p">,</span> <span class="n">page</span><span class="p">.</span><span class="nf">status_code</span>
    <span class="n">click_link</span> <span class="s2">"Sign in with Twitter"</span>
    <span class="n">assert_equal</span> <span class="s2">"/"</span><span class="p">,</span> <span class="n">current_path</span>
    <span class="n">assert</span> <span class="n">page</span><span class="p">.</span><span class="nf">has_content?</span><span class="p">(</span><span class="s2">"Horace"</span><span class="p">)</span>
    <span class="n">assert</span> <span class="n">page</span><span class="p">.</span><span class="nf">has_link?</span><span class="p">(</span><span class="s2">"Logout"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Run this test and see what happens. You should get
a routing error similar to:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ActionController::RoutingError: No route matches [GET] "/oauth/authenticate"
</code></pre></div></div>

<p>This is because by default, our OAuth middleware is disabled in test mode.
As we said before, we need to provide a ‚Äúmock‚Äù implementation for our test
suite, so that the tests don‚Äôt need the real OAuth implementation in order to
pass.</p>

<h3 id="step-15---using-omniauthmock_auth-to-stub-oauth-details">Step 15 - Using OmniAuth.mock_auth to stub OAuth details</h3>

<p>We can do this using the <code class="highlighter-rouge">mock_auth</code> method on <code class="highlighter-rouge">OmniAuth.config</code>. Here‚Äôs
an example of how to do this for twitter:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">stub_omniauth</span>
    <span class="c1"># first, set OmniAuth to run in test mode</span>
    <span class="no">OmniAuth</span><span class="p">.</span><span class="nf">config</span><span class="p">.</span><span class="nf">test_mode</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="c1"># then, provide a set of fake oauth data that</span>
    <span class="c1"># omniauth will use when a user tries to authenticate:</span>
    <span class="no">OmniAuth</span><span class="p">.</span><span class="nf">config</span><span class="p">.</span><span class="nf">mock_auth</span><span class="p">[</span><span class="ss">:twitter</span><span class="p">]</span> <span class="o">=</span> <span class="no">OmniAuth</span><span class="o">::</span><span class="no">AuthHash</span><span class="p">.</span><span class="nf">new</span><span class="p">({</span>
      <span class="ss">provider: </span><span class="s1">'twitter'</span><span class="p">,</span>
      <span class="ss">extra: </span><span class="p">{</span>
        <span class="ss">raw_info: </span><span class="p">{</span>
          <span class="ss">user_id: </span><span class="s2">"1234"</span><span class="p">,</span>
          <span class="ss">name: </span><span class="s2">"Horace"</span><span class="p">,</span>
          <span class="ss">screen_name: </span><span class="s2">"worace"</span>
        <span class="p">}</span>
      <span class="p">},</span>
      <span class="ss">credentials: </span><span class="p">{</span>
        <span class="ss">token: </span><span class="s2">"pizza"</span><span class="p">,</span>
        <span class="ss">secret: </span><span class="s2">"secretpizza"</span>
      <span class="p">}</span>
    <span class="p">})</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>The config we are providing looks a bit complicated at first, but it‚Äôs just
a nested hash with the proper structure for containing the data we need.</p>

<p>So how do we know what data we need? If we look closely, we‚Äôll see that the
structure we‚Äôre using here mirrors what we were consuming from the <code class="highlighter-rouge">auth_data</code>
OmniAuth provided us in our <code class="highlighter-rouge">User.from_omniauth</code> method.</p>

<p>This process can be a bit tedious, since the shape of the data will often vary
from provider to provider. But the easiest way to figure out what you need is to
capture a real auth_hash in development, investigate its structure, and determine
which keys and values you need to provide.</p>

<h3 id="step-16---putting-the-full-test-together">Step 16 - Putting the Full Test Together</h3>

<p>Now that we have a method for configuring OmniAuth with test data, let‚Äôs invoke that
in our test‚Äôs <code class="highlighter-rouge">setup</code> method. Here‚Äôs the whole test file that we have up to now:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s2">"test_helper"</span>
<span class="k">class</span> <span class="nc">UserLogsInWithTwitterTest</span> <span class="o">&lt;</span> <span class="no">ActionDispatch</span><span class="o">::</span><span class="no">IntegrationTest</span>
  <span class="kp">include</span> <span class="no">Capybara</span><span class="o">::</span><span class="no">DSL</span>
  <span class="k">def</span> <span class="nf">setup</span>
    <span class="no">Capybara</span><span class="p">.</span><span class="nf">app</span> <span class="o">=</span> <span class="no">Storedom</span><span class="o">::</span><span class="no">Application</span>
    <span class="n">stub_omniauth</span>
  <span class="k">end</span>

  <span class="nb">test</span> <span class="s2">"logging in"</span> <span class="k">do</span>
    <span class="n">visit</span> <span class="s2">"/"</span>
    <span class="n">assert_equal</span> <span class="mi">200</span><span class="p">,</span> <span class="n">page</span><span class="p">.</span><span class="nf">status_code</span>
    <span class="n">click_link</span> <span class="s2">"login"</span>
    <span class="n">assert_equal</span> <span class="s2">"/"</span><span class="p">,</span> <span class="n">current_path</span>
    <span class="n">assert</span> <span class="n">page</span><span class="p">.</span><span class="nf">has_content?</span><span class="p">(</span><span class="s2">"Horace"</span><span class="p">)</span>
    <span class="n">assert</span> <span class="n">page</span><span class="p">.</span><span class="nf">has_link?</span><span class="p">(</span><span class="s2">"logout"</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">stub_omniauth</span>
    <span class="c1"># first, set OmniAuth to run in test mode</span>
    <span class="no">OmniAuth</span><span class="p">.</span><span class="nf">config</span><span class="p">.</span><span class="nf">test_mode</span> <span class="o">=</span> <span class="kp">true</span>
    <span class="c1"># then, provide a set of fake oauth data that</span>
    <span class="c1"># omniauth will use when a user tries to authenticate:</span>
    <span class="no">OmniAuth</span><span class="p">.</span><span class="nf">config</span><span class="p">.</span><span class="nf">mock_auth</span><span class="p">[</span><span class="ss">:twitter</span><span class="p">]</span> <span class="o">=</span> <span class="no">OmniAuth</span><span class="o">::</span><span class="no">AuthHash</span><span class="p">.</span><span class="nf">new</span><span class="p">({</span>
      <span class="ss">provider: </span><span class="s1">'twitter'</span><span class="p">,</span>
      <span class="ss">extra: </span><span class="p">{</span>
        <span class="ss">raw_info: </span><span class="p">{</span>
          <span class="ss">uid: </span><span class="s2">"1234"</span><span class="p">,</span>
          <span class="ss">name: </span><span class="s2">"Horace"</span><span class="p">,</span>
          <span class="ss">screen_name: </span><span class="s2">"worace"</span><span class="p">,</span>
        <span class="p">}</span>
      <span class="p">},</span>
      <span class="ss">credentials: </span><span class="p">{</span>
        <span class="ss">token: </span><span class="s2">"pizza"</span><span class="p">,</span>
        <span class="ss">secret: </span><span class="s2">"secretpizza"</span>
      <span class="p">}</span>
    <span class="p">})</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Run your tests with <code class="highlighter-rouge">rake</code>. It should pass! If you‚Äôre still getting failures,
double check the following:</p>

<ul>
  <li>Make sure you‚Äôre calling your <code class="highlighter-rouge">stub_omniauth</code> method from your test‚Äôs <code class="highlighter-rouge">setup</code> method</li>
  <li>Make sure the structure of the data you‚Äôre providing in the <code class="highlighter-rouge">OmniAuth::AuthHash</code>
matches what your <code class="highlighter-rouge">User.from_omniauth</code> method is consuming from twitter.</li>
</ul>

<p>You now have a model for basic integration testing using OmniAuth.</p>

<p>Finally, you can read more about integration testing with omniauth <a href="https://github.com/intridea/omniauth/wiki/Integration-Testing">here</a>.</p>

<h2 id="wrapup">Wrapup</h2>

<p>In this tutorial we‚Äôve covered the basics of setting up a rails app that
authenticates with OAuth. The steps included:</p>

<ul>
  <li>Setting up an application account with an external OAuth provider</li>
  <li>Using the OmniAuth gem to incorporate the OAuth protocol flow into your application</li>
  <li>Handling the OAuth callback and capturing identification details in our
own application‚Äôs database</li>
  <li>Testing OAuth using OmniAuth‚Äôs provided mocking system</li>
</ul>

<p>Now that you understand the fundamentals of working with OAuth, you should be
able to extend this knowledge to your own applications or to working with different
OAuth providers.</p>

<h2 id="resources-for-further-study">Resources for Further Study</h2>

<ul>
  <li><a href="http://en.wikipedia.org/wiki/OAuth">OAuth</a> on Wikipedia</li>
  <li><a href="http://lifehacker.com/5918086/understanding-oauth-what-happens-when-you-log-into-a-site-with-google-twitter-or-facebook">Understanding OAuth</a> on LifeHacker</li>
  <li><a href="https://github.com/intridea/omniauth">OmniAuth</a> for integration in Ruby web apps</li>
  <li><a href="http://puu.sh/2pJ4y">Oauth 1.0 Diagram (from MashApe‚Äôs oauth bible)</a></li>
  <li><a href="http://oauthbible.com/">Oauth Bible</a> - lots of in-depth info about different oauth versions and components</li>
  <li><a href="http://edgecasesshow.com/036-zenos-paradox-of-authentication.html">Edge Cases Podcast #36</a> - Good in-depth discussion of the evolution of Oauth and the pros and cons of using it.</li>
  <li><a href="https://github.com/doorkeeper-gem/doorkeeper">Doorkeeper</a> ‚Äì Oauth provider gem</li>
  <li>OmniAuth core API documentation: https://github.com/intridea/omniauth</li>
  <li>OmniAuth wiki: https://github.com/intridea/omniauth/wiki</li>
  <li>A Devise and OmniAuth powered Single-Sign-On implementation: https://github.com/joshsoftware/sso-devise-omniauth-provider</li>
  <li><a href="http://railscasts.com/episodes/235-devise-and-omniauth-revised">RailsCast on combining Devise and OmniAuth</a></li>
</ul>
:ET