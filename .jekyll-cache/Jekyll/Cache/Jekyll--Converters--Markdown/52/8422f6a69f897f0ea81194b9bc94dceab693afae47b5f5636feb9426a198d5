I"<h2 id="what-are-you-allowed-to-do-here">What Are You Allowed to Do Here?</h2>

<p>The idea of Authentication in our previous lesson was â€œWho are you?â€. Now that youâ€™re here, and logged in, we need to explore the idea if â€œWhat are you allowed to do?â€</p>

<h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>Review of the Session object in Rails, and how itâ€™s actually stored</li>
  <li>Learn how cookies are transmitted to/from Rails</li>
  <li>Explore different kinds of Cookies</li>
  <li>Examine different ways of tracking Authorization</li>
  <li>Load an object to be used throughout the app using a <code class="highlighter-rouge">before_action</code> filter in the ApplicationController</li>
</ul>

<h2 id="warm-up">Warm Up</h2>

<ul>
  <li>What is in an HTTP request?</li>
  <li>What is in an HTTP response?</li>
  <li>What do you already know about browser Cookies?</li>
  <li>(optional) Whatâ€™s your favorite kind of cookie?</li>
</ul>

<h2 id="intro">Intro</h2>

<p>Now that weâ€™re logged in, how is Rails actually storing our session? Is that something our user can manipulate?</p>

<p>How can we have different <em>kinds</em> of users in our application, such as a â€œregularâ€ user, an â€œadminâ€ user, etc.?</p>

<h3 id="picking-up-where-we-left-off">Picking up where we left off</h3>

<p>In our previous lesson, we built a login form, had a user log in, and remembered them using a Rails <code class="highlighter-rouge">session</code>. But what is the <code class="highlighter-rouge">session</code> object all about? How does it get built, managed, stored, etc.?</p>

<h3 id="session-management-configuration">Session Management, Configuration</h3>

<p>By default, if we look for session storage in our existing Rails application, we likely wonâ€™t find any mention of the word <code class="highlighter-rouge">session</code>. Try it: hit Cmd-Shift-F in Atom or VS Code to search throughout your application for the word â€œsessionâ€ and youâ€™ll likely only see the bit of code we added to our repo from the previous lesson.</p>

<p><strong>By default, Rails stores sessions in a client-side cookie</strong>, and the configuration setting isnâ€™t even specified anywhere as a default for Rails 5.</p>

<p>We CAN override this by implementing <code class="highlighter-rouge">config.session_store</code> in <code class="highlighter-rouge">config/application.rb</code> but we donâ€™t have to for what weâ€™re building. You can read more about deeper configurations at this URL: https://guides.rubyonrails.org/v5.2/configuring.html</p>

<h3 id="is-that-really-secure">Is that really secure?</h3>

<p>Letâ€™s try it out. Go ahead and log into the application that we started in our previous lesson, and look at your cookies in Chrome:</p>

<p>Go into the Inspect tool (Cmd-Option-i), click on the Application tab along the top, click on Cookies in the left pane to expand the list of cookies, and we should see an option there for <code class="highlighter-rouge">http://localhost:3000</code></p>

<p>When we select the <code class="highlighter-rouge">localhost</code> option under our cookies, we should see a set of key/value pairs like <code class="highlighter-rouge">_congress_tracker_session</code> and a <code class="highlighter-rouge">Value</code> that we canâ€™t easily read.</p>

<p>The <code class="highlighter-rouge">name</code> of the piece of data is named after our application, plus <code class="highlighter-rouge">_session</code> at the end of it.</p>

<p>The <code class="highlighter-rouge">value</code> is unreadable. In our application, all we set in our session was our <code class="highlighter-rouge">user_id</code> value.</p>

<p>This is an <strong>encrypted</strong> cookie. Only our Rails application can decrypt this. In fact, if we were to change something in our Chrome browser about this value, we should be immediately logged out when we refresh the page.</p>

<p>Try it now:</p>

<ul>
  <li>alter the Value of the cookie, even changing one character is enough. (right-click or Ctrl-click on the value, select â€˜Edit Valueâ€™)</li>
  <li>hit Cmd-R in your main browser window to reload.</li>
  <li>notice that youâ€™re not logged in any more!</li>
  <li>notice, also, that your session cookie value has changed in Chrome!</li>
</ul>

<p>Rails protects itself from tampered cookies.</p>

<h3 id="session-cookies-are-short-lived">Session cookies are short-lived</h3>

<p>Your browser will clean up any cookies that it sees which are too â€œoldâ€. We call this an â€œexpiredâ€ cookie.</p>

<p>By default, session cookies in Rails are set to expire whenever the browser is completely closed. Having a browser open somewhere else isnâ€™t enough. If you <em>completely</em> close Chrome, for example (Cmd-Q) then any Rails-based session cookies you have in your browser will be cleaned up.</p>

<h3 id="how-can-we-make-these-last-longer">How can we make these last longer?</h3>

<p>Many web sites may have a â€œremember me for 7 daysâ€ or â€œremember me for 30 daysâ€ or sometimes just a â€œremember meâ€ checkbox when youâ€™re logging in on a web site.</p>

<p>How do THOSE work?</p>

<p>Thatâ€™s what weâ€™re going to build today.</p>

<p>But to do that, we need to build a â€œregularâ€ cookie, not a â€œsessionâ€ cookie.</p>

<p>And there are different kinds of cookies.</p>

<h2 id="cookies-in-rails">Cookies in Rails</h2>

<p>Rails 5 Documentation on Cookies:</p>

<ul>
  <li><a href="https://api.rubyonrails.org/v5.2.1/classes/ActionDispatch/Cookies.html">https://api.rubyonrails.org/v5.2.1/classes/ActionDispatch/Cookies.html</a></li>
</ul>

<p>Cookies are handled by ActionDispatch, but readable by ActionController. Since ActionController is inherited by our other controllers, we have access to cookies in any of our controller code.</p>

<p>Cookies are effectively treated like a hash. Itâ€™s a key/value storage mechanism. But cookies also have additional configuration around things like an expiration date, which â€œdomain nameâ€ itâ€™s linked to (ie, â€œlocalhostâ€ or â€œmy-awesome-app.comâ€), whether the cookie should only work for SSL/TLS enabled sites, and more.</p>

<h3 id="basic-cookie-usage">Basic Cookie Usage</h3>

<p><code class="highlighter-rouge">cookies</code> is the name of our storage, which as mentioned previously, is similar to a hash.</p>

<p>We will generally use this code within our Controllers, but we may be able to access them elsewhere in our code as well, such as in our Views.</p>

<p><code class="highlighter-rouge">cookies[:user_id] = "12"</code> is all we need to set a cookie with a key of <code class="highlighter-rouge">:user_id</code> and a value of <code class="highlighter-rouge">"12"</code>.</p>

<p>Itâ€™s important to note that keys and values in cookies are always going to be treated as <code class="highlighter-rouge">String</code> object types.</p>

<p>If you REALLY want to store a different type of object as a value, you will need to use <code class="highlighter-rouge">JSON.generate</code> like this:</p>

<p><code class="highlighter-rouge">cookies[:favorite_colors] = JSON.generate(['blue', 'red'])</code></p>

<p>We will need to use <code class="highlighter-rouge">JSON.parse</code> to read this value back into an array in our code:</p>

<p><code class="highlighter-rouge">fav_colors = JSON.parse(cookies[:favorite_colors])</code></p>

<p>Because our <code class="highlighter-rouge">cookies</code> object isnâ€™t JUST a hash, we can set additional settings in this way:</p>

<p><code class="highlighter-rouge">cookies[:site_theme] = {value: 'dark-mode', expires: 1.day}</code></p>

<p>Whoa, cool, we can set a value AND an expiration at the same time!</p>

<h3 id="expiration-times">Expiration times</h3>

<p>If we do NOT specify an expiration, then the cookie becomes â€œsessionâ€ based, and deleted when the browser is closed, just like our <code class="highlighter-rouge">session</code> cookie.</p>

<p>We can use Rubyâ€™s date helpers to set our expirations in a very easy way, such as <code class="highlighter-rouge">1.day</code> or <code class="highlighter-rouge">3.years</code> etc..</p>

<p>Rails also has a special setting for â€œpermanentâ€ cookies, which will set an expiration date of â€œ20 years from nowâ€, which we can set using this syntax:</p>

<p><code class="highlighter-rouge">cookies.permanent[:greeting] = 'Howdy!'</code></p>

<h3 id="deleting-a-cookie">Deleting a Cookie</h3>

<p>Deleting a cookie can be helpful if we log out, for example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cookies</span><span class="p">.</span><span class="nf">delete</span> <span class="ss">:greeting</span>
<span class="n">cookies</span><span class="p">.</span><span class="nf">delete</span> <span class="ss">:favorite_colors</span>
</code></pre></div></div>

<h2 id="wait-we-never-really-talked-about-security-here">Wait, we never really talked about security here!</h2>

<p>When we set a cookie in our code, and look at it in our Inspect tool in Chrome, what do we see now?</p>

<p>Letâ€™s add some code to a view that prints whatâ€™s in our cookies:</p>

<p>In our controller:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">index</span>
    <span class="k">unless</span> <span class="n">cookies</span><span class="p">[</span><span class="ss">:greeting</span><span class="p">]</span>
      <span class="n">cookies</span><span class="p">[</span><span class="ss">:greeting</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'Howdy!'</span>
    <span class="k">end</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>In a view:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="sx">%= cookies[:greeting] %&gt;
</span></code></pre></div></div>

<p>When we load the page for the first time, weâ€™ll see our â€œHowdy!â€ greeting. If we manipulate our cookie value in our browser, and reload the page, weâ€™ll see that the greeting changes to whatever weâ€™ve found in our cookie.</p>

<p>THIS is why our typical session cookie is ENCRYPTED. It cannot be tampered with, because we wouldnâ€™t want our user to try to become some other user, or access a setting that we donâ€™t want them to access.</p>

<h3 id="plain-signed-and-encrypted-cookies">Plain, Signed, and Encrypted cookies</h3>

<p>By default, cookies are generated with no security at all. Users can view them, manipulate them etc..</p>

<p>It ALSO means that malicious software (eg â€œmalwareâ€ and viruses) can sometimes scrape our cookies from our browser and inspect their keys/values, possibly even tamper with the data.</p>

<p>We can â€œsignâ€ a cookie, which acts as a type of â€œtrustâ€ that Rails will verify, so if data is manipulated in some way we can have Rails take some sort of action.</p>

<ul>
  <li>weâ€™ll need to delete our old â€˜greetingâ€™ cookie first!</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cookies</span><span class="p">.</span><span class="nf">signed</span><span class="p">[</span><span class="ss">:greeting</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'Hello there!'</span>
</code></pre></div></div>

<p>We also need to update our View to use the <code class="highlighter-rouge">.signed</code> property to read the value as well:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="sx">%= cookies.signed[:greeting] %&gt;
</span></code></pre></div></div>

<h3 id="wait-cant-really-read-this-anyway-so-whats-the-difference-between-signed-and-encrypted">Wait, canâ€™t really read this anyway so whatâ€™s the difference between Signed and Encrypted??</h3>

<p>Well, the â€œsignedâ€ text is still readable with a little extra work.</p>

<p>At the time of writing this lesson, a signed greeting of â€˜Howdy!â€™ was signed like the following cookie value:</p>

<p><code class="highlighter-rouge">Ikhvd2R5ISI=--d12208b183689c5f30379f30d149b481d23f1cd2</code></p>

<p>If we grab the first portion of the string:</p>

<p><code class="highlighter-rouge">Ikhvd2R5ISI=</code></p>

<p>We can use â€œbase64 decodingâ€ to turn this back into plaintext.</p>

<p>Visit https://www.base64decode.org/ and paste that text above, and it should turn that string into <code class="highlighter-rouge">"Howdy!"</code> which is our string. The remaining portion after the <code class="highlighter-rouge">--</code> which included <code class="highlighter-rouge">d12208b...</code> is the â€œsignatureâ€ that our Rails application added to the value which verifies that the data has not been tampered with.</p>

<p>If we use that same site to base64 encode â€œHowdyâ€ without the exclamation point, we would see it generate this string:</p>

<p><code class="highlighter-rouge">Ikhvd2R5Ig==</code></p>

<p>If we alter our browser cookie so our value is this instead, but keeping the same signature portion:</p>

<p><code class="highlighter-rouge">Ikhvd2R5Ig==--d12208b183689c5f30379f30d149b481d23f1cd2</code></p>

<p>If we reload the page, our cookie greeting is now blank!</p>

<p>This, again, is Rails protecting itself from using tampered data.</p>

<p>But malicious software can still detect that these cookies are â€œsignedâ€ and that a portion of it is still base64 encoded, and still be able to read that data!</p>

<h3 id="encrypted-cookies">Encrypted cookies</h3>

<p>If we really want these cookie values to be as secure as possible, we can encrypt the data, and only our Rails application can decrypt it.</p>

<ul>
  <li>weâ€™ll need to delete our old â€˜greetingâ€™ cookie first!</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cookies</span><span class="p">.</span><span class="nf">encrypted</span><span class="p">[</span><span class="ss">:greeting</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'Hello there!'</span>
</code></pre></div></div>

<p>We also need to update our View to use the <code class="highlighter-rouge">.signed</code> property to read the value as well:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="sx">%= cookies.encrypted[:greeting] %&gt;
</span></code></pre></div></div>

<h2 id="lessons-learned-so-far">Lessons learned (so far)</h2>

<p>Cookies are a great way to store some data, settings, etc, on the userâ€™s browser.</p>

<p>Weâ€™ve looked at plain cookies, signed cookies, and encrypted cookies, and their benefits, and interesting things like expiration dates.</p>

<p>One thing to note, though:</p>

<p>The NAME of the cookie key (ie â€œgreetingâ€) is ALWAYS plaintext-readable in the browser. If you set this to something like â€œpasswordâ€ or â€œuser_idâ€ itâ€™s more likely that malicious software (or users) will attempt to view/tamper with that data. Try to use generic-sounding key names to avoid this problem!</p>

<p>Our â€œsessionâ€ cookie just has a name of â€œappname_sessionâ€ which malicious users/malware may still try to examine, but since itâ€™s encrypted they donâ€™t know whatâ€™s in there anyway.</p>

<h1 id="remember-me-an-exercise-to-build">Remember Me, an Exercise to Build</h1>

<p>Okay, so now that weâ€™ve looked at cookies in-depth, what would be the best way to implement a â€œRemember Meâ€ cookie that will automatically log in a user when they visit our site, even if the browser is closed?</p>

<p>For starters, we know that setting our own expiration date will be a good way to ensure we donâ€™t lose the cookie when we close our browser.</p>

<p>At a high level, we need steps that look like this in our controller:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- when a user logs in, make a 'remember me' cookie with a long expiration date

- if there is a session cookie, use that
- if not, check if we have a remember-me cookie
  - if so, check if that value is valid (not tampered with)
    - if so, look up that user, and set a new session cookie
</code></pre></div></div>

<p>Note that for strong security practices, if a long-term â€œremember meâ€ cookie exists, and when you look up that user, they appear to be an â€˜adminâ€™ user, you should probably destroy the cookie and force the user to log in again. In other words, admin users should not get to use a â€œremember meâ€ cookie and always have to log in to enforce good security.</p>

<p>One other consideration: if our â€œremember meâ€ is set for, say, 24 hours, do we reset that timer every time the user takes an action within that 24 hours to give them ANOTHER 24 hours? or do we automatically log them out after 24 hours regardless?</p>

<h2 id="wrap-up-on-cookies">Wrap-Up on Cookies</h2>

<ul>
  <li>what should we store in a session cookie versus a regular cookie?</li>
  <li>how much data can we store in each cookie?</li>
  <li>how do cookies even get set in the browser?</li>
  <li>how does the browser get that cookie information back to Rails?</li>
</ul>

<hr />

<h1 id="authorization--are-you-allowed-to-do-that">Authorization â€“ Are you ALLOWED to do that??</h1>

<p>At a high level, we sometimes want to have different â€œkindsâ€ of users in our application like an â€œadminâ€ user versus a â€œregularâ€ user, maybe a â€œmanagementâ€ user.</p>

<p>We can very specific in our permissions, ie, maybe a regular user can view information, a manager can add new data but not delete things, maybe an admin user can have full CRUD functionality.</p>

<p>At a very high level, the following steps will be needed:</p>

<ul>
  <li>we need to add a â€œroleâ€ to our user model</li>
  <li>we need to have different controller code based on the userâ€™s role
    <ul>
      <li>this means that we need additional routing</li>
      <li>this introduces extra â€œname spacingâ€ in our application</li>
    </ul>
  </li>
</ul>

<h2 id="user-role">User Role</h2>

<p>We generally would make the user role an integer value so weâ€™re not storing a string over and over, and we can tell Ruby to use a lookup table called an â€œenumâ€ (short for enumerable) to convert that number to a string later.</p>

<p>How we order these values doesnâ€™t really matter, but itâ€™s important to note that we generally only add to the END of our enumerable list. If we add something in the middle of the list, we might accidentally change other roles, and that can get really confusing.</p>

<p>Rails also has some neat â€œmagicâ€ about using these enum strings to build validation routines that weâ€™ll see in a moment.</p>

<h3 id="add-a-new-role-field">Add a new <code class="highlighter-rouge">role</code> field</h3>

<p>Make a migration to add a <code class="highlighter-rouge">role</code> field for a user, which is an integer field:</p>

<p><code class="highlighter-rouge">rails g migration AddRoleToUsers role:integer</code></p>

<p>The migration should look something like this. Be sure to set the default to 0, which weâ€™ll set to be a â€œdefaultâ€ user, like a regular user with no special access.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AddRoleToUsers</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span><span class="p">[</span><span class="mf">5.2</span><span class="p">]</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">add_column</span> <span class="ss">:users</span><span class="p">,</span> <span class="ss">:role</span><span class="p">,</span> <span class="ss">:integer</span><span class="p">,</span> <span class="ss">default: </span><span class="mi">0</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Run <code class="highlighter-rouge">rake db:migrate</code> to apply this change.</p>

<p>In our User model, we need to specify our list of enumerable strings for our Roles:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_secure_password</span>

  <span class="n">enum</span> <span class="ss">role: </span><span class="sx">%w(default manager admin)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now weâ€™ll have access to interesting validations about our User model, like this:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># look up user 1</span>
<span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># is user a default user?</span>
<span class="k">if</span> <span class="n">user</span><span class="p">.</span><span class="nf">default?</span>
  <span class="c1"># default user!</span>
<span class="k">elsif</span> <span class="n">user</span><span class="p">.</span><span class="nf">manager?</span>
  <span class="c1"># user is a manager</span>
<span class="k">elsif</span> <span class="n">user</span><span class="p">.</span><span class="nf">admin?</span>
  <span class="c1"># user is an admin</span>
<span class="k">else</span>
  <span class="c1"># we don't know what kind of user they are?!</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Be default, our database will set the role to <code class="highlighter-rouge">0</code> if we do not set the <code class="highlighter-rouge">role</code> otherwise when the user registers on our site, so we DEFINITELY want to use strong params to make sure we do NOT allow the <code class="highlighter-rouge">role</code> property to be transferred to us as a form parameter!!</p>

<h2 id="logging-in-differently">Logging in differently</h2>

<p>Now, when a user logs in, we could redirect them to a different dashboard based on their role. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find_by_email</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:email</span><span class="p">].</span><span class="nf">downcase</span><span class="p">)</span>
<span class="k">if</span> <span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="p">.</span><span class="nf">authenticate</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:password</span><span class="p">])</span>
  <span class="k">if</span> <span class="n">user</span><span class="p">.</span><span class="nf">admin?</span>
    <span class="n">redirect_to</span> <span class="n">admin_dashboard_path</span>
  <span class="k">elsif</span> <span class="n">user</span><span class="p">.</span><span class="nf">manager?</span>
    <span class="n">redirect_to</span> <span class="n">manager_dashboard_path</span>
  <span class="k">elsif</span> <span class="n">user</span><span class="p">.</span><span class="nf">default?</span>
    <span class="n">redirect_to</span> <span class="n">user_dashboard_path</span>
  <span class="k">end</span>
<span class="k">else</span>
  <span class="n">flash</span><span class="p">[</span><span class="ss">:error</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"Your credentials are bad and you should feel bad"</span>
  <span class="n">render</span> <span class="ss">:new</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Then, of course, we would need to build the correct dashboards.</p>

<h2 id="whats-in-a-namespace">Whatâ€™s in a name(space)?</h2>

<p>From here, we can route to a new dashboard path, like <code class="highlighter-rouge">/admin/dashboard</code> where only our admin users can access the controller:</p>

<p><code class="highlighter-rouge">config/routes.rb</code>:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">namespace</span> <span class="ss">:admin</span>
  <span class="n">get</span> <span class="s1">'/dashboard'</span><span class="p">,</span> <span class="ss">to: </span><span class="s1">'dashboard#index'</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now, inside our <code class="highlighter-rouge">/app/controllers/</code> path we need to add a new folder called <code class="highlighter-rouge">admin</code>, and create a dashboard controller in there:</p>

<p><code class="highlighter-rouge">/app/controllers/admin/dashboard_controller.rb</code>:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Admin::DashboardController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
<span class="c1">#     ^^^^^^^</span>
<span class="c1">#     this is where we note the namespace</span>
<span class="c1">#     this will come up again when we build APIs later</span>
<span class="k">end</span> 
</code></pre></div></div>

<p>Now if we write a test where we have an admin user and log in, we can verify that we end up at the correct dashboard:</p>

<p><code class="highlighter-rouge">spec/features/admin/login_spec.rb</code></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s2">"rails_helper"</span>

<span class="n">describe</span> <span class="s2">"Admin login"</span> <span class="k">do</span>
  <span class="n">describe</span> <span class="s2">"happy path"</span> <span class="k">do</span>
    <span class="n">it</span> <span class="s2">"I can log in as an admin and get to my dashboard"</span> <span class="k">do</span>
	    <span class="n">admin</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">email: </span><span class="s2">"superuser@awesome-site.com"</span><span class="p">,</span>
                        <span class="ss">password: </span><span class="s2">"super_secret_passw0rd"</span><span class="p">,</span>
                        <span class="ss">role: </span><span class="mi">1</span><span class="p">)</span>

      <span class="n">visit</span> <span class="n">login_path</span>
      <span class="n">fill_in</span> <span class="ss">:email</span><span class="p">,</span> <span class="n">with</span> <span class="n">admin</span><span class="p">.</span><span class="nf">email</span>
      <span class="n">fill_in</span> <span class="ss">:password</span><span class="p">,</span> <span class="n">with</span> <span class="n">admin</span><span class="p">.</span><span class="nf">password</span>
      <span class="n">click_button</span> <span class="s1">'log in'</span>

      <span class="n">expect</span><span class="p">(</span><span class="n">current_path</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span><span class="p">(</span><span class="n">admin_dashboard_path</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Next, we need to make sure that regular users canâ€™t access any of our â€˜adminâ€™ paths.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">describe</span> <span class="s2">"as default user"</span> <span class="k">do</span>
    <span class="n">it</span> <span class="s1">'does not allow default user to see admin dashboard index'</span> <span class="k">do</span>
      <span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">username: </span><span class="s2">"fern@gully.com"</span><span class="p">,</span>
                         <span class="ss">password: </span><span class="s2">"password"</span><span class="p">,</span>
                         <span class="ss">role: </span><span class="mi">0</span><span class="p">)</span>

      <span class="n">allow_any_instance_of</span><span class="p">(</span><span class="no">ApplicationController</span><span class="p">).</span><span class="nf">to</span> <span class="n">receive</span><span class="p">(</span><span class="ss">:current_user</span><span class="p">).</span><span class="nf">and_return</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>

      <span class="n">visit</span> <span class="s2">"/admin/dashboard"</span>

      <span class="n">expect</span><span class="p">(</span><span class="n">page</span><span class="p">).</span><span class="nf">to</span> <span class="n">have_content</span><span class="p">(</span><span class="s2">"The page you were looking for doesn't exist."</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>In our Admin Dashboard controller, we need to use a â€œfilterâ€ to make sure that before we run any â€œaction methodâ€ (ie index, create, etc) that we check that a user is an admin user:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Admin::DashboardController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="n">before_action</span> <span class="ss">:require_admin</span>

  <span class="k">def</span> <span class="nf">index</span>
  <span class="k">end</span>

  <span class="kp">private</span>
    <span class="k">def</span> <span class="nf">require_admin</span>
      <span class="n">render</span> <span class="ss">file: </span><span class="s2">"/public/404"</span> <span class="k">unless</span> <span class="n">current_admin?</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="wait-what-is-current_admin">Wait, what is <code class="highlighter-rouge">current_admin?</code></h2>

<p>We can make another helper method in our primary application_controller:</p>

<p><code class="highlighter-rouge">/app/controllers/application_controller.rb</code>:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">current_admin?</span>
  <span class="n">current_user</span> <span class="o">&amp;&amp;</span> <span class="n">current_user</span><span class="p">.</span><span class="nf">admin?</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This will re-use our <code class="highlighter-rouge">current_user</code> method, and, if that passes, will check the <code class="highlighter-rouge">admin?</code> helper from our <code class="highlighter-rouge">enum</code> to make sure the user is also an admin user.</p>

<p>But having to build this <code class="highlighter-rouge">before_action</code> into each admin controller is going to be a nuisance, so we can make this reusable by making an equivalent â€œapplication controllerâ€ for our admin namespace. Typically youâ€™ll see this called a â€œbase controllerâ€, like this:</p>

<p><code class="highlighter-rouge">/app/controllers/application_controller.rb</code></p>
<ul>
  <li>defines <code class="highlighter-rouge">current_user</code>, <code class="highlighter-rouge">current_admin?</code> etc</li>
</ul>

<p><code class="highlighter-rouge">/app/controllers/admin/base_controller.rb</code></p>
<ul>
  <li>inherits application_controller</li>
  <li>uses our <code class="highlighter-rouge">before_action</code> and defines <code class="highlighter-rouge">require_admin</code></li>
</ul>

<p><code class="highlighter-rouge">/app/controllers/admin/dashboard_controller.rb</code></p>
<ul>
  <li>inherits our new <code class="highlighter-rouge">admin/base_controller.rb</code></li>
</ul>

<h2 id="wrap-up">Wrap-Up</h2>

<ul>
  <li>what are the main differences between authentication and authorization?</li>
  <li>how can we use both to secure our application?</li>
  <li>what does <code class="highlighter-rouge">before_action</code> do?</li>
  <li>what are good/bad things about using an <code class="highlighter-rouge">enum</code> for our role?</li>
  <li>what does <code class="highlighter-rouge">allow_any_instance_of</code> do?</li>
</ul>

:ET