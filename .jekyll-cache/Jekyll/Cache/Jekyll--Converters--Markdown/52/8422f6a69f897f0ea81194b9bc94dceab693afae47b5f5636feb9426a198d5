I"Å<h2 id="what-are-you-allowed-to-do-here">What Are You Allowed to Do Here?</h2>

<p>The idea of Authentication in our previous lesson was ‚ÄúWho are you?‚Äù. Now that you‚Äôre here, and logged in, we need to explore the idea if ‚ÄúWhat are you allowed to do?‚Äù</p>

<h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>Review of the Session object in Rails, and how it‚Äôs actually stored</li>
  <li>Learn how cookies are transmitted to/from Rails</li>
  <li>Explore different kinds of Cookies</li>
  <li>Examine different ways of tracking Authorization</li>
  <li>Load an object to be used throughout the app using a <code class="highlighter-rouge">before_action</code> filter in the ApplicationController</li>
</ul>

<h2 id="warm-up">Warm Up</h2>

<ul>
  <li>What is in an HTTP request?</li>
  <li>What is in an HTTP response?</li>
  <li>What do you already know about browser Cookies?</li>
  <li>(optional) What‚Äôs your favorite kind of cookie?</li>
</ul>

<h2 id="intro">Intro</h2>

<p>Now that we‚Äôre logged in, how is Rails actually storing our session? Is that something our user can manipulate?</p>

<p>How can we have different <em>kinds</em> of users in our application, such as a ‚Äúregular‚Äù user, an ‚Äúadmin‚Äù user, etc.?</p>

<h3 id="picking-up-where-we-left-off">Picking up where we left off</h3>

<p>In our previous lesson, we built a login form, had a user log in, and remembered them using a Rails <code class="highlighter-rouge">session</code>. But what is the <code class="highlighter-rouge">session</code> object all about? How does it get built, managed, stored, etc.?</p>

<h3 id="session-management-configuration">Session Management, Configuration</h3>

<p>By default, if we look for session storage in our existing Rails application, we likely won‚Äôt find any mention of the word <code class="highlighter-rouge">session</code>. Try it: hit Cmd-Shift-F in Atom or VS Code to search throughout your application for the word ‚Äúsession‚Äù and you‚Äôll likely only see the bit of code we added to our repo from the previous lesson.</p>

<p><strong>By default, Rails stores sessions in a client-side cookie</strong>, and the configuration setting isn‚Äôt even specified anywhere as a default for Rails 5.</p>

<p>We CAN override this by implementing <code class="highlighter-rouge">config.session_store</code> in <code class="highlighter-rouge">config/application.rb</code> but we don‚Äôt have to for what we‚Äôre building. You can read more about deeper configurations at this URL: https://guides.rubyonrails.org/v5.2/configuring.html</p>

<h3 id="is-that-really-secure">Is that really secure?</h3>

<p>Let‚Äôs try it out. Go ahead and log into the application that we started in our previous lesson, and look at your cookies in Chrome:</p>

<p>Go into the Inspect tool (Cmd-Option-i), click on the Application tab along the top, click on Cookies in the left pane to expand the list of cookies, and we should see an option there for <code class="highlighter-rouge">http://localhost:3000</code></p>

<p>When we select the <code class="highlighter-rouge">localhost</code> option under our cookies, we should see a set of key/value pairs like <code class="highlighter-rouge">_congress_tracker_session</code> and a <code class="highlighter-rouge">Value</code> that we can‚Äôt easily read.</p>

<p>The <code class="highlighter-rouge">name</code> of the piece of data is named after our application, plus <code class="highlighter-rouge">_session</code> at the end of it.</p>

<p>The <code class="highlighter-rouge">value</code> is unreadable. In our application, all we set in our session was our <code class="highlighter-rouge">user_id</code> value.</p>

<p>This is an <strong>encrypted</strong> cookie. Only our Rails application can decrypt this. In fact, if we were to change something in our Chrome browser about this value, we should be immediately logged out when we refresh the page.</p>

<p>Try it now:</p>

<ul>
  <li>alter the Value of the cookie, even changing one character is enough. (right-click or Ctrl-click on the value, select ‚ÄòEdit Value‚Äô)</li>
  <li>hit Cmd-R in your main browser window to reload.</li>
  <li>notice that you‚Äôre not logged in any more!</li>
  <li>notice, also, that your session cookie value has changed in Chrome!</li>
</ul>

<p>Rails protects itself from tampered cookies.</p>

<h3 id="session-cookies-are-short-lived">Session cookies are short-lived</h3>

<p>Your browser will clean up any cookies that it sees which are too ‚Äúold‚Äù. We call this an ‚Äúexpired‚Äù cookie.</p>

<p>By default, session cookies in Rails are set to expire whenever the browser is completely closed. Having a browser open somewhere else isn‚Äôt enough. If you <em>completely</em> close Chrome, for example (Cmd-Q) then any Rails-based session cookies you have in your browser will be cleaned up.</p>

<h3 id="how-can-we-make-these-last-longer">How can we make these last longer?</h3>

<p>Many web sites may have a ‚Äúremember me for 7 days‚Äù or ‚Äúremember me for 30 days‚Äù or sometimes just a ‚Äúremember me‚Äù checkbox when you‚Äôre logging in on a web site.</p>

<p>How do THOSE work?</p>

<p>That‚Äôs what we‚Äôre going to build today.</p>

<p>But to do that, we need to build a ‚Äúregular‚Äù cookie, not a ‚Äúsession‚Äù cookie.</p>

<p>And there are different kinds of cookies.</p>

<h2 id="cookies-in-rails">Cookies in Rails</h2>

<p>Rails 5 Documentation on Cookies:</p>

<ul>
  <li><a href="https://api.rubyonrails.org/v5.2.1/classes/ActionDispatch/Cookies.html">https://api.rubyonrails.org/v5.2.1/classes/ActionDispatch/Cookies.html</a></li>
</ul>

<p>Cookies are handled by ActionDispatch, but readable by ActionController. Since ActionController is inherited by our other controllers, we have access to cookies in any of our controller code.</p>

<p>Cookies are effectively treated like a hash. It‚Äôs a key/value storage mechanism. But cookies also have additional configuration around things like an expiration date, which ‚Äúdomain name‚Äù it‚Äôs linked to (ie, ‚Äúlocalhost‚Äù or ‚Äúmy-awesome-app.com‚Äù), whether the cookie should only work for SSL/TLS enabled sites, and more.</p>

<h3 id="basic-cookie-usage">Basic Cookie Usage</h3>

<p><code class="highlighter-rouge">cookies</code> is the name of our storage, which as mentioned previously, is similar to a hash.</p>

<p>We will generally use this code within our Controllers, but we may be able to access them elsewhere in our code as well, such as in our Views.</p>

<p><code class="highlighter-rouge">cookies[:user_id] = "12"</code> is all we need to set a cookie with a key of <code class="highlighter-rouge">:user_id</code> and a value of <code class="highlighter-rouge">"12"</code>.</p>

<p>It‚Äôs important to note that keys and values in cookies are always going to be treated as <code class="highlighter-rouge">String</code> object types.</p>

<p>If you REALLY want to store a different type of object as a value, you will need to use <code class="highlighter-rouge">JSON.generate</code> like this:</p>

<p><code class="highlighter-rouge">cookies[:favorite_colors] = JSON.generate(['blue', 'red'])</code></p>

<p>We will need to use <code class="highlighter-rouge">JSON.parse</code> to read this value back into an array in our code:</p>

<p><code class="highlighter-rouge">fav_colors = JSON.parse(cookies[:favorite_colors])</code></p>

<p>Because our <code class="highlighter-rouge">cookies</code> object isn‚Äôt JUST a hash, we can set additional settings in this way:</p>

<p><code class="highlighter-rouge">cookies[:site_theme] = {value: 'dark-mode', expires: 1.day}</code></p>

<p>Whoa, cool, we can set a value AND an expiration at the same time!</p>

<h3 id="expiration-times">Expiration times</h3>

<p>If we do NOT specify an expiration, then the cookie becomes ‚Äúsession‚Äù based, and deleted when the browser is closed, just like our <code class="highlighter-rouge">session</code> cookie.</p>

<p>We can use Ruby‚Äôs date helpers to set our expirations in a very easy way, such as <code class="highlighter-rouge">1.day</code> or <code class="highlighter-rouge">3.years</code> etc..</p>

<p>Rails also has a special setting for ‚Äúpermanent‚Äù cookies, which will set an expiration date of ‚Äú20 years from now‚Äù, which we can set using this syntax:</p>

<p><code class="highlighter-rouge">cookies.permanent[:greeting] = 'Howdy!'</code></p>

<h3 id="deleting-a-cookie">Deleting a Cookie</h3>

<p>Deleting a cookie can be helpful if we log out, for example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cookies</span><span class="p">.</span><span class="nf">delete</span> <span class="ss">:greeting</span>
<span class="n">cookies</span><span class="p">.</span><span class="nf">delete</span> <span class="ss">:favorite_colors</span>
</code></pre></div></div>

<h2 id="wait-we-never-really-talked-about-security-here">Wait, we never really talked about security here!</h2>

<p>When we set a cookie in our code, and look at it in our Inspect tool in Chrome, what do we see now?</p>

<p>Let‚Äôs add some code to a view that prints what‚Äôs in our cookies:</p>

<p>In our controller:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">index</span>
    <span class="k">unless</span> <span class="n">cookies</span><span class="p">[</span><span class="ss">:greeting</span><span class="p">]</span>
      <span class="n">cookies</span><span class="p">[</span><span class="ss">:greeting</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'Howdy!'</span>
    <span class="k">end</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>In a view:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="sx">%= cookies[:greeting] %&gt;
</span></code></pre></div></div>

<p>When we load the page for the first time, we‚Äôll see our ‚ÄúHowdy!‚Äù greeting. If we manipulate our cookie value in our browser, and reload the page, we‚Äôll see that the greeting changes to whatever we‚Äôve found in our cookie.</p>

<p>THIS is why our typical session cookie is ENCRYPTED. It cannot be tampered with, because we wouldn‚Äôt want our user to try to become some other user, or access a setting that we don‚Äôt want them to access.</p>

<h3 id="plain-signed-and-encrypted-cookies">Plain, Signed, and Encrypted cookies</h3>

<p>By default, cookies are generated with no security at all. Users can view them, manipulate them etc..</p>

<p>It ALSO means that malicious software (eg ‚Äúmalware‚Äù and viruses) can sometimes scrape our cookies from our browser and inspect their keys/values, possibly even tamper with the data.</p>

<p>We can ‚Äúsign‚Äù a cookie, which acts as a type of ‚Äútrust‚Äù that Rails will verify, so if data is manipulated in some way we can have Rails take some sort of action.</p>

<ul>
  <li>we‚Äôll need to delete our old ‚Äògreeting‚Äô cookie first!</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cookies</span><span class="p">.</span><span class="nf">signed</span><span class="p">[</span><span class="ss">:greeting</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'Hello there!'</span>
</code></pre></div></div>

<p>We also need to update our View to use the <code class="highlighter-rouge">.signed</code> property to read the value as well:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="sx">%= cookies.signed[:greeting] %&gt;
</span></code></pre></div></div>

<h3 id="wait-cant-really-read-this-anyway-so-whats-the-difference-between-signed-and-encrypted">Wait, can‚Äôt really read this anyway so what‚Äôs the difference between Signed and Encrypted??</h3>

<p>Well, the ‚Äúsigned‚Äù text is still readable with a little extra work.</p>

<p>At the time of writing this lesson, a signed greeting of ‚ÄòHowdy!‚Äô was signed like the following cookie value:</p>

<p><code class="highlighter-rouge">Ikhvd2R5ISI=--d12208b183689c5f30379f30d149b481d23f1cd2</code></p>

<p>If we grab the first portion of the string:</p>

<p><code class="highlighter-rouge">Ikhvd2R5ISI=</code></p>

<p>We can use ‚Äúbase64 decoding‚Äù to turn this back into plaintext.</p>

<p>Visit https://www.base64decode.org/ and paste that text above, and it should turn that string into <code class="highlighter-rouge">"Howdy!"</code> which is our string. The remaining portion after the <code class="highlighter-rouge">--</code> which included <code class="highlighter-rouge">d12208b...</code> is the ‚Äúsignature‚Äù that our Rails application added to the value which verifies that the data has not been tampered with.</p>

<p>If we use that same site to base64 encode ‚ÄúHowdy‚Äù without the exclamation point, we would see it generate this string:</p>

<p><code class="highlighter-rouge">Ikhvd2R5Ig==</code></p>

<p>If we alter our browser cookie so our value is this instead, but keeping the same signature portion:</p>

<p><code class="highlighter-rouge">Ikhvd2R5Ig==--d12208b183689c5f30379f30d149b481d23f1cd2</code></p>

<p>If we reload the page, our cookie greeting is now blank!</p>

<p>This, again, is Rails protecting itself from using tampered data.</p>

<p>But malicious software can still detect that these cookies are ‚Äúsigned‚Äù and that a portion of it is still base64 encoded, and still be able to read that data!</p>

<h3 id="encrypted-cookies">Encrypted cookies</h3>

<p>If we really want these cookie values to be as secure as possible, we can encrypt the data, and only our Rails application can decrypt it.</p>

<ul>
  <li>we‚Äôll need to delete our old ‚Äògreeting‚Äô cookie first!</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cookies</span><span class="p">.</span><span class="nf">encrypted</span><span class="p">[</span><span class="ss">:greeting</span><span class="p">]</span> <span class="o">=</span> <span class="s1">'Hello there!'</span>
</code></pre></div></div>

<p>We also need to update our View to use the <code class="highlighter-rouge">.signed</code> property to read the value as well:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="sx">%= cookies.encrypted[:greeting] %&gt;
</span></code></pre></div></div>

<h2 id="lessons-learned-so-far">Lessons learned (so far)</h2>

<p>Cookies are a great way to store some data, settings, etc, on the user‚Äôs browser.</p>

<p>We‚Äôve looked at plain cookies, signed cookies, and encrypted cookies, and their benefits, and interesting things like expiration dates.</p>

<p>One thing to note, though:</p>

<p>The NAME of the cookie key (ie ‚Äúgreeting‚Äù) is ALWAYS plaintext-readable in the browser. If you set this to something like ‚Äúpassword‚Äù or ‚Äúuser_id‚Äù it‚Äôs more likely that malicious software (or users) will attempt to view/tamper with that data. Try to use generic-sounding key names to avoid this problem!</p>

<p>Our ‚Äúsession‚Äù cookie just has a name of ‚Äúappname_session‚Äù which malicious users/malware may still try to examine, but since it‚Äôs encrypted they don‚Äôt know what‚Äôs in there anyway.</p>

<h1 id="remember-me-an-exercise-to-build">Remember Me, an Exercise to Build</h1>

<p>Okay, so now that we‚Äôve looked at cookies in-depth, what would be the best way to implement a ‚ÄúRemember Me‚Äù cookie that will automatically log in a user when they visit our site, even if the browser is closed?</p>

<p>For starters, we know that setting our own expiration date will be a good way to ensure we don‚Äôt lose the cookie when we close our browser.</p>

<p>At a high level, we need steps that look like this in our controller:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- when a user logs in, make a 'remember me' cookie with a long expiration date

- if there is a session cookie, use that
- if not, check if we have a remember-me cookie
  - if so, check if that value is valid (not tampered with)
    - if so, look up that user, and set a new session cookie
</code></pre></div></div>

<p>Note that for strong security practices, if a long-term ‚Äúremember me‚Äù cookie exists, and when you look up that user, they appear to be an ‚Äòadmin‚Äô user, you should probably destroy the cookie and force the user to log in again. In other words, admin users should not get to use a ‚Äúremember me‚Äù cookie and always have to log in to enforce good security.</p>

<p>One other consideration: if our ‚Äúremember me‚Äù is set for, say, 24 hours, do we reset that timer every time the user takes an action within that 24 hours to give them ANOTHER 24 hours? or do we automatically log them out after 24 hours regardless?</p>

<h2 id="wrap-up-on-cookies">Wrap-Up on Cookies</h2>

<ul>
  <li>what should we store in a session cookie versus a regular cookie?</li>
  <li>how much data can we store in each cookie?</li>
  <li>how do cookies even get set in the browser?</li>
  <li>how does the browser get that cookie information back to Rails?</li>
</ul>

<hr />

<h1 id="authorization--are-you-allowed-to-do-that">Authorization ‚Äì Are you ALLOWED to do that??</h1>

<p>At a high level, we sometimes want to have different ‚Äúkinds‚Äù of users in our application like an ‚Äúadmin‚Äù user versus a ‚Äúregular‚Äù user, maybe a ‚Äúmanagement‚Äù user.</p>

<p>We can very specific in our permissions, ie, maybe a regular user can view information, a manager can add new data but not delete things, maybe an admin user can have full CRUD functionality.</p>

<p>At a very high level, the following steps will be needed:</p>

<ul>
  <li>we need to add a ‚Äúrole‚Äù to our user model</li>
  <li>we need to have different controller code based on the user‚Äôs role
    <ul>
      <li>this means that we need additional routing</li>
      <li>this introduces extra ‚Äúname spacing‚Äù in our application</li>
    </ul>
  </li>
</ul>

<h2 id="user-role">User Role</h2>

<p>We generally would make the user role an integer value so we‚Äôre not storing a string over and over, and we can tell Ruby to use a lookup table called an ‚Äúenum‚Äù (short for enumerable) to convert that number to a string later.</p>

<p>How we order these values doesn‚Äôt really matter, but it‚Äôs important to note that we generally only add to the END of our enumerable list. If we add something in the middle of the list, we might accidentally change other roles, and that can get really confusing.</p>

<p>Rails also has some neat ‚Äúmagic‚Äù about using these enum strings to build validation routines that we‚Äôll see in a moment.</p>

<h3 id="add-a-new-role-field">Add a new <code class="highlighter-rouge">role</code> field</h3>

<p>Make a migration to add a <code class="highlighter-rouge">role</code> field for a user, which is an integer field:</p>

<p><code class="highlighter-rouge">rails g migration AddRoleToUsers role:integer</code></p>

<p>The migration should look something like this. Be sure to set the default to 0, which we‚Äôll set to be a ‚Äúdefault‚Äù user, like a regular user with no special access.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">AddRoleToUsers</span> <span class="o">&lt;</span> <span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Migration</span><span class="p">[</span><span class="mf">5.2</span><span class="p">]</span>
  <span class="k">def</span> <span class="nf">change</span>
    <span class="n">add_column</span> <span class="ss">:users</span><span class="p">,</span> <span class="ss">:role</span><span class="p">,</span> <span class="ss">:integer</span><span class="p">,</span> <span class="ss">default: </span><span class="mi">0</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Run <code class="highlighter-rouge">rake db:migrate</code> to apply this change.</p>

<p>In our User model, we need to specify our list of enumerable strings for our Roles:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">User</span> <span class="o">&lt;</span> <span class="no">ApplicationRecord</span>
  <span class="n">has_secure_password</span>

  <span class="n">enum</span> <span class="ss">role: </span><span class="sx">%w(default manager admin)</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now we‚Äôll have access to interesting validations about our User model, like this:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># look up user 1</span>
<span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># is user a default user?</span>
<span class="k">if</span> <span class="n">user</span><span class="p">.</span><span class="nf">default?</span>
  <span class="c1"># default user!</span>
<span class="k">elsif</span> <span class="n">user</span><span class="p">.</span><span class="nf">manager?</span>
  <span class="c1"># user is a manager</span>
<span class="k">elsif</span> <span class="n">user</span><span class="p">.</span><span class="nf">admin?</span>
  <span class="c1"># user is an admin</span>
<span class="k">else</span>
  <span class="c1"># we don't know what kind of user they are?!</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Be default, our database will set the role to <code class="highlighter-rouge">0</code> if we do not set the <code class="highlighter-rouge">role</code> otherwise when the user registers on our site, so we DEFINITELY want to use strong params to make sure we do NOT allow the <code class="highlighter-rouge">role</code> property to be transferred to us as a form parameter!!</p>

<h2 id="logging-in-differently">Logging in differently</h2>

<p>Now, when a user logs in, we could redirect them to a different dashboard based on their role. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">find_by_email</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:email</span><span class="p">].</span><span class="nf">downcase</span><span class="p">)</span>
<span class="k">if</span> <span class="n">user</span> <span class="o">&amp;&amp;</span> <span class="n">user</span><span class="p">.</span><span class="nf">authenticate</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:password</span><span class="p">])</span>
  <span class="k">if</span> <span class="n">user</span><span class="p">.</span><span class="nf">admin?</span>
    <span class="n">redirect_to</span> <span class="n">admin_dashboard_path</span>
  <span class="k">elsif</span> <span class="n">user</span><span class="p">.</span><span class="nf">manager?</span>
    <span class="n">redirect_to</span> <span class="n">manager_dashboard_path</span>
  <span class="k">elsif</span> <span class="n">user</span><span class="p">.</span><span class="nf">default?</span>
    <span class="n">redirect_to</span> <span class="n">user_dashboard_path</span>
  <span class="k">end</span>
<span class="k">else</span>
  <span class="n">flash</span><span class="p">[</span><span class="ss">:error</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"Your credentials are bad and you should feel bad"</span>
  <span class="n">render</span> <span class="ss">:new</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Then, of course, we would need to build the correct dashboards.</p>

<h2 id="whats-in-a-namespace">What‚Äôs in a name(space)?</h2>

<p>From here, we can route to a new dashboard path, like <code class="highlighter-rouge">/admin/dashboard</code> where only our admin users can access the controller:</p>

<p><code class="highlighter-rouge">config/routes.rb</code>:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">namespace</span> <span class="ss">:admin</span>
  <span class="n">get</span> <span class="s1">'/dashboard'</span><span class="p">,</span> <span class="ss">to: </span><span class="s1">'dashboard#index'</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now, inside our <code class="highlighter-rouge">/app/controllers/</code> path we need to add a new folder called <code class="highlighter-rouge">admin</code>, and create a dashboard controller in there:</p>

<p><code class="highlighter-rouge">/app/controllers/admin/dashboard_controller.rb</code>:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Admin::DashboardController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
<span class="c1">#     ^^^^^^^</span>
<span class="c1">#     this is where we note the namespace</span>
<span class="c1">#     this will come up again when we build APIs later</span>
<span class="k">end</span> 
</code></pre></div></div>

<p>Now if we write a test where we have an admin user and log in, we can verify that we end up at the correct dashboard:</p>

<p><code class="highlighter-rouge">spec/features/admin/login_spec.rb</code></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s2">"rails_helper"</span>

<span class="n">describe</span> <span class="s2">"Admin login"</span> <span class="k">do</span>
  <span class="n">describe</span> <span class="s2">"happy path"</span> <span class="k">do</span>
    <span class="n">it</span> <span class="s2">"I can log in as an admin and get to my dashboard"</span> <span class="k">do</span>
	    <span class="n">admin</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">email: </span><span class="s2">"superuser@awesome-site.com"</span><span class="p">,</span>
                        <span class="ss">password: </span><span class="s2">"super_secret_passw0rd"</span><span class="p">,</span>
                        <span class="ss">role: </span><span class="mi">1</span><span class="p">)</span>

      <span class="n">visit</span> <span class="n">login_path</span>
      <span class="n">fill_in</span> <span class="ss">:email</span><span class="p">,</span> <span class="n">with</span> <span class="n">admin</span><span class="p">.</span><span class="nf">email</span>
      <span class="n">fill_in</span> <span class="ss">:password</span><span class="p">,</span> <span class="n">with</span> <span class="n">admin</span><span class="p">.</span><span class="nf">password</span>
      <span class="n">click_button</span> <span class="s1">'log in'</span>

      <span class="n">expect</span><span class="p">(</span><span class="n">current_path</span><span class="p">).</span><span class="nf">to</span> <span class="n">eq</span><span class="p">(</span><span class="n">admin_dashboard_path</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Next, we need to make sure that regular users can‚Äôt access any of our ‚Äòadmin‚Äô paths.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">describe</span> <span class="s2">"as default user"</span> <span class="k">do</span>
    <span class="n">it</span> <span class="s1">'does not allow default user to see admin dashboard index'</span> <span class="k">do</span>
      <span class="n">user</span> <span class="o">=</span> <span class="no">User</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">username: </span><span class="s2">"fern@gully.com"</span><span class="p">,</span>
                         <span class="ss">password: </span><span class="s2">"password"</span><span class="p">,</span>
                         <span class="ss">role: </span><span class="mi">0</span><span class="p">)</span>

      <span class="n">allow_any_instance_of</span><span class="p">(</span><span class="no">ApplicationController</span><span class="p">).</span><span class="nf">to</span> <span class="n">receive</span><span class="p">(</span><span class="ss">:current_user</span><span class="p">).</span><span class="nf">and_return</span><span class="p">(</span><span class="n">user</span><span class="p">)</span>

      <span class="n">visit</span> <span class="s2">"/admin/dashboard"</span>

      <span class="n">expect</span><span class="p">(</span><span class="n">page</span><span class="p">).</span><span class="nf">to</span> <span class="n">have_content</span><span class="p">(</span><span class="s2">"The page you were looking for doesn't exist."</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>In our Admin Dashboard controller, we need to use a ‚Äúfilter‚Äù to make sure that before we run any ‚Äúaction method‚Äù (ie index, create, etc) that we check that a user is an admin user:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Admin::DashboardController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="n">before_action</span> <span class="ss">:require_admin</span>

  <span class="k">def</span> <span class="nf">index</span>
  <span class="k">end</span>

  <span class="kp">private</span>
    <span class="k">def</span> <span class="nf">require_admin</span>
      <span class="n">render</span> <span class="ss">file: </span><span class="s2">"/public/404"</span> <span class="k">unless</span> <span class="n">current_admin?</span>
    <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="wait-what-is-current_admin">Wait, what is <code class="highlighter-rouge">current_admin?</code></h2>

<p>We can make another helper method in our primary application_controller:</p>

<p><code class="highlighter-rouge">/app/controllers/application_controller.rb</code>:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">current_admin?</span>
  <span class="n">current_user</span> <span class="o">&amp;&amp;</span> <span class="n">current_user</span><span class="p">.</span><span class="nf">admin?</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This will re-use our <code class="highlighter-rouge">current_user</code> method, and, if that passes, will check the <code class="highlighter-rouge">admin?</code> helper from our <code class="highlighter-rouge">enum</code> to make sure the user is also an admin user.</p>

<p>But having to build this <code class="highlighter-rouge">before_action</code> into each admin controller is going to be a nuisance, so we can make this reusable by making an equivalent ‚Äúapplication controller‚Äù for our admin namespace. Typically you‚Äôll see this called a ‚Äúbase controller‚Äù, like this:</p>

<p><code class="highlighter-rouge">/app/controllers/application_controller.rb</code></p>
<ul>
  <li>defines <code class="highlighter-rouge">current_user</code>, <code class="highlighter-rouge">current_admin?</code> etc</li>
</ul>

<p><code class="highlighter-rouge">/app/controllers/admin/base_controller.rb</code></p>
<ul>
  <li>inherits application_controller</li>
  <li>uses our <code class="highlighter-rouge">before_action</code> and defines <code class="highlighter-rouge">require_admin</code></li>
</ul>

<p><code class="highlighter-rouge">/app/controllers/admin/dashboard_controller.rb</code></p>
<ul>
  <li>inherits our new <code class="highlighter-rouge">admin/base_controller.rb</code></li>
</ul>

<h2 id="wrap-up">Wrap-Up</h2>

<ul>
  <li>what are the main differences between authentication and authorization?</li>
  <li>how can we use both to secure our application?</li>
  <li>what does <code class="highlighter-rouge">before_action</code> do?</li>
  <li>what are good/bad things about using an <code class="highlighter-rouge">enum</code> for our role?</li>
  <li>what does <code class="highlighter-rouge">allow_any_instance_of</code> do?</li>
</ul>

:ET