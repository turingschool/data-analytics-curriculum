I"3ó<h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>Understand what an aggregate function does</li>
  <li>Understand what the group SQL statement does</li>
  <li>Understand how the group statement relates to aggregate functions</li>
  <li>Write aggregate/group queries in SQL</li>
  <li>Write aggregate/group queries in ActiveRecord</li>
  <li>Write aggregate/group/joins queries in ActiveRecord</li>
</ul>

<h2 id="vocabulary">Vocabulary</h2>

<ul>
  <li>SQL Group</li>
  <li>SQL Aggregate Function</li>
  <li>ActiveRecord Calculation</li>
</ul>

<h2 id="recording">Recording</h2>

<p><a href="https://youtu.be/shUhwkiT2Jg">This recording</a> will cover the conceptual parts of the lesson, plus some bloopers at the beginning üòÅ</p>

<h2 id="aggregate-functions">Aggregate Functions</h2>

<p>PostgresSQL comes with some handy built-in aggregate functions. From the <a href="https://www.postgresql.org/docs/9.5/functions-aggregate.html">Postgresql Docs</a>: <code class="highlighter-rouge">Aggregate functions compute a single result from a set of input values</code>. Basically, aggregate functions will do some math for us.</p>

<p>Take a minute to look through the <a href="https://www.postgresql.org/docs/9.5/functions-aggregate.html">docs</a> and see what the DB can do for you.</p>

<p>While we are talking about functions built in to Postgresql, it is important to note that nearly all relational database systems include some form of aggregating, for example <a href="https://dev.mysql.com/doc/refman/8.0/en/group-by-functions.html">MySQL</a>.</p>

<h3 id="sql-aggregates">SQL Aggregates</h3>

<p>Let‚Äôs run <code class="highlighter-rouge">rails dbconsole</code> in SetList to open up a connection to our Postgres Database. Let‚Äôs find the average length of all songs:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="k">avg</span><span class="p">(</span><span class="k">length</span><span class="p">)</span> <span class="k">from</span> <span class="n">songs</span><span class="p">;</span>
</code></pre></div></div>

<p>As with all our SQl queries, this is returning a new table. It has one row and one column, the average length of the songs.</p>

<p>We could also get a count of all our songs:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="n">songs</span><span class="p">;</span>
</code></pre></div></div>

<p>get the sum of all play_counts:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="k">sum</span><span class="p">(</span><span class="n">play_count</span><span class="p">)</span> <span class="k">from</span> <span class="n">songs</span><span class="p">;</span>
</code></pre></div></div>

<p>and find the longest length:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="k">max</span><span class="p">(</span><span class="k">length</span><span class="p">)</span> <span class="k">from</span> <span class="n">songs</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="activerecord-calculations">ActiveRecord Calculations</h3>

<p>ActiveRecord gives us corresponding ‚Äúcalculations‚Äù for those aggregate functions. Take a minute to look through the <a href="https://api.rubyonrails.org/classes/ActiveRecord/Calculations.html">ActiveRecord Calculations Docs</a> to see what calculations are available.</p>

<p>Let‚Äôs open up a Rails console and look at the ActiveRecord syntax for the above examples:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Song</span><span class="p">.</span><span class="nf">average</span><span class="p">(</span><span class="ss">:length</span><span class="p">)</span>
<span class="c1">#=&gt; 0.14955e4</span>

<span class="no">Song</span><span class="p">.</span><span class="nf">count</span>
<span class="c1">#=&gt; 4</span>

<span class="no">Song</span><span class="p">.</span><span class="nf">sum</span><span class="p">(</span><span class="ss">:play_count</span><span class="p">)</span>
<span class="c1">#=&gt; 8172627</span>

<span class="no">Song</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="ss">:length</span><span class="p">)</span>
<span class="c1">#=&gt; 4378</span>
</code></pre></div></div>

<p>Unlike some of the ActiveRecord methods we‚Äôve seen so far, the order that you put the calculations does matter. For instance, if you only want to count songs with at least 10 plays:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Song</span><span class="p">.</span><span class="nf">count</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"play_count &gt; 10"</span><span class="p">)</span>
</code></pre></div></div>

<p>You will get this error:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NoMethodError: undefined method `where' for 4:Integer
</code></pre></div></div>

<p>Once ActiveRecord sees a calculation method, it performs the calculation and returns it. In this case, ActiveRecord does <code class="highlighter-rouge">Song.count</code>, returning an integer. It then throws an error when we try to call <code class="highlighter-rouge">.where</code> on that integer.</p>

<p>This is the same behavior we have seen with <code class="highlighter-rouge">.pluck</code>. In fact, if you look at the Calculation Docs, you‚Äôll see that <code class="highlighter-rouge">pluck</code> is a calculation.</p>

<h2 id="grouping">Grouping</h2>

<p>A sql <code class="highlighter-rouge">group by</code> statement will take the rows that you‚Äôve selected using <code class="highlighter-rouge">select</code>, <code class="highlighter-rouge">from</code>, and <code class="highlighter-rouge">where</code> and group them together based on a common attribute. It will then condense these rows together, usually through a calculation. Let‚Äôs look at an example. Starting with this table:</p>

<p><strong>Songs Table</strong></p>

<table>
  <thead>
    <tr>
      <th>id</th>
      <th>title</th>
      <th>length</th>
      <th>play_count</th>
      <th>artist_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>This Must Be the Place</td>
      <td>345</td>
      <td>23</td>
      <td>1</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Heaven</td>
      <td>432</td>
      <td>12</td>
      <td>1</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Don‚Äôt Stop Believin‚Äô</td>
      <td>367</td>
      <td>45</td>
      <td>2</td>
    </tr>
    <tr>
      <td>4</td>
      <td>Chicken Fried</td>
      <td>183</td>
      <td>49</td>
      <td>3</td>
    </tr>
  </tbody>
</table>

<p>In our pqsl session, run:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="n">artist_id</span> <span class="k">from</span> <span class="n">songs</span> <span class="k">group</span> <span class="k">by</span> <span class="n">artist_id</span><span class="p">;</span>
</code></pre></div></div>

<p>This will return this table:</p>

<table>
  <thead>
    <tr>
      <th>artist_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
    </tr>
    <tr>
      <td>2</td>
    </tr>
    <tr>
      <td>3</td>
    </tr>
  </tbody>
</table>

<p>This is not very interesting information, but we can use this example to understand what the <code class="highlighter-rouge">group by</code> clause is doing. First, SQl is going to perform the <code class="highlighter-rouge">select</code>/<code class="highlighter-rouge">from</code>, which will give us this table:</p>

<table>
  <thead>
    <tr>
      <th>artist_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
    </tr>
    <tr>
      <td>1</td>
    </tr>
    <tr>
      <td>2</td>
    </tr>
    <tr>
      <td>3</td>
    </tr>
  </tbody>
</table>

<p>Then, <code class="highlighter-rouge">group by</code> will group these rows by the <code class="highlighter-rouge">artist_id</code>:</p>

<p><strong>group with artist_id = 1</strong></p>

<table>
  <thead>
    <tr>
      <th>artist_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
    </tr>
    <tr>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p><strong>group with artist_id = 2</strong></p>

<table>
  <thead>
    <tr>
      <th>artist_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2</td>
    </tr>
  </tbody>
</table>

<p><strong>group with artist_id = 3</strong></p>

<table>
  <thead>
    <tr>
      <th>artist_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>3</td>
    </tr>
  </tbody>
</table>

<p>Then, for each of these groups, sql will condense the rows.</p>

<p><strong>group with artist_id = 1</strong></p>

<table>
  <thead>
    <tr>
      <th>artist_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p><strong>group with artist_id = 2</strong></p>

<table>
  <thead>
    <tr>
      <th>artist_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>2</td>
    </tr>
  </tbody>
</table>

<p><strong>group with artist_id = 3</strong></p>

<table>
  <thead>
    <tr>
      <th>artist_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>3</td>
    </tr>
  </tbody>
</table>

<p>And finally put all these groups back together:</p>

<p><strong>result table</strong></p>

<table>
  <thead>
    <tr>
      <th>artist_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
    </tr>
    <tr>
      <td>2</td>
    </tr>
    <tr>
      <td>3</td>
    </tr>
  </tbody>
</table>

<p>This query is functionally the same as <code class="highlighter-rouge">select distinct artist_id from songs;</code>.</p>

<p>Let‚Äôs now look at an example that doesn‚Äôt work. Instead of selecting the artist_id, we‚Äôll try to select the song title:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="n">title</span> <span class="k">from</span> <span class="n">songs</span> <span class="k">group</span> <span class="k">by</span> <span class="n">artist_id</span><span class="p">;</span>
</code></pre></div></div>

<p>This query will give us this error:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ERROR:  column "songs.title" must appear in the GROUP BY clause or be used in an aggregate function
</code></pre></div></div>

<p>Let‚Äôs break this query down in the same way to see why this isn‚Äôt working:</p>

<p>First, we do our <code class="highlighter-rouge">select</code>/<code class="highlighter-rouge">from</code>:</p>

<table>
  <thead>
    <tr>
      <th>title</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>This Must Be the Place</td>
    </tr>
    <tr>
      <td>Heaven</td>
    </tr>
    <tr>
      <td>Don‚Äôt Stop Believin‚Äô</td>
    </tr>
    <tr>
      <td>Chicken Fried</td>
    </tr>
  </tbody>
</table>

<p>Next, sql is going to group the rows, but since the <code class="highlighter-rouge">artist_id</code> is not part of of this table, we can‚Äôt group on it, and so we get our error. <strong>We can only group on attributes that are part of the select statement</strong>.</p>

<p>Let‚Äôs instead try to include the <code class="highlighter-rouge">artist_id</code> in the select statement:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="n">title</span><span class="p">,</span> <span class="n">artist_id</span> <span class="k">from</span> <span class="n">songs</span> <span class="k">group</span> <span class="k">by</span> <span class="n">artist_id</span><span class="p">;</span>
</code></pre></div></div>

<p>And we‚Äôll get the same error. Let‚Äôs break this one down. First, our <code class="highlighter-rouge">select</code>/<code class="highlighter-rouge">from</code>:</p>

<table>
  <thead>
    <tr>
      <th>title</th>
      <th>artist_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>This Must Be the Place</td>
      <td>1</td>
    </tr>
    <tr>
      <td>Heaven</td>
      <td>1</td>
    </tr>
    <tr>
      <td>Don‚Äôt Stop Believin‚Äô</td>
      <td>2</td>
    </tr>
    <tr>
      <td>Chicken Fried</td>
      <td>3</td>
    </tr>
  </tbody>
</table>

<p>Next, sql tries to group the rows. We have the <code class="highlighter-rouge">artist_id</code> so we can do this:</p>

<p><strong>groups with artist_id = 1</strong></p>

<table>
  <thead>
    <tr>
      <th>title</th>
      <th>artist_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>This Must Be the Place</td>
      <td>1</td>
    </tr>
    <tr>
      <td>Heaven</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p><strong>groups with artist_id = 2</strong></p>

<table>
  <thead>
    <tr>
      <th>title</th>
      <th>artist_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Don‚Äôt Stop Believin‚Äô</td>
      <td>2</td>
    </tr>
  </tbody>
</table>

<p><strong>groups with artist_id = 3</strong></p>

<table>
  <thead>
    <tr>
      <th>title</th>
      <th>artist_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Chicken Fried</td>
      <td>3</td>
    </tr>
  </tbody>
</table>

<p>Then, we try to condense the rows, but how do we condense them? If we look at the first group, there are two different titles, and sql doesn‚Äôt know what to do with them. The information is conflicting. In most cases, we are going to use aggregate functions to condense rows.</p>

<h2 id="grouping-and-aggregating">Grouping and Aggregating</h2>

<p>Whenever we have a <code class="highlighter-rouge">group by</code> statement, we are going to need an aggregate function in our select statement to tell sql how we want to condense the rows. For example, we can get an average length of songs for each artist id:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="n">artist_id</span><span class="p">,</span> <span class="k">avg</span><span class="p">(</span><span class="k">length</span><span class="p">)</span> <span class="k">from</span> <span class="n">songs</span> <span class="k">group</span> <span class="k">by</span> <span class="n">artist_id</span><span class="p">;</span>
</code></pre></div></div>

<p>This will return:</p>

<table>
  <tbody>
    <tr>
      <td>artist_id</td>
      <td>avg</td>
    </tr>
    <tr>
      <td>1</td>
      <td>388.5</td>
    </tr>
    <tr>
      <td>2</td>
      <td>367.0</td>
    </tr>
    <tr>
      <td>3</td>
      <td>183.0</td>
    </tr>
  </tbody>
</table>

<p>Let‚Äôs break this query down. First, we do our <code class="highlighter-rouge">select</code> statement, which includes the <code class="highlighter-rouge">artist_id</code> and the <code class="highlighter-rouge">length</code> from songs (we are ignoring the <code class="highlighter-rouge">avg</code> for the moment):</p>

<table>
  <tbody>
    <tr>
      <td>artist_id</td>
      <td>length</td>
    </tr>
    <tr>
      <td>1</td>
      <td>345</td>
    </tr>
    <tr>
      <td>1</td>
      <td>432</td>
    </tr>
    <tr>
      <td>2</td>
      <td>367</td>
    </tr>
    <tr>
      <td>3</td>
      <td>183</td>
    </tr>
  </tbody>
</table>

<p>Then, sql will group on the <code class="highlighter-rouge">artist_id</code></p>

<p><strong>artist_id = 1</strong></p>

<table>
  <tbody>
    <tr>
      <td>artist_id</td>
      <td>length</td>
    </tr>
    <tr>
      <td>1</td>
      <td>345</td>
    </tr>
    <tr>
      <td>1</td>
      <td>432</td>
    </tr>
  </tbody>
</table>

<p><strong>artist_id = 2</strong></p>

<table>
  <tbody>
    <tr>
      <td>artist_id</td>
      <td>length</td>
    </tr>
    <tr>
      <td>2</td>
      <td>367</td>
    </tr>
  </tbody>
</table>

<p><strong>artist_id = 3</strong></p>

<table>
  <tbody>
    <tr>
      <td>artist_id</td>
      <td>length</td>
    </tr>
    <tr>
      <td>3</td>
      <td>183</td>
    </tr>
  </tbody>
</table>

<p>Now sql will try to condense the rows. Like the last example, there is conflicting information (the lengths are different), but this time we have used the <code class="highlighter-rouge">avg</code> aggregate function to tell sql how we want to condense that information into a single value:</p>

<p><strong>artist_id = 1</strong></p>

<table>
  <tbody>
    <tr>
      <td>artist_id</td>
      <td>avg</td>
    </tr>
    <tr>
      <td>1</td>
      <td>388.5</td>
    </tr>
  </tbody>
</table>

<p><strong>artist_id = 2</strong></p>

<table>
  <tbody>
    <tr>
      <td>artist_id</td>
      <td>avg</td>
    </tr>
    <tr>
      <td>2</td>
      <td>367.0</td>
    </tr>
  </tbody>
</table>

<p><strong>artist_id = 3</strong></p>

<table>
  <tbody>
    <tr>
      <td>artist_id</td>
      <td>avg</td>
    </tr>
    <tr>
      <td>3</td>
      <td>183.0</td>
    </tr>
  </tbody>
</table>

<p>Finally, sql will put the groups back together:</p>

<p><strong>result table</strong></p>

<table>
  <tbody>
    <tr>
      <td>artist_id</td>
      <td>avg</td>
    </tr>
    <tr>
      <td>1</td>
      <td>388.5</td>
    </tr>
    <tr>
      <td>2</td>
      <td>367.0</td>
    </tr>
    <tr>
      <td>3</td>
      <td>183.0</td>
    </tr>
  </tbody>
</table>

<p>What if we wanted to count the number of songs for each artist?</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="n">artist_id</span><span class="p">,</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">from</span> <span class="n">songs</span> <span class="k">group</span> <span class="k">by</span> <span class="n">artist_id</span><span class="p">;</span>
</code></pre></div></div>

<p>Let‚Äôs follow our process again. First, the <code class="highlighter-rouge">select</code> statement. In this case, our <code class="highlighter-rouge">select</code> includes a <code class="highlighter-rouge">*</code>, which means everything:</p>

<table>
  <thead>
    <tr>
      <th>artist_id</th>
      <th>id</th>
      <th>title</th>
      <th>length</th>
      <th>play_count</th>
      <th>artist_id</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>This Must Be the Place</td>
      <td>345</td>
      <td>23</td>
      <td>1</td>
    </tr>
    <tr>
      <td>1</td>
      <td>2</td>
      <td>Heaven</td>
      <td>432</td>
      <td>12</td>
      <td>1</td>
    </tr>
    <tr>
      <td>2</td>
      <td>3</td>
      <td>Don‚Äôt Stop Believin‚Äô</td>
      <td>367</td>
      <td>45</td>
      <td>2</td>
    </tr>
    <tr>
      <td>3</td>
      <td>4</td>
      <td>Chicken Fried</td>
      <td>183</td>
      <td>49</td>
      <td>3</td>
    </tr>
  </tbody>
</table>

<p>Notice how we selected the <code class="highlighter-rouge">artist_id</code> twice. Then, we group on the <code class="highlighter-rouge">artist_id</code>:</p>

<p><strong>artist_id = 1</strong></p>

<table>
  <tbody>
    <tr>
      <td>artist_id</td>
      <td>id</td>
      <td>title</td>
      <td>length</td>
      <td>play_count</td>
      <td>artist_id</td>
    </tr>
    <tr>
      <td>1</td>
      <td>1</td>
      <td>This Must Be the Place</td>
      <td>345</td>
      <td>23</td>
      <td>1</td>
    </tr>
    <tr>
      <td>1</td>
      <td>2</td>
      <td>Heaven</td>
      <td>432</td>
      <td>12</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p><strong>artist_id = 2</strong></p>

<table>
  <tbody>
    <tr>
      <td>artist_id</td>
      <td>id</td>
      <td>title</td>
      <td>length</td>
      <td>play_count</td>
      <td>artist_id</td>
    </tr>
    <tr>
      <td>2</td>
      <td>3</td>
      <td>Don‚Äôt Stop Believin‚Äô</td>
      <td>367</td>
      <td>45</td>
      <td>2</td>
    </tr>
  </tbody>
</table>

<p><strong>artist_id = 3</strong></p>

<table>
  <tbody>
    <tr>
      <td>artist_id</td>
      <td>id</td>
      <td>title</td>
      <td>length</td>
      <td>play_count</td>
      <td>artist_id</td>
    </tr>
    <tr>
      <td>3</td>
      <td>4</td>
      <td>Chicken Fried</td>
      <td>183</td>
      <td>49</td>
      <td>3</td>
    </tr>
  </tbody>
</table>

<p>In this case, there is a lot of conflicting information in our groups, but count knows how to condense them. Just count the rows:</p>

<p><strong>artist_id = 1</strong></p>

<table>
  <tbody>
    <tr>
      <td>artist_id</td>
      <td>count</td>
    </tr>
    <tr>
      <td>1</td>
      <td>2</td>
    </tr>
  </tbody>
</table>

<p><strong>artist_id = 2</strong></p>

<table>
  <tbody>
    <tr>
      <td>artist_id</td>
      <td>count</td>
    </tr>
    <tr>
      <td>2</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p><strong>artist_id = 3</strong></p>

<table>
  <tbody>
    <tr>
      <td>artist_id</td>
      <td>count</td>
    </tr>
    <tr>
      <td>3</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>Finally, put the groups back together:</p>

<table>
  <tbody>
    <tr>
      <td>artist_id</td>
      <td>count</td>
    </tr>
    <tr>
      <td>1</td>
      <td>2</td>
    </tr>
    <tr>
      <td>2</td>
      <td>1</td>
    </tr>
    <tr>
      <td>3</td>
      <td>1</td>
    </tr>
  </tbody>
</table>

<p>If we don‚Äôt want our column to be labeled <code class="highlighter-rouge">count</code>, we can use an <strong>alias</strong>:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="n">artist_id</span><span class="p">,</span> <span class="k">count</span><span class="p">(</span><span class="o">*</span><span class="p">)</span> <span class="k">as</span> <span class="nv">"count of songs"</span> <span class="k">from</span> <span class="n">songs</span> <span class="k">group</span> <span class="k">by</span> <span class="n">artist_id</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="grouping-and-aggregating-in-activerecord">Grouping and Aggregating in ActiveRecord</h2>

<p>Once you have a mental model for how you want to interact with your tables, you can translate the sql into the corresponding AR syntax. For example, getting a count of songs for each artist:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Song</span><span class="p">.</span><span class="nf">group</span><span class="p">(</span><span class="ss">:artist_id</span><span class="p">).</span><span class="nf">count</span>
<span class="c1">#=&gt; {1=&gt;2, 2=&gt;1, 3=&gt;1}</span>
</code></pre></div></div>

<p>This returns a hash where the keys are the <code class="highlighter-rouge">artist_id</code> and the values are the counts of songs.</p>

<p>If we wanted to get the average length of songs for each artist:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Song</span><span class="p">.</span><span class="nf">group</span><span class="p">(</span><span class="ss">:artist_id</span><span class="p">).</span><span class="nf">average</span><span class="p">(</span><span class="ss">:length</span><span class="p">)</span>
<span class="c1">#=&gt; {3=&gt;0.4378e4, 1=&gt;0.753e3, 2=&gt;0.98e2}</span>
</code></pre></div></div>

<p>As we mentioned before, as soon as ActiveRecord sees a calculation method, it returns the calculation immediately, so if you do something like:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Song</span><span class="p">.</span><span class="nf">average</span><span class="p">(</span><span class="ss">:length</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="ss">:artist_id</span><span class="p">)</span>
</code></pre></div></div>

<p>You will get:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>NoMethodError: undefined method `group' for 0.33175e3:BigDecimal
</code></pre></div></div>

<h2 id="joining-grouping-and-aggregating">Joining, Grouping, and Aggregating</h2>

<p>If you use <code class="highlighter-rouge">group</code> with a calculation method, it will always return a hash with the grouped data and the calculation, but what if we want more than just the raw data? For instance, what if we wanted Artist objects sorted by their average length of song?</p>

<p>Any time we need information from two or more tables, we are going to need to <strong>join</strong> those tables. In this case, the Artist info is stored in the <code class="highlighter-rouge">artists</code> table and the Song lengths are stored in the <code class="highlighter-rouge">songs</code> table:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Artist</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:songs</span><span class="p">)</span>
</code></pre></div></div>

<p>That joined table will look like:</p>

<table>
  <tbody>
    <tr>
      <td>id</td>
      <td>name</td>
      <td>id</td>
      <td>title</td>
      <td>length</td>
      <td>play_count</td>
      <td>artist_id</td>
    </tr>
    <tr>
      <td>1</td>
      <td>Talking Heads</td>
      <td>1</td>
      <td>This Must Be the Place</td>
      <td>345</td>
      <td>23</td>
      <td>1</td>
    </tr>
    <tr>
      <td>1</td>
      <td>Talking Heads</td>
      <td>2</td>
      <td>Heaven</td>
      <td>432</td>
      <td>12</td>
      <td>1</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Journey</td>
      <td>3</td>
      <td>Don‚Äôt Stop Believin‚Äô</td>
      <td>367</td>
      <td>45</td>
      <td>2</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Zac Brown Band</td>
      <td>4</td>
      <td>Chicken Fried</td>
      <td>183</td>
      <td>49</td>
      <td>3</td>
    </tr>
  </tbody>
</table>

<p>In order to average the song lengths for each artist, we will need to group by the artist‚Äôs id:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Artist</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:songs</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="ss">:id</span><span class="p">).</span><span class="nf">average</span><span class="p">(</span><span class="ss">:length</span><span class="p">)</span>
</code></pre></div></div>

<p>Notice how there are two columns called <code class="highlighter-rouge">id</code> in this joined table. ActiveRecord will pick the first one, which in this case is the Artist id.</p>

<p>If you run this query, you‚Äôll notice that it‚Äôs still returning us a hash. If we want to get our Artist objects, we need to include  a <code class="highlighter-rouge">select</code> statement with the aggregate <code class="highlighter-rouge">avg</code> rather than using the ActiveRecord <code class="highlighter-rouge">average</code> method. This is an example of why it‚Äôs important to know SQL when writing ActiveRecord queries:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Artist</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"artists.*, avg(length)"</span><span class="p">).</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:songs</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
</code></pre></div></div>

<p>Let‚Äôs visualize what this is doing. First, we take the joined table, select the all the Artist columns (id and name) and the length column from Songs:</p>

<table>
  <tbody>
    <tr>
      <td>id</td>
      <td>name</td>
      <td>length</td>
    </tr>
    <tr>
      <td>1</td>
      <td>Talking Heads</td>
      <td>345</td>
    </tr>
    <tr>
      <td>1</td>
      <td>Talking Heads</td>
      <td>432</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Journey</td>
      <td>367</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Zac Brown Band</td>
      <td>183</td>
    </tr>
  </tbody>
</table>

<p>Group them by the id:</p>

<p><strong>id = 1</strong></p>

<table>
  <tbody>
    <tr>
      <td>id</td>
      <td>name</td>
      <td>length</td>
    </tr>
    <tr>
      <td>1</td>
      <td>Talking Heads</td>
      <td>345</td>
    </tr>
    <tr>
      <td>1</td>
      <td>Talking Heads</td>
      <td>432</td>
    </tr>
  </tbody>
</table>

<p><strong>id = 2</strong></p>

<table>
  <tbody>
    <tr>
      <td>id</td>
      <td>name</td>
      <td>length</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Journey</td>
      <td>367</td>
    </tr>
  </tbody>
</table>

<p><strong>id = 3</strong></p>

<table>
  <tbody>
    <tr>
      <td>id</td>
      <td>name</td>
      <td>length</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Zac Brown Band</td>
      <td>183</td>
    </tr>
  </tbody>
</table>

<p>And condense the rows by averaging the length:</p>

<p><strong>id = 1</strong></p>

<table>
  <tbody>
    <tr>
      <td>id</td>
      <td>name</td>
      <td>average_song_length</td>
    </tr>
    <tr>
      <td>1</td>
      <td>Talking Heads</td>
      <td>388.5</td>
    </tr>
  </tbody>
</table>

<p><strong>id = 2</strong></p>

<table>
  <tbody>
    <tr>
      <td>id</td>
      <td>name</td>
      <td>average_song_length</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Journey</td>
      <td>367.0</td>
    </tr>
  </tbody>
</table>

<p><strong>id = 3</strong></p>

<table>
  <tbody>
    <tr>
      <td>id</td>
      <td>name</td>
      <td>average_song_length</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Zac Brown Band</td>
      <td>183.0</td>
    </tr>
  </tbody>
</table>

<p>And finally, put all the groups back together:</p>

<table>
  <tbody>
    <tr>
      <td>id</td>
      <td>name</td>
      <td>average_song_length</td>
    </tr>
    <tr>
      <td>1</td>
      <td>Talking Heads</td>
      <td>388.5</td>
    </tr>
    <tr>
      <td>2</td>
      <td>Journey</td>
      <td>367.0</td>
    </tr>
    <tr>
      <td>3</td>
      <td>Zac Brown Band</td>
      <td>183.0</td>
    </tr>
  </tbody>
</table>

<p>If you run this query in the Rails console, You‚Äôll get this return value:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#&lt;ActiveRecord::Relation [#&lt;Artist id: 1, name: "Talking Heads", created_at: "2019-05-08 23:49:09", updated_at: "2019-05-08 23:49:09"&gt;, #&lt;Artist id: 2, name: "Journey", created_at: "2019-05-08 23:49:09", updated_at: "2019-05-08 23:49:09"&gt;, #&lt;Artist id: 3, name: "Zac Brown Band", created_at: "2019-05-08 23:49:09", updated_at: "2019-05-08 23:49:09"&gt;]&gt;
</code></pre></div></div>

<p>We can see our Artists in this ActiveRecord::Relation, but where is our average song length? It‚Äôs there, we just can‚Äôt see it:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">artists</span> <span class="o">=</span> <span class="no">Artist</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:songs</span><span class="p">).</span><span class="nf">select</span><span class="p">(</span><span class="s2">"artists.*, avg(length)"</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
<span class="n">artists</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">average_song_length</span>
<span class="c1">#=&gt; 0.753e3</span>
</code></pre></div></div>

<p>ActiveRecord is creating a new attribute for our returned Artists objects called <code class="highlighter-rouge">average_song_length</code>. This is a default name. We can change it with an alias:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">artists</span> <span class="o">=</span> <span class="no">Artist</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:songs</span><span class="p">).</span><span class="nf">select</span><span class="p">(</span><span class="s2">"artists.*, avg(length) as avg_length"</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
<span class="n">artists</span><span class="p">.</span><span class="nf">first</span><span class="p">.</span><span class="nf">avg_length</span>
<span class="c1">#=&gt; 0.753e3</span>
</code></pre></div></div>

<p>It‚Äôs important to note that this is not a new attribute for the Artist records in our database. This is a temporary attribute that is created for the objects returned from our query.</p>

<p>Now that we have our average song length for each Artist, we can sort this list:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">artists</span> <span class="o">=</span> <span class="no">Artist</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:songs</span><span class="p">).</span><span class="nf">select</span><span class="p">(</span><span class="s2">"artists.*, avg(length) as avg_length"</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="ss">:id</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="s2">"avg_length"</span><span class="p">)</span>
</code></pre></div></div>

<p>One ActiveRecord quirk you may run into is if you try to use a symbol rather than a string:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">artists</span> <span class="o">=</span> <span class="no">Artist</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:songs</span><span class="p">).</span><span class="nf">select</span><span class="p">(</span><span class="s2">"artists.*, avg(length) as avg_length"</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="ss">:id</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="ss">:avg_length</span><span class="p">)</span>
</code></pre></div></div>

<p>Will produce:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ActiveRecord::StatementInvalid: PG::UndefinedColumn: ERROR:  column artists.avg_length does not exist
</code></pre></div></div>

<p>Whenever you use symbol notation, ActiveRecord assumes that you are referring to a colum of the table that corresponds to the Model you started the query with (in this case <code class="highlighter-rouge">Artist</code> relates to the <code class="highlighter-rouge">artists</code> table). We need to use string notation to tell ActiveRecord to insert the string <code class="highlighter-rouge">"avg_length"</code> as-is into our group statement, rather than look for an attribute on our model.</p>

<p>You may also think to group on the <code class="highlighter-rouge">artist_id</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Artist</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:songs</span><span class="p">).</span><span class="nf">select</span><span class="p">(</span><span class="s2">"artists.*, avg(length) as avg_length"</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="ss">:artist_id</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="s2">"avg_length"</span><span class="p">)</span>
</code></pre></div></div>

<p>This will produce:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ActiveRecord::StatementInvalid: PG::GroupingError: ERROR:  column "artists.id" must appear in the GROUP BY clause or be used in an aggregate function
</code></pre></div></div>

<p>Remember, we can only group on columns that are part of our <code class="highlighter-rouge">select</code> statement. Since we select <code class="highlighter-rouge">artists.id</code>, <code class="highlighter-rouge">artists.name</code>, and <code class="highlighter-rouge">songs.length</code>, we can‚Äôt group on <code class="highlighter-rouge">artist_id</code> even though the <code class="highlighter-rouge">artist_id</code> is the same as <code class="highlighter-rouge">artists.id</code>.</p>

<h2 id="practice-problems">Practice Problems</h2>

<p>Test your understanding by writing queries for the following in ActiveRecord:</p>

<ol>
  <li>What is the length of the longest song?</li>
  <li>What is the length of each artist‚Äôs longest song?</li>
  <li>What is the name of the artist with the longest song?</li>
  <li>What is the average length of each artists‚Äô songs?</li>
  <li>What is the name of the artist with longest average length of song?</li>
  <li>What are the names of the three artists with the least amount of total plays for all of their songs?</li>
</ol>

<p><strong>Extra Spicy Problem</strong></p>

<ol>
  <li>Write a query to return each artist‚Äôs name and a comma separated list of all their songs, for example ‚ÄúTalking Heads‚Äù would have ‚ÄúThis must be the Place, Heaven‚Äù</li>
</ol>

<h2 id="checks-for-understanding">Checks for Understanding</h2>

<ul>
  <li>What are aggregate functions? Where do they appear in SQL statements?</li>
  <li>What do calculation methods in AR return?</li>
  <li>What does the <code class="highlighter-rouge">group by</code> statement do in sql?</li>
  <li>Why do we need to include an aggregate function when using <code class="highlighter-rouge">group by</code>?</li>
  <li>When do we need to join?</li>
</ul>
:ET