I"FN<p><strong>Discussion – Integration Testing</strong></p>

<ul>
  <li><code class="highlighter-rouge">Rack::Test</code> – advantages and disadvantages</li>
  <li>“Integration” testing – what’s the point?</li>
  <li>How are our existing integration tests not really…integrative?</li>
  <li>As our apps include JS it would be good to be able to test that the JS
portions and the server portions work correctly together.</li>
  <li>Capybara Architecture: Modular with respect to drivers</li>
  <li>Alternate drivers: Selenium, Poltergiest, Webkit, etc. – give us a real web browser in our tests. We can actually run JS!</li>
</ul>

<h2 id="getting-started-with-selenium">Getting Started With Selenium</h2>

<h4 id="want-to-test-your-dom-but-you-have-some-javascript-dynamically-manipulating-the-dom-or-some-ajax-calls-enter-selenium">Want to test your DOM but you have some JavaScript dynamically manipulating the DOM, or some AJAX calls? Enter Selenium.</h4>

<h4 id="what-is-selenium">What is Selenium?</h4>

<p>This lesson is all about learning to use Selenium WebDriver. WebDriver is a tool that will allow you to run tests on features that use JavaScript to make AJAX calls and dynamic content manipulation in the DOM.</p>

<p>Basically - testing with Selenium allows us to test complex user interactions. We are not limited to basic <code class="highlighter-rouge">fill_in</code> <code class="highlighter-rouge">click</code> follow the request to the next page and see what’s there. Selenium allows us model not just traditional user actions, but more complex ones like interacting with dropdowns, changing windows in the browser, dealing with AJAX calls, navigation handling etc.</p>

<p>Selenium suite is a full scale testing suite that is composed of 4 basic components - Selenium IDE, Selenium RC, WebDriver, Selenium Grid. We will only focus on WebDriver - “a tool for automating web application testing, and in particular to verify that they work as expected. It aims to provide a friendly API that’s easy to explore and understand…” <a href="http://www.seleniumhq.org/docs/03_webdriver.jsp">Here are the WebDriver docs</a> if you want to read more about WebDriver.</p>

<p>Selenium WebDriver fairly platform agnostic. You can use it with any of these languages:</p>

<ul>
  <li>Java</li>
  <li>C#</li>
  <li>PHP</li>
  <li>Python</li>
  <li>Perl</li>
  <li>Ruby</li>
</ul>

<p>We will be using Selenium WebDriver along with Capybara in our Ruby on Rails projects.</p>

<h4 id="first---setup">First - Setup</h4>

<p><strong>Setup</strong></p>

<p>The only machine dependency for using Selenium is to have Firefox 46 installed.
If you don’t have this, then <a href="https://www.softexia.com/windows/web-browsers/firefox-46">go download it.</a> If you do have it, make sure it on version 46. Selenium does not work with all versions of Firefox, so make sure that you are using Firefox 46 or else IT WILL NOT WORK. If you already have firefox and it’s on a version more recent than 46, the easiest way to downgrade is to uninstall firefox then install version 46.</p>

<p><strong>Important Note</strong></p>

<p>When in firefox - make sure it does not automatically update firefox.</p>

<ul>
  <li>Firefox
    <ul>
      <li>preferences</li>
      <li>Advanced</li>
      <li>Update
Then uncheck the automatic updates option.</li>
    </ul>
  </li>
</ul>

<h2 id="app-setup">App Setup</h2>

<p>For this section, we’ll work through a brief demo using the Blogger example
project. In this tutorial, we’ll aim to:</p>

<ul>
  <li>Get selenium set up with our app</li>
  <li>Write integration tests for a new feature using AJAX</li>
  <li>Implement the feature and verify the functionality using Selenium</li>
</ul>

<h3 id="1-clone--setup">1. Clone / Setup</h3>

<p>Get started by cloning and setting up the blogger application:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/turingschool/blogger_advanced.git selenium-workshop
cd selenium-workshop
git checkout starting-selenium-webdriver-tutorial
bundle
rake db:setup
</code></pre></div></div>

<p>Additionally, go ahead and add the Selenium gem to your Gemfile:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem 'selenium-webdriver', '~&gt; 2.53.4'
</code></pre></div></div>

<h3 id="2-using-selenium-for-a-test">2. Using Selenium for a Test</h3>

<p>The feature we’d like to add is an AJAX-based comment submission. Currently users can submit comments by submitting the form from an Article page, but let’s see if we can make this work without a full page reload.</p>

<p>Fortunately, there is already a test written for the content we need – it’s in
<code class="highlighter-rouge">spec/features/article_comments_spec.rb</code>. However so far this is just using the default
(<code class="highlighter-rouge">Rack::Test</code>) capybara driver. Let’s start by swapping it to use Selenium, by
setting the <code class="highlighter-rouge">js</code> flag on the test itself:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># in spec/features/article_comments_spec.rb</span>
<span class="nb">require</span> <span class="s1">'spec_helper'</span>

<span class="c1">## Add the :js =&gt; true option to the test group:</span>
<span class="n">describe</span> <span class="s2">"Article Comments"</span><span class="p">,</span> <span class="ss">:type</span> <span class="o">=&gt;</span> <span class="ss">:feature</span><span class="p">,</span> <span class="ss">:js</span> <span class="o">=&gt;</span> <span class="kp">true</span> <span class="k">do</span>
  <span class="n">let</span><span class="p">(</span><span class="ss">:article</span><span class="p">){</span> <span class="no">Fabricate</span><span class="p">(</span><span class="ss">:article</span><span class="p">)</span> <span class="p">}</span>

  <span class="n">it</span> <span class="s2">"posts a comment"</span> <span class="k">do</span>
    <span class="n">visit</span> <span class="n">article_path</span><span class="p">(</span><span class="n">article</span><span class="p">)</span>
    <span class="n">fill_in</span> <span class="s2">"comment_author_name"</span><span class="p">,</span> <span class="ss">:with</span> <span class="o">=&gt;</span> <span class="s2">"Cowboy"</span>
    <span class="n">fill_in</span> <span class="s2">"comment_body"</span><span class="p">,</span> <span class="ss">:with</span> <span class="o">=&gt;</span> <span class="s2">"Testing is too hard."</span>
    <span class="n">click_link_or_button</span> <span class="s2">"post_comment"</span>
    <span class="n">within</span><span class="p">(</span><span class="s1">'#comments'</span><span class="p">)</span> <span class="k">do</span>
      <span class="n">expect</span><span class="p">(</span><span class="n">page</span><span class="p">).</span><span class="nf">to</span> <span class="n">have_content</span><span class="p">(</span><span class="s2">"Cowboy said"</span><span class="p">)</span>
      <span class="n">expect</span><span class="p">(</span><span class="n">page</span><span class="p">).</span><span class="nf">to</span> <span class="n">have_content</span><span class="p">(</span><span class="s2">"Testing is too hard."</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Once this is in place, run your tests.</p>

<ul>
  <li>A new firefox browser window will open automatically and execute your test.</li>
  <li><strong>If you have issues with your test suit not finding the Article. You may be running into an issue with DB threading. You can solve this by using the feature to create a new article instead of a factory/fabricator</strong>
    <ul>
      <li>If you do need to refactor to create the article with the feature - try to refactor the test using the features RSpec provides. Something like this:</li>
    </ul>
  </li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">before</span><span class="p">(</span><span class="ss">:each</span><span class="p">)</span> <span class="k">do</span>
    <span class="n">visit</span> <span class="n">new_article_path</span>
    <span class="n">fill_in</span> <span class="s2">"article_title"</span><span class="p">,</span> <span class="ss">with: </span><span class="s2">"My Article"</span>
    <span class="n">fill_in</span> <span class="s2">"article_body"</span><span class="p">,</span> <span class="ss">with: </span><span class="s2">"My Article Body"</span>
    <span class="n">click_link_or_button</span> <span class="s2">"Save"</span>
    <span class="n">click_link_or_button</span> <span class="s2">"My Article"</span>
  <span class="k">end</span>
</code></pre></div></div>

<p>Note that the last step of this is taking you to the specific articles show page, so you will not need the <code class="highlighter-rouge">visit article_path(article)</code> as the first line in your test.</p>

<h3 id="4-creating-comments-using-ajax">4. Creating Comments using AJAX</h3>

<p>Now that we have our test running with Selenium, we have a reasonable foundation
to add in our AJAX feature and remain confident that it will still be testing.</p>

<p>For starters, let’s replace our existing <code class="highlighter-rouge">comments.js.coffee</code> file with a normal JS file.
Probably the easiest way to do this is to just remove one and create the other:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rm app/assets/javascripts/comments.js.coffee
touch app/assets/javascripts/comments.js
</code></pre></div></div>

<p>(don’t skip this step, or the empty coffeescript file will overwrite your work in
the new JS file)</p>

<p><strong>New Comment with AJAX</strong></p>

<p>Now let’s change the way we create a new comment for our articles. Let’s use AJAX to submit/create the comment.</p>

<p>For a spicy challenge - go ahead and try to implement this feature without looking at the code below.</p>

<p>Inside of the comment.js file, let’s write a function to gather the information from the comment submission form and submit it via a post request.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">postComment</span><span class="p">()</span> <span class="p">{</span>
      <span class="kd">var</span> <span class="nx">commentData</span> <span class="o">=</span> <span class="p">{</span>
          <span class="na">comment</span><span class="p">:</span> <span class="p">{</span>
              <span class="na">author_name</span><span class="p">:</span> <span class="nx">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">#comment_author_name</span><span class="dl">"</span><span class="p">).</span><span class="nx">val</span><span class="p">(),</span>
              <span class="na">body</span><span class="p">:</span> <span class="nx">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">#comment_body</span><span class="dl">"</span><span class="p">).</span><span class="nx">val</span><span class="p">(),</span>
              <span class="na">article_id</span><span class="p">:</span> <span class="nx">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">#comment_article_id</span><span class="dl">"</span><span class="p">).</span><span class="nx">val</span><span class="p">()</span>
           <span class="p">}</span>
       <span class="p">}</span>

       <span class="nx">$</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="dl">"</span><span class="s2">/comments</span><span class="dl">"</span><span class="p">,</span>
              <span class="nx">commentData</span><span class="p">,</span>
              <span class="kd">function</span><span class="p">(</span><span class="nx">newCommentMarkup</span><span class="p">)</span> <span class="p">{</span>
                  <span class="nx">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">#comments</span><span class="dl">"</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span><span class="nx">newCommentMarkup</span><span class="p">);</span>
                  <span class="nx">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">#comment_author_name</span><span class="dl">"</span><span class="p">).</span><span class="nx">val</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span>
                  <span class="nx">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">#comment_body</span><span class="dl">"</span><span class="p">).</span><span class="nx">val</span><span class="p">(</span><span class="dl">""</span><span class="p">);</span>
              <span class="p">});</span>
   <span class="p">}</span>
</code></pre></div></div>

<p>For this post request we are expecting the return value of the comment post - <code class="highlighter-rouge">newCommentMarkup</code> in the <code class="highlighter-rouge">comments.js</code> file above - to be a template of the comment. If you look into the article show page file where all the comments are displayed you’ll see the template for the comment shown:</p>

<div class="language-erb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">'comment'</span><span class="nt">&gt;</span>
  <span class="nt">&lt;p&gt;</span>
    <span class="nt">&lt;em&gt;</span><span class="cp">&lt;%=</span> <span class="n">comment</span><span class="p">.</span><span class="nf">author_name</span> <span class="cp">%&gt;</span><span class="nt">&lt;/em&gt;</span>
    said <span class="cp">&lt;%=</span> <span class="n">distance_of_time_in_words</span><span class="p">(</span><span class="n">article</span><span class="p">.</span><span class="nf">created_at</span><span class="p">,</span> <span class="n">comment</span><span class="p">.</span><span class="nf">created_at</span><span class="p">)</span> <span class="cp">%&gt;</span> later:
  <span class="nt">&lt;/p&gt;</span>
  <span class="nt">&lt;p&gt;</span><span class="cp">&lt;%=</span> <span class="n">comment</span><span class="p">.</span><span class="nf">body</span> <span class="cp">%&gt;</span><span class="nt">&lt;/p&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<p>We are going to make a partial to return from the post request so the AJAX call can just render that partial. You see it the postComment function above code as <code class="highlighter-rouge">newCommentMarkup</code>.</p>

<p>So, we’ll change the comments controller create action to handle this for us:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">create</span>
    <span class="n">article</span> <span class="o">=</span> <span class="no">Article</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:comment</span><span class="p">][</span><span class="ss">:article_id</span><span class="p">])</span>
    <span class="n">comment</span> <span class="o">=</span> <span class="n">article</span><span class="p">.</span><span class="nf">comments</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">comment_params</span><span class="p">)</span>

    <span class="n">comment</span><span class="p">.</span><span class="nf">save!</span>
    <span class="n">render</span> <span class="ss">partial: </span><span class="s1">'articles/comment'</span><span class="p">,</span> <span class="ss">locals: </span><span class="p">{</span><span class="ss">comment: </span><span class="n">comment</span><span class="p">,</span> <span class="ss">article: </span><span class="n">article</span><span class="p">},</span> <span class="ss">layout: </span><span class="kp">false</span>
<span class="k">end</span>
</code></pre></div></div>

<p>What you may not be familiar with from the code above is the <code class="highlighter-rouge">layout: false</code>. What this is saying is that the partial will not be rendered in the context of the current layout. If you’re interested into reading more about this checkout the <a href="http://guides.rubyonrails.org/layouts_and_rendering.html">rails docs</a>.</p>

<p>Now that you have the return value setup correctly from the create action - the last thing we need to do is prevent the button from submitting the HTTP request and call the function from the JS file so everything will work correctly.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="kd">function</span> <span class="nx">bindSubmitListenerAndPostComment</span><span class="p">()</span> <span class="p">{</span>
   <span class="nx">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">#new_comment</span><span class="dl">"</span><span class="p">).</span><span class="nx">submit</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="p">{</span>
       <span class="nx">event</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
       <span class="nx">postComment</span><span class="p">();</span>
   <span class="p">});</span>
<span class="p">}</span>

<span class="nx">$</span><span class="p">(</span><span class="nb">document</span><span class="p">).</span><span class="nx">ready</span><span class="p">(</span><span class="kd">function</span><span class="p">(){</span>
  <span class="nx">bindSubmitListenerAndPostComment</span><span class="p">();</span>
<span class="p">})</span>
</code></pre></div></div>

<p>What we’re doing above is binding the <code class="highlighter-rouge">postComment</code> function to the #new_comment form submit action. With the line <code class="highlighter-rouge">event.preventDefault()</code> we’re stopping the button from submitting the form and allowing the AJAX request to submit the post.</p>

<p>Run the tests again and everything should still pass.</p>

<h3 id="5-additional-challenges">5. Additional Challenges</h3>

<p>As you can see the feature tests is exactly the same as if you did not have JavaScript in place. So, now write tests and implement the features in JavaScript for the following features:</p>

<ul>
  <li>You can currently filter the articles by tag, but it makes a new request and reloads the page. Can you implement this feature in JavaScript? First write the test and make sure the test passes before you change the feature to JavaScript.</li>
  <li>Write a test and implement the functionality to click a button and hide (not delete) a particular article from the articles index page.</li>
  <li>Write a test and implement the feature in JavaScript to delete an article from the articles index page.</li>
</ul>

<h3 id="outside-resources--further-reading">Outside Resources / Further Reading</h3>

<ul>
  <li><a href="http://www.guru99.com/introduction-to-selenium.html">Intro to Selenium</a></li>
  <li><a href="http://www.softwaretestinghelp.com/selenium-webdriver-selenium-tutorial-8/">Quick into to Selenium WebDriver</a></li>
  <li><a href="https://github.com/SeleniumHQ/selenium/wiki/Ruby-Bindings">Selenium Wiki - Ruby Bindings</a></li>
  <li><a href="https://github.com/jnicklas/capybara#selenium">Using Selenium with Capybara</a></li>
  <li><a href="http://stefan.magnuson.co/articles/rails/robust-integration-testing-in-rails-4-with-rspec-capybara-and-selenium/">Integration/Feature tests with RSpec, Capybara and Selenium</a></li>
</ul>
:ET