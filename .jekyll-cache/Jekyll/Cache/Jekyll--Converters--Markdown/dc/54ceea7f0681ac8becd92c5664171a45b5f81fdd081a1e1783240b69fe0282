I"˜<h2 id="learning--completion-goals">Learning &amp; Completion Goals</h2>

<ul>
  <li>Students build applications that execute in development, staging, CI and production environments</li>
</ul>

<h3 id="learning-goals-breakdown">Learning Goals Breakdown</h3>

<ul>
  <li>Student can configure each of their environments</li>
  <li>Student can identify the difference between configuration and logic in their code</li>
  <li>Student can explain the nature and purpose of a staging environment</li>
  <li>Student can explain the main components of a staging/production environment</li>
</ul>

<h2 id="a-brief-history-of-environments">A Brief History of Environments</h2>

<h3 id="stage-0-one-environment">Stage 0: One Environment</h3>

<p>Way back when, development would happen directly on production. Imagine your appâ€™s been hosted on Heroku, youâ€™ve got users on it daily, yet you push straight to Heroku every time you add a new feature / fix a bug.</p>

<p>Some problems:</p>

<ul>
  <li>Getting the code from your machine onto the production server every time you want feedback from your code</li>
  <li>Youâ€™re breaking things a lot while youâ€™re working, chancing your usersâ€™ work being interrupted on the fly</li>
</ul>

<h3 id="stage-1-two-environments">Stage 1: Two Environments</h3>

<p>To solve the last problem, we created development environments. Development environments are meant to:</p>

<ul>
  <li>shorten the feedback loop</li>
  <li>give us a low risk place to write and push code</li>
</ul>

<p>A development environment is something you can access easily from wherever you do your work. So it may live on your laptop, but there are remote development environments out there.</p>

<p>Some problems with our two environment solution:</p>

<ul>
  <li>Just because it worked on my machine, doesnâ€™t mean it will work on othersâ€™</li>
  <li>You have to ensure that your software versions are the same between environments</li>
  <li>Development environments are often not even running the same OS</li>
  <li>Although rare, hardware can sometimes change how software behaves</li>
</ul>

<h3 id="stage-2-three-environments">Stage 2: Three Environments</h3>

<p>So, we created another environment that we call <strong>staging</strong>. This environment is meant to execute our code in an environment as close as possible to production, without actually disrupting production.</p>

<p>Your staging environment is essentially a copy of production. Whatever setup you do in production, youâ€™ll do the same in staging, with a few exceptions weâ€™ll get into.</p>

<p>Staging provides a safe environment to check your work, or share your work with others. If you create bad data, or delete data, or introduce bugs, your production users are not affected.</p>

<p>If you want to learn more about staging with Heroku - <a href="https://devcenter.heroku.com/articles/multiple-environments">check out this article.</a></p>

<h3 id="stage-3-three-environments--continuous-integration">Stage 3: Three Environments + Continuous Integration</h3>

<p>There is yet another environment that is common on modern development teams: <em>Continuous Integration</em> (CI). It exists to run our tests, report back with success or failure, and in some cases, take additional action.</p>

<p>We all should run our tests before we push, or after we merge, or before we deploy, but a continuously integrated environment ensures that tests are run. It doesnâ€™t allow you to forget. You can even add CI tools to your production deployment process, such that any commit that doesnâ€™t pass its tests will be rejected.</p>

<h2 id="modern-environments">Modern Environments</h2>

<p>Letâ€™s synthesize what this looks like for a modern dev environment.</p>

<h3 id="development">Development</h3>

<p>A development environmentâ€¦</p>

<ul>
  <li>should be software-similar to staging and production</li>
  <li>is likely not hardware-similar</li>
  <li>needs to be reproducible across dev team machines</li>
  <li>is typically just setup once per project, but by many people</li>
</ul>

<h3 id="staging">Staging</h3>

<p>A staging environmentâ€¦</p>

<ul>
  <li>should be software-identical to production</li>
  <li>uses production-like data (may be a direct copy of the current production DB)</li>
  <li>has to consider privacy
    <ul>
      <li>sometimes staging sites, since live, are password-protected</li>
    </ul>
  </li>
  <li>ideally setup/teardown is very easy</li>
  <li>is usually accessible by most or all developers</li>
  <li>is usually accessible by non-technical members of your team</li>
</ul>

<h3 id="production">Production</h3>

<p>A production environmentâ€¦</p>

<ul>
  <li>defines the standard/expected hardware and software</li>
  <li>has private data</li>
  <li>is commonly scaled to <code class="highlighter-rouge">n</code> instances</li>
  <li>ideally setup/teardown is automated, or at least very well-documented</li>
  <li>typically has access restricted to only senior members</li>
</ul>

<h3 id="continuous-integration">Continuous Integration</h3>

<p>Continuous integration is an environment integration / practice to consider. CI can span environments in some situations (always run your tests before you push, run your tests in staging, in a separate tool, etc)</p>

<p>A continuously integrated environmentâ€¦</p>

<ul>
  <li>needs the same software as your production environment</li>
  <li>usually connected to your version control</li>
  <li>often connected to production for deployment</li>
  <li>should be accessible by the whole development team</li>
  <li>uses whatever data is used by the test suite</li>
</ul>

<h3 id="check-for-understanding">Check for understanding</h3>

<ul>
  <li>What is a staging environment?</li>
  <li>What advantages does a staging environment give us?</li>
  <li>What is continuous integration?</li>
  <li>How does continuous integration make our lives easier?</li>
  <li>Bonus: Youâ€™ve lived this long without either staging or CI. How could you think to get the same advantages from just your development and production environments?</li>
</ul>

<h2 id="configuration">Configuration</h2>

<h3 id="whats-the-same-across-environments">Whatâ€™s the Same Across Environments?</h3>

<p>We want to ensure that across environments we have:</p>

<ul>
  <li>Consistent versions of Ruby/Node</li>
  <li>The same gems/packages installed</li>
</ul>

<h3 id="whats-different-across-environments">Whatâ€™s Different Across Environments?</h3>

<p>There are also things that we intentionally want different between our environments. The most common example is external data sources and services:</p>

<ul>
  <li>Databases</li>
  <li>APIs</li>
  <li>Email servers</li>
  <li>Message queues</li>
</ul>

<p>To address these differences, we usually use <strong>Environment Variables</strong>. These are <em>variable values</em> that differ between <em>environments</em>. Theyâ€™re used across languages and platforms to set configuration. They allow the same logic and code to interact with different sources.</p>

<h3 id="synthesis--cfus">Synthesis / CFUs</h3>

<ul>
  <li>Why might we need differing configurations?</li>
  <li>Where do we configure environment settings in Rails?</li>
  <li>Where do we configure environment settings in Express?</li>
</ul>

<h2 id="implementing-ci">Implementing CI</h2>

<p>On your own, try setting up <a href="https://travis-ci.org/">Travis CI</a> for one of your existing projects.</p>

<p>Be sure to read their <a href="https://docs.travis-ci.com/user/getting-started/">docs here</a>.</p>
:ET