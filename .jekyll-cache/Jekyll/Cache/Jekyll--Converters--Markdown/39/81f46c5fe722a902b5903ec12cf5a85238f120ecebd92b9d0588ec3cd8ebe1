I"<h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>Learn how to create a staging environment to test your production code</li>
  <li>Learn how to handle common routing errors</li>
  <li>Rescue ActiveRecord errors in the controllers</li>
</ul>

<h2 id="structure">Structure</h2>

<h3 id="block-1-30-minutes">Block 1: 30 minutes</h3>

<ul>
  <li>5  - Conceptual discussion</li>
  <li>20 - Adding a staging environment</li>
  <li>5  - Break</li>
</ul>

<h3 id="block-2-30-minutes">Block 2: 30 minutes</h3>

<ul>
  <li>15 - Handling routing errors</li>
  <li>10 - Handling ActiveRecord exceptions</li>
  <li>5  - Break</li>
</ul>

<h3 id="block-3-30-minutes">Block 3: 30 minutes</h3>

<ul>
  <li>15 - Workshop 1: Handling ActiveRecord Exceptions</li>
  <li>10 - Demo: How to implement workshop 1</li>
  <li>5  - Recap</li>
</ul>

<h2 id="workshops">Workshops</h2>

<h3 id="workshop-1-handling-activerecord-exceptions">Workshop 1: Handling ActiveRecord Exceptions</h3>

<ol>
  <li>Create a show action in the comments  controller that finds a particular comment. Create the view.</li>
  <li>Create an index action in the comments controller that finds all the comments. Create the view.</li>
  <li>Create the corresponding routes.</li>
  <li>In the show action, rescue a record not found error and redirect to the comments#index.</li>
</ol>

<h2 id="procedure">Procedure</h2>

<ol>
  <li>Creating a Staging Environment</li>
  <li>Create a staging.rb file in the environments folder.</li>
  <li>Copy the contents of the production.rb.</li>
  <li>Change line 45 to set the config.log_level to debug.</li>
  <li>Add staging to Gemfile</li>
  <li>Change config.serve_static_assets = true</li>
  <li>Add the database configuration for the staging server.</li>
  <li>Set the staging database</li>
  <li>Run rake assets:precompile</li>
  <li>Handling Routing Exceptions
    <ol>
      <li>Add config.exceptions_app = self.routes in the config/application.rb</li>
      <li>In route controller add match ‘404’, to: redirect(‘/’), via: :all</li>
      <li>Create an errors controller</li>
      <li>Change the route to  match ‘:status’, to: ‘errors#show’, via: :all, constraints: {status: /\d{3}/ }</li>
      <li>Create a show action in the errors controller: render text: request.path</li>
      <li>Add 404.html.erb template</li>
      <li>Add render request.path[1..-1]</li>
      <li>Add @exception in the template</li>
      <li>Add this line to the show action: @exception = env[“action_dispatch.exception”]</li>
    </ol>
  </li>
  <li>Handling ActiveRecord Exceptions</li>
  <li>Open the show action in the article controller</li>
  <li>Use begin and rescue to rescue ActiveRecord::RecordNotFound and redirect to articles_path</li>
  <li>Use rescue_from ActiveRecord::RecordNotFound, with: :record_not_found. Create a private method that redirects_to articles_path, notice: ‘The article you are looking for doesn’t exist’</li>
  <li>Explain that it’s not ok to rescue all errors, such as validations.</li>
</ol>

<h2 id="discussion">Discussion</h2>

<p>Try as we might, things in software often go wrong. Unfortunately in the
case of web applications, we’re designing not for crusty developers who
can digest a nice stack trace, but for end-users, whose experience we
want to preserve even in the case of unexpected failure.</p>

<h3 id="principles-for-error-handling">Principles for Error Handling</h3>

<ul>
  <li>Fail fast – generally if something does actually go wrong, it’s better
to fail explicitly than to limp along doing wrong or unpredictable things</li>
  <li><a href="https://en.wikipedia.org/wiki/Robustness_principle">Robustness Principle</a> – be strict
about what outputs you produce, but strict about what inputs you accept – this is often
a good rule of thumb for building robust software</li>
</ul>

<h3 id="error-handling-in-ruby">Error Handling in Ruby</h3>

<ul>
  <li><code class="highlighter-rouge">Exception</code> and its various sub classes</li>
  <li><code class="highlighter-rouge">rescue</code> keyword</li>
  <li><code class="highlighter-rouge">begin...rescue</code> and <code class="highlighter-rouge">rescue</code> in method blocks</li>
</ul>

<h3 id="patterns-for-error-handling">Patterns for Error Handling</h3>

<p>In the context of a Web App, we have an additional layer of error handling
to take into account – HTTP Error Codes</p>

<p>Not only do we need to think about when and where to rescue exceptions
that might occur within our app, but we will want to think about what the proper
HTTP status code is to serve each case.</p>

<ul>
  <li>HTTP Status Code review – 3xx, 4xx, 5xx</li>
  <li>Rails error pages – maintain a reasonable UI even for unexpected errors</li>
  <li>Role of an error page – give some explanation of what went wrong, and give
users an “escape hatch” back to the main portion of the site</li>
</ul>

<h2 id="supporting-materials">Supporting Materials</h2>

<ul>
  <li><a href="https://github.com/JumpstartLab/blogger_advanced.git">Repo</a></li>
  <li><a href="https://www.dropbox.com/s/gadq54bdh8arew7/Turing%20-%20Handling%20Errors%20in%20Rails.key?dl=0">Notes</a></li>
  <li><a href="https://www.dropbox.com/s/gadq54bdh8arew7/Turing%20-%20Handling%20Errors%20in%20Rails.key?dl=0">Slides</a></li>
  <li><a href="https://vimeo.com/125649523">Video 1412</a></li>
</ul>
:ET