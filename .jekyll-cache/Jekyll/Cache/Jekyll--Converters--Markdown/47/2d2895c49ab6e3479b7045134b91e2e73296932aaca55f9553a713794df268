I"·0<h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>Understand the decorator pattern and how it can be used to make code cleaner and more maintainable</li>
  <li>Understand the theory and purpose of a presenter object</li>
</ul>

<h2 id="lecture-intro-to-decorators">Lecture: Intro to Decorators</h2>

<h3 id="q-and-a-discussion-what-problem-are-decorators-trying-to-solve">Q and A Discussion: What Problem are Decorators trying to Solve?</h3>

<ul>
  <li><strong>Q:</strong> What is the standard tool in rails for abstracting view-layer
responsibilities?</li>
  <li><strong>Q:</strong> What are some downsides to this approach? (hint: when you see a method
called in a view template, how do you determine where this method is defined?)</li>
  <li><strong>Q:</strong> What might a more object-oriented approach to view-layer
interactions look like?</li>
</ul>

<h3 id="decorator-basics">Decorator Basics</h3>

<ul>
  <li>Decorators are a Software Pattern for applying object-oriented techniques to handling
application presentation logic</li>
  <li>Decorators are often used to solve similar problems as <code class="highlighter-rouge">Helpers</code> in Rails, but rather than mixing the helper methods into our view template, we will create an object that provides the desired behavior</li>
  <li>Most implementations of the Decorator pattern are built around ‚Äúwrapping‚Äù and ‚Äúdelegation‚Äù</li>
  <li>Decorators are a good demonstration of
the <a href="https://en.wikipedia.org/wiki/Open/closed_principle">Open/Closed Principle</a> ‚Äì
we are able to add functionality to the wrapped object without
modifying it directly</li>
  <li>Decorators in ruby also exploit ruby‚Äôs use of duck typing ‚Äì since
they delegate unknown methods to the internal/wrapped object, they
effectively preserve the same interface and can be used
interchangeably.</li>
</ul>

<h3 id="wrapper--delegator-pattern">Wrapper / Delegator Pattern</h3>

<p>It‚Äôs often useful on OO design to create an object which adds additional functionality
as a ‚Äúlayer‚Äù on top of another object. We could use inheritance for this, but it‚Äôs
not always an accurate expression of the relationship ‚Äì my new object might not really
be a ‚Äúdescendant‚Äù of the original one, but it can still be involved in enhancing its
functionality.</p>

<p>A common approach to this type of relationship is to define the second object as a ‚Äúdelegator‚Äù
or ‚Äúwrapper‚Äù around the first. When creating an instance of Object B, we will pass it an
instance of Object A. In some cases Object B will define its own methods, but in some
cases it will simply ‚Äúpass through‚Äù methods that are called on it to Object A.</p>

<p>Let‚Äôs look at a more concrete example.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">class</span> <span class="nc">ObjectA</span>
  <span class="k">def</span> <span class="nf">pizza</span>
    <span class="s2">"pizza"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">calzones</span>
    <span class="s2">"calzones"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="k">class</span> <span class="nc">ObjectB</span>
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">object_a</span><span class="p">)</span>
    <span class="vi">@object_a</span> <span class="o">=</span> <span class="n">object_a</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">pizza</span>
    <span class="vi">@object_a</span><span class="p">.</span><span class="nf">pizza</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">calzones</span>
    <span class="vi">@object_a</span><span class="p">.</span><span class="nf">calzones</span><span class="p">.</span><span class="nf">upcase</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">obj</span> <span class="o">=</span> <span class="no">ObjectB</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="no">ObjectA</span><span class="p">.</span><span class="nf">new</span><span class="p">)</span>
<span class="n">obj</span><span class="p">.</span><span class="nf">pizza</span>
<span class="o">=&gt;</span> <span class="s2">"pizza"</span>
<span class="n">obj</span><span class="p">.</span><span class="nf">calzones</span>
<span class="o">=&gt;</span> <span class="s2">"CALZONES"</span>
</code></pre></div></div>

<p>As we said, ObjectB takes as its initialization argument an instance
of ObjectA. The methods we define on ObjectB either delegate directly
to methods on ObjectA, or add small modifications on the equivalent method
from ObjectA.</p>

<p>This pattern gives us 2 main advantages:</p>

<ol>
  <li>Since ObjectB defines the same suite of methods as ObjectA
we can use them interchangeably (recall what we said about Duck Typing before)</li>
  <li>Since ObjectB has the ability to modify the return values of methods from
ObjectA, we can use it as a way to add small tweaks onto these existing
behaviors. This can be very useful for presentation logic, which we often want to keep
out of the main model methods.</li>
</ol>

<h3 id="decorator-pattern-in-ruby">Decorator Pattern in Ruby</h3>

<p><strong>TODO:</strong> Create a project where we can try this out on and have the students work through it.</p>

<p>The Decorator Pattern is an OO concept and is not specific to Ruby. Ruby offers us a simple, built-in way to use the Decorator Pattern: <code class="highlighter-rouge">SimpleDelegator</code>.</p>

<p>Let‚Äôs take a look at how we could use a Decorator to clean up our view and prevent logic from leaking through.</p>

<p>Let‚Äôs say we‚Äôre storing our cart contents in a session so that the key points to an item‚Äôs id and the value points to the quantity of that item in the cart. If we called <code class="highlighter-rouge">session[:cart]</code> from a Rails controller and it returned <code class="highlighter-rouge">{"1" =&gt; 2, "3" =&gt; 1}</code> we would have 2 <code class="highlighter-rouge">Item</code>s with an id of 1 and 1 <code class="highlighter-rouge">Item</code> with an id of 3. Displaying this cart content in the view can be tricky since we want to load the <code class="highlighter-rouge">Item</code> objects and display things like their names and prices, but also the quantity in the cart. We could do something like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;% session[:cart].each do |item_id, quantity| %&gt;
  &lt;% item = Item.find(item_id) %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= item.name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= item.name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= quantity %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
</code></pre></div></div>

<p>Gross. We are making database queries and accessing the <code class="highlighter-rouge">session</code> directly in our view. One way we could improve this is to use the Decorator Pattern. The end goal would be for our view to look like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;% @cart_items.each do |cart_item| %&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;%= cart_item.name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= cart_item.name %&gt;&lt;/td&gt;
    &lt;td&gt;&lt;%= cart_item.quantity %&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;% end %&gt;
</code></pre></div></div>

<p>This feels a lot better and more in line with the purpose of a view. Iterating over an array of objects instead of a hash is also preferred and will lead to more maintainable software. So what does the code behind this need to look like?</p>

<p>In the controller:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def show
  @cart_items = Cart.new(session[:cart]).cart_items
end
</code></pre></div></div>

<p>In <code class="highlighter-rouge">cart.rb</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Cart
  def initialize(raw_contents = {})
    @raw_contents = raw_contents
  end

  def cart_items
    raw_contents.map do |item_id, quantity|
      item = Item.find(item_id)
      CartItem.new(item, quantity)
    end
  end

  private
    attr_reader :raw_contents
end
</code></pre></div></div>

<p>In <code class="highlighter-rouge">cart_item.rb</code></p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class CartItem &lt; SimpleDelegator
  attr_reader :quantity

  def initialize(item, quantity)
    super(item)
    @quantity = quantity
  end
end
</code></pre></div></div>

<p>We now have several single responsibility objects which might on the surface seem more complex. But as this project grows in complexity we will have a much easier time deciding where to put logic. Is the code specific to the cart? Put it in the <code class="highlighter-rouge">Cart</code> class. Is it specific to an item in the cart? Put it in the <code class="highlighter-rouge">CartItem</code>. If we don‚Äôt do this refactor and leave it the way it was, most of the logic lives in the view. If any of this logic needs to be used in multiple views, let‚Äôs say a main cart view and a smaller cart side-bar, we‚Äôll likely have duplicate logic making changes more difficult to maintain.</p>

<h4 id="a-deeper-dive-to-solidify-understanding">A Deeper Dive to Solidify Understanding</h4>

<p>Take some time to experiment and research the following questions</p>

<ol>
  <li>In our <code class="highlighter-rouge">CartItem</code> we define <code class="highlighter-rouge">initialize</code>. Is this always necessary with <code class="highlighter-rouge">SimpleDelegator</code>? (Experiment: Create a more simple class that inherits from <code class="highlighter-rouge">SimpleDelegator</code> that doesn‚Äôt require two parameter to initialize)</li>
  <li>In the <code class="highlighter-rouge">initialize</code> method, what is the purpose of the <code class="highlighter-rouge">super(item)</code> line?</li>
  <li>Does <code class="highlighter-rouge">super</code> always require a parameter?</li>
  <li>How does the Decorator Pattern utilize the Four Pillars of Object Oriented Programming?</li>
</ol>

<h2 id="lecture-intro-to-presenters">Lecture: Intro to Presenters</h2>

<h3 id="presenter-basics">Presenter Basics</h3>

<p>Consider these 4 rules from Sandy Metz for practicing good Rails
hygiene:</p>

<ol>
  <li>Your class can be no longer than 100 lines of code.</li>
  <li>Your methods can be no longer than five lines of code.</li>
  <li>You can pass no more than four parameters and you can‚Äôt just make it one big hash.</li>
  <li>When a call comes into your Rails controller, you can only instantiate one
object to do whatever it is that needs to be done. And your view can only know about one instance variable.</li>
</ol>

<p>The first 3 are probably familiar to us at this point (even if we
grumble about them), but what about that last one?</p>

<p>We‚Äôve certainly seen Rails controllers and views that utilized more
than one object. So how can we reconcile the need to get things done
with this outline for code cleanliness?</p>

<p>Presenters are a technique for solving this problem.</p>

<ul>
  <li>Similar to Decorators, Presenters are a pattern for abstracting
complexity in our view/presentation layer</li>
  <li>Decorator ‚Äì Adds functionality (often view-related) to a single
object (or possibly collection of objects)</li>
  <li>Presenter ‚Äì Combines functionality across <em>multiple objects</em>
into a single interface</li>
  <li>A presenter is just another domain object ‚Äì one that represents
a larger abstraction across multiple objects</li>
  <li>In more complicated scenarios, Presenters and Decorators can be
used in conjunction</li>
  <li>No library needed ‚Äì just POROs!</li>
  <li>Example: creating a <code class="highlighter-rouge">Dashboard</code> presenter</li>
</ul>

<h2 id="code-creating-a-dashboard">Code: Creating a Dashboard</h2>
<p>Using the Blogger project, create a presenter for the Dashboard such
that the <strong>only</strong> instance variable in <code class="highlighter-rouge">views/dashboard/show.html.erb</code> is
<code class="highlighter-rouge">@dashboard</code>.</p>

<p>If you get that working, try creating a <code class="highlighter-rouge">DashboardDecorator</code>. What logic can
you pull out of the view template into the decorator?</p>
:ET