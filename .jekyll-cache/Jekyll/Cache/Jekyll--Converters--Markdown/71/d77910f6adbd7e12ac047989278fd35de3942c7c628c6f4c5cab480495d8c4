I"h'<h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>Understand that there are multiple types of data collections</li>
  <li>Explain a mental model to describe hashes</li>
  <li>Describe some common hash methods</li>
</ul>

<h2 id="structure">Structure</h2>

<ul>
  <li>5 - WarmUp</li>
  <li>25 - Together - Building a Hash</li>
  <li>5 - Break</li>
  <li>15 - Group Exercise</li>
  <li>5 - WrapUp</li>
</ul>

<h2 id="vocabulary">Vocabulary</h2>
<ul>
  <li>Data Structure</li>
  <li>Hash</li>
  <li>Key</li>
  <li>Value</li>
  <li>Reference</li>
  <li>Assignment</li>
</ul>

<h2 id="warmup">WarmUp</h2>
<p>Make a T-Chart of the collections you are familiar with. Fill in what you know about each collection type you listed.</p>

<h2 id="hashes">Hashes</h2>

<h3 id="supplies">Supplies</h3>

<p>For this section, we’ll walk through performing some common Hash operations both in code using IRB and in a physical model using some basic supplies.</p>

<p>You’ll need these supplies:</p>

<ol>
  <li>1 Black Velvet Bag</li>
  <li>Piece of paper</li>
  <li>6 Beads</li>
  <li>6 Bead Labels<br />
You’ll need the following labels: blue, green, purple, red, orange, warm<br />
Attach your labels to your beads</li>
</ol>

<h3 id="intro---hash-properties">Intro - Hash Properties</h3>

<p>Hashes are the second most important data structure in Ruby. Like an Array, a Hash is a data structure used for representing a <em>collection</em> of things. But whereas an Array generally represents a <strong>list</strong> of things (ordered, identified by numeric position), we use a Hash to represent a collection of <em>named</em> key-value pairs. Both keys and values can be any object type. In a Hash, we can insert data by assigning it to a key name and later retrieving it using the same key name.</p>

<p>Ruby stringifies <code class="highlighter-rouge">keys</code>, then uses a hashing algorithm to map the string to a data address where the <code class="highlighter-rouge">value</code> data is stored (data can be stored wherever memory is free; all <code class="highlighter-rouge">values</code> do not need to be in a contiguous block of memory). Look ups are more efficient for hashes than arrays because they only need to look at one memory location to get the <code class="highlighter-rouge">value</code> data. Iterating through a hash is less efficient than an array because the hashing algorithm is not efficient to reverse the hash back to the original stringified <code class="highlighter-rouge">key</code>, so it stores the string and the hash result and needs to use both for iteration.</p>

<p>Some languages call their Hashes <em>hash maps, maps, dictionaries, associative arrays, or symbol tables</em> because you look up a key to retrieve its definition (the data or value with which the label was associated).</p>

<p>Key ideas:</p>

<ul>
  <li>Ordered vs. Unordered</li>
  <li>Pairs</li>
  <li>Determinism and uniqueness</li>
  <li>Choosing a hash vs an array</li>
  <li>Performance characteristics</li>
</ul>

<h3 id="working-a-hash">Working a Hash</h3>

<p>Now let’s model some of the common hash operations in the physical space alongside an IRB session. As we go, we’ll look at these common methods:</p>

<ul>
  <li><code class="highlighter-rouge">[]</code>     element reference</li>
  <li><code class="highlighter-rouge">[]=</code>    element assignment</li>
  <li><code class="highlighter-rouge">keys</code>   returns an array of all the keys</li>
  <li><code class="highlighter-rouge">values</code> returns an array of all the values</li>
</ul>

<p>Follow along with the instructor as you walk through the following operations:</p>

<p>Create a bead class:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Bead</span>
  
  <span class="k">def</span> <span class="nf">initialize</span>
  <span class="k">end</span>
  
<span class="k">end</span>
</code></pre></div></div>

<ol>
  <li>Create a new hash <code class="highlighter-rouge">beads = {}</code> or ‘beads = Hash.new`
    <ul>
      <li>Write <code class="highlighter-rouge">beads</code> on your paper, this is your variable assigned to the hash we are making. Put your bag on your paper, this is your hash.</li>
    </ul>
  </li>
  <li>Assign the key <code class="highlighter-rouge">blue</code>: <code class="highlighter-rouge">beads["blue"] = Bead.new</code>
    <ul>
      <li>Using your blue tag, attach it to a bead. Put the bead into the bag leaving the blue tag/key hanging out.</li>
    </ul>
  </li>
  <li>Read the value: <code class="highlighter-rouge">beads["blue"]</code>
    <ul>
      <li>Pull the ‘blue’ tag. The blue tag is your key, bead is your value.</li>
    </ul>
  </li>
  <li>Store a second pair: <code class="highlighter-rouge">beads["green"] = Bead.new</code>
    <ul>
      <li>Using your “green” tag, attach it to a bead. Put the bead into your hash/bag, leaving they key/tag hanging out.</li>
    </ul>
  </li>
  <li>Reuse a key: <code class="highlighter-rouge">beads["blue"] = Bead.new</code>
    <ul>
      <li>Change what kind of blue bead you want. Take the blue tag off and re-attach it to a new bead.</li>
      <li>Note in IRB that the object ID is different for the first blue bead and the second blue bead.</li>
    </ul>
  </li>
  <li>Create a key for nothing: <code class="highlighter-rouge">beads["purple"] = nil</code>
    <ul>
      <li>Hang a purple tag/key from your bag/hash, with no bead attached.</li>
    </ul>
  </li>
  <li>I can everything in my bag/hash by calling <code class="highlighter-rouge">beads</code>; this returns the whole hash.
    <ul>
      <li>Grab all the tags, pull them all out</li>
    </ul>
  </li>
  <li>What if I want to do something with my keys, maybe I just want to see what keys are there. You can retrieve an array (a list) of keys by entering <code class="highlighter-rouge">beads.keys</code>.
    <ul>
      <li>Spread out your keys/tags and look at what keys you have.</li>
    </ul>
  </li>
  <li>Retrieving an array (list) of <code class="highlighter-rouge">values</code> from the hash: <code class="highlighter-rouge">beads.values</code>
    <ul>
      <li>Spread out your values/beads and look at what values you have</li>
    </ul>
  </li>
  <li>Get a little weird: We said you can have any object type as a value, perhaps an array - <code class="highlighter-rouge">beads["red"] = [Bead.new, Bead.new]</code> perhaps a collection of all my red beads.</li>
  <li>Get more weird: You can also have a hash as a value (nested hashes) <code class="highlighter-rouge">beads["warm"] = {"orange" =&gt; Bead.new, "red" =&gt; Bead.new}</code>
    <ul>
      <li>This would be if you have a tag/key that is attached to your neighbor’s hash/bag which had a orange and red bead in it.</li>
    </ul>
  </li>
  <li>Consider the key <code class="highlighter-rouge">"red"</code> and how it does and doesn’t exist twice. What is different about the ways I need to access each of these reds?</li>
  <li>Mess up your brain: <code class="highlighter-rouge">beads["spinning top"] = beads</code></li>
</ol>

<h2 id="group-exercise">Group Exercise</h2>

<p>For this exercise you’ll work in threes.</p>

<ul>
  <li>Person <code class="highlighter-rouge">A</code> is in charge of reading the instructions</li>
  <li>Person <code class="highlighter-rouge">B</code> is in charge of the physical model - you’ll need 3 more tags</li>
  <li>Person <code class="highlighter-rouge">C</code> is in charge of working in IRB (in such a way that the others can see!)</li>
</ul>

<p>Start with an empty <code class="highlighter-rouge">beads</code> hash in both the physical space and in <code class="highlighter-rouge">pry</code>.</p>

<p>For the pry person, recall that you can create a simple <code class="highlighter-rouge">Bead</code> model like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Bead</span> 
  <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="n">color</span><span class="p">)</span>
     <span class="vi">@color</span> <span class="o">=</span> <span class="n">color</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="steps">Steps</h3>

<ol>
  <li>Insert a “blue” bead <code class="highlighter-rouge">beads["blue"] = Bead.new("blue")</code></li>
  <li>Find the value attached to the key <code class="highlighter-rouge">"blue"</code></li>
  <li>Find the value attached to the key <code class="highlighter-rouge">"green"</code></li>
  <li>Add a new bead referenced by the key <code class="highlighter-rouge">"green"</code></li>
  <li>Add a new bead referenced by the key <code class="highlighter-rouge">"purple"</code></li>
  <li>What are the <code class="highlighter-rouge">keys</code>? What kind of object does that method return?</li>
  <li>What are the <code class="highlighter-rouge">values</code>? What kind of object does that method return?</li>
  <li>What’s interesting about the order of the return value of both <code class="highlighter-rouge">keys</code> and <code class="highlighter-rouge">values</code>?</li>
  <li>Add a new bead referenced by the key <code class="highlighter-rouge">"green"</code></li>
  <li>How has <code class="highlighter-rouge">keys</code> changed after the last step? How has <code class="highlighter-rouge">values</code> changed? What was lost?</li>
  <li>As a group, update your data collection T-Chart to include new Hash info.</li>
</ol>

<h2 id="wrapup">WrapUp</h2>
<p>Create a Venn Diagram of Arrays and Hashes</p>

<h2 id="additional-resources">Additional Resources</h2>

<p>Now you’ve got a decent understanding of hashes. Let’s go at it from the
beginning and try to fill a few of the gaps: work through the <a href="http://tutorials.jumpstartlab.com/projects/ruby_in_100_minutes.html#8.-hashes">Hashes section of Ruby in 100 Minutes</a> to pick up a bit more.</p>
:ET