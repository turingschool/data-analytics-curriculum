I"∫ñ<h2 id="goals">Goals</h2>

<p>By the end of this lesson,  you will know/be able to:</p>

<ul>
  <li>understand that methods generate a new local scope</li>
  <li>understand how a method ‚Äúbinds‚Äù its arguments within its scope</li>
  <li>recognize the difference between a bound and an unbound variable</li>
  <li>understand that instance methods remain in scope to other methods
within a class</li>
  <li>understand that local variables within a method will override
variables/methods of the same name in outer scopes</li>
  <li>understand the idea of a top-level ‚Äúglobal‚Äù scope where code will
execute by default</li>
</ul>

<h2 id="concepts">Concepts</h2>
<ul>
  <li>A scope represents a local ‚Äúenvironment‚Äù where code can be executed</li>
  <li>Scopes recognize the names of variables or methods which are defined
in them and can translate these names back to their appropriate
values</li>
  <li>Scopes can be ‚Äúnested,‚Äù and in the case of a nested scope, the
closest definition of a given name will always take precedence</li>
  <li>Several things in ruby create new local scopes ‚Äì methods, blocks,
classes/modules, and instances are the main ones we encounter</li>
</ul>

<h3 id="structure">Structure</h3>

<ul>
  <li>Global Scope</li>
  <li>Scope Methods and Arguments</li>
  <li>Methods Accessing Other Methods</li>
  <li>Break</li>
  <li>What About Blocks?</li>
  <li>Blocks with overlapping Inner/Outer variables</li>
  <li>Break</li>
  <li>Defining Classes and Instantiating Them</li>
  <li>Classes Can Have Methods Too</li>
  <li>Referring to the Current Object</li>
  <li>Instance Methods with Arguments</li>
  <li>Using Method Values as arguments to other methods</li>
  <li>Argument Names are Arbitrary</li>
  <li>Default Argument Values</li>
  <li>Other Methods Can Be Used as Default Values</li>
</ul>

<h2 id="group-discussion--walkthrough">Group Discussion / Walkthrough</h2>

<h4 id="step-1-global-scope">Step 1: Global scope</h4>

<p>Let‚Äôs start with the most basic code structure we could look at in ruby
‚Äî a single file with some statements executing in top-level scope.</p>

<p>Create a file called <code class="highlighter-rouge">global_scope.rb</code> on your machine:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>touch global_scope.rb
</code></pre></div></div>

<p>Open the file in your text editor so we can work on it.</p>

<p>Let‚Äôs add some very basic code:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span>
  <span class="nb">puts</span> <span class="s2">"x is </span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2">"</span>
  <span class="n">x</span> <span class="o">+=</span> <span class="mi">20</span>
  <span class="nb">puts</span> <span class="s2">"x is </span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>Before running the file, state briefly in your head what output you
expect to see. Then run the file (<code class="highlighter-rouge">ruby global_scope.rb</code>) and see if
your expectations were correct.</p>

<p>In this trivial example <code class="highlighter-rouge">x</code> is functioning as a local variable. So far
we have not added any methods, classes, blocks, or other structures that
would create additional scopes, so we might say that <code class="highlighter-rouge">x</code> is currently
defined in the ‚Äúglobal‚Äù or top-level scope.</p>

<p><strong>Methods in Global Scope</strong></p>

<p>While we most often define methods on objects in ruby, we can define
them in the global scope as well, just as we defined the local variable
<code class="highlighter-rouge">x</code> in the example above.</p>

<h4 id="step-2-method-scopes-and-arguments">Step 2: Method Scopes and Arguments</h4>

<p>Let‚Äôs add some lines to the bottom of <code class="highlighter-rouge">global_scope.rb</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">def</span> <span class="nf">print_doubled_value</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="s2">"double the value </span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2"> is </span><span class="si">#{</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>

  <span class="n">print_doubled_value</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div></div>

<p>Again, consider what you expect this code to do, and then run it.</p>

<p>So far so good ‚Äî we can probably guess pretty easily how this example will
behave.</p>

<p>Let‚Äôs add another example using the new <code class="highlighter-rouge">print_doubled_value</code> method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">y</span> <span class="o">=</span> <span class="mi">27</span>
  <span class="n">print_doubled_value</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
</code></pre></div></div>

<p>Does this code behave as you expect? Consider the 2 uses of the variable
<code class="highlighter-rouge">x</code> in our current example ‚Äî we have a variable called <code class="highlighter-rouge">x</code> in the top
level scope which begins as <code class="highlighter-rouge">10</code> and is then incremented to <code class="highlighter-rouge">30</code>.</p>

<p>But inside of the <code class="highlighter-rouge">print_doubled_value</code> method, we see another usage of <code class="highlighter-rouge">x</code>,
this one apparently changing each time the method is called.</p>

<p>This illustrates one of the important behaviors of methods in ruby ‚Äì
they create new scopes with an independent set of variables from
whatever scope surrounds the method.</p>

<p>In this case the <code class="highlighter-rouge">x</code> which appears in the definition of our method
(<code class="highlighter-rouge">def print_doubled_value(x)</code>) is an <strong>argument</strong> to the method,
and as such it becomes a new local variable available within the
scope of the method.</p>

<p>To get fancy, we might say that the variable <code class="highlighter-rouge">x</code> is <em>bound</em> by the
method <code class="highlighter-rouge">print_doubled_value</code> ‚Äì other definitions of variables named <code class="highlighter-rouge">x</code>
may exist, but within <code class="highlighter-rouge">print_doubled_value</code> they are irrelevant, since
the method‚Äôs own definition of this variable supersedes any other
definitions.</p>

<p>Enough theory, let‚Äôs look at another example. Redefine
<code class="highlighter-rouge">print_doubled_value</code> and call it like so:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">print_doubled_value</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="n">orig</span> <span class="o">=</span> <span class="n">x</span>
  <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span>
  <span class="nb">puts</span> <span class="s2">"double the value </span><span class="si">#{</span><span class="n">orig</span><span class="si">}</span><span class="s2"> is </span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2">"</span>
  <span class="nb">puts</span> <span class="s2">"inner x is now: </span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>

<span class="n">print_doubled_value</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="nb">puts</span> <span class="s2">"outer x is still: </span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>What output do you expect from this code? Think especially about the
output about ‚Äúinner‚Äù and ‚Äúouter‚Äù values of x:</p>

<p><code class="highlighter-rouge">inner x is now: ??</code></p>

<p><code class="highlighter-rouge">outer x is still: ??</code></p>

<p>We can see from this example that modifying the value of <code class="highlighter-rouge">x</code> inside of
the method has no effect on the value of <code class="highlighter-rouge">x</code> outside of the method.</p>

<p>This behavior holds true even when (as in this example) the outer
variable and the inner (method) variable <em>have the same name</em>!</p>

<p>The method‚Äôs variable of the name <code class="highlighter-rouge">x</code> is completely independent of the
global scope‚Äôs method of the name <code class="highlighter-rouge">x</code>, so any modifications we make
within the method have no effect on the outer variable.</p>

<p>Let‚Äôs consider another example. Add a new <code class="highlighter-rouge">combine_variables</code> method to
your file:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">12</span>
<span class="k">def</span> <span class="nf">combine_variables</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"inner x is: </span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2">"</span>
  <span class="nb">puts</span> <span class="s2">"and outer b is: </span><span class="si">#{</span><span class="n">b</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
<span class="n">combine_variables</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</code></pre></div></div>

<p>How does this code match your expectations?</p>

<p>We might have expected some output like:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">inner</span> <span class="n">x</span> <span class="ss">is: </span><span class="mi">4</span>
<span class="n">and</span> <span class="n">outer</span> <span class="n">b</span> <span class="ss">is: </span><span class="mi">12</span>
</code></pre></div></div>

<p>But what actually happens? We should get an error similar to:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">global_scope</span><span class="p">.</span><span class="nf">rb</span><span class="p">:</span><span class="mi">29</span><span class="ss">:in</span> <span class="sb">`combine_variables': undefined local variable or method `</span><span class="n">b</span><span class="s1">' for main:Object (NameError)
	from global_scope.rb:31:in `&lt;main&gt;'</span>
</code></pre></div></div>

<p>What does this error show us about method scopes?</p>

<p>Not only do they have independent versions of any variables that might
have existed in their parent scope, but they can‚Äôt even access other
variables from the parent scope.</p>

<p>This can be a common source of confusion when you‚Äôre new to ruby so make
a note: method‚Äôs <strong>can‚Äôt</strong> access local variables in their parent scope.</p>

<h4 id="step-3-methods-accessing-other-methods">Step 3: Methods Accessing Other Methods</h4>

<p>So what can methods access? Let‚Äôs replace the code from our last
iteration with a new version which actually works:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">combine_variables</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"inner x is: </span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2">"</span>
  <span class="nb">puts</span> <span class="s2">"and outer b is: </span><span class="si">#{</span><span class="n">b</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">b</span>
  <span class="mi">12</span>
<span class="k">end</span>

<span class="n">a</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">combine_variables</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
</code></pre></div></div>

<p>Why does this version work when the other did not?</p>

<p>While a method can‚Äôt access local variables defined in its parent scope,
it <em>can</em> access other methods defined in that scope.</p>

<p>We might think of these methods as ‚Äúsiblings‚Äù ‚Äì since they are created
at the same level in our code, they can reference one another freely.</p>

<p>But don‚Äôt forget that local variables within the method always take
precedence.</p>

<p>Let‚Äôs modify our <code class="highlighter-rouge">combine_variables</code> method to look like so:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">combine_variables</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"inner x is: </span><span class="si">#{</span><span class="n">x</span><span class="si">}</span><span class="s2">"</span>
  <span class="nb">puts</span> <span class="s2">"and outer b is: </span><span class="si">#{</span><span class="n">b</span><span class="si">}</span><span class="s2">"</span>
  <span class="n">b</span> <span class="o">=</span> <span class="s2">"pizza"</span>
  <span class="nb">puts</span> <span class="s2">"but now b is: </span><span class="si">#{</span><span class="n">b</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>What happens to <code class="highlighter-rouge">b</code> during the course of this method? We can see that at
first it refers to the method <code class="highlighter-rouge">b</code>; after we create a new local variable
of the same name, however, <code class="highlighter-rouge">b</code> refers to that instead.</p>

<p>When trying to determine what value a variable refers to, a method will
always look first for a local variable, and only if one is not found
will it attempt to look for another method of that name.</p>

<h4 id="check-for-understanding">Check for Understanding</h4>

<ul>
  <li>When a variable is defined outside of any classes, what scope would we say that it is in?</li>
  <li>Why are local variables when defined in a method, not accessible to other scopes?</li>
  <li>When are methods siblings? What does being a sibling allow them to do?</li>
</ul>

<h4 id="step-4-what-about-blocks">Step 4: What about blocks?</h4>

<p>We saw earlier that methods create new scopes which lack the ability to
reference local variables in their parent scope. But methods aren‚Äôt the
only things that can create scopes.</p>

<p>Another common way that we create new scopes in ruby is by using blocks.
You‚Äôve seen blocks many times by now, especially when using enumerables:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">].</span><span class="nf">each</span> <span class="p">{</span> <span class="o">|</span><span class="n">num</span><span class="o">|</span> <span class="nb">puts</span> <span class="s2">"num is </span><span class="si">#{</span><span class="n">num</span><span class="si">}</span><span class="s2">"</span> <span class="p">}</span>
<span class="n">num</span> <span class="n">is</span> <span class="mi">1</span>
<span class="n">num</span> <span class="n">is</span> <span class="mi">2</span>
<span class="n">num</span> <span class="n">is</span> <span class="mi">3</span>
<span class="o">=&gt;</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
</code></pre></div></div>

<p>Note that the <code class="highlighter-rouge">num</code> block variable functions very similarly to a method
argument ‚Äî each time the block is executed, a new value will be supplied
for <code class="highlighter-rouge">num</code></p>

<p>Do blocks have the same behavior when it comes to scopes and arguments?
Let‚Äôs find out. Add some more code to the bottom of our <code class="highlighter-rouge">global_scopes.rb</code> file:</p>

<p>(this file is starting to get a bit messy, but such is the price of
learning)</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ingredients</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"flour"</span><span class="p">,</span> <span class="s2">"water"</span><span class="p">,</span> <span class="s2">"yeast"</span><span class="p">,</span> <span class="s2">"salt"</span><span class="p">]</span>
<span class="nb">method</span> <span class="o">=</span> <span class="s2">"measure"</span>

<span class="k">def</span> <span class="nf">unit</span>
  <span class="p">[</span><span class="s2">"teaspoon"</span><span class="p">,</span> <span class="s2">"cup"</span><span class="p">,</span> <span class="s2">"pinch"</span><span class="p">].</span><span class="nf">sample</span>
<span class="k">end</span>

<span class="n">ingredients</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">ingredient</span><span class="o">|</span>
  <span class="nb">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">method</span><span class="si">}</span><span class="s2"> one </span><span class="si">#{</span><span class="n">unit</span><span class="si">}</span><span class="s2"> </span><span class="si">#{</span><span class="n">ingredient</span><span class="si">}</span><span class="s2">"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>There are quite a few pieces in play here ‚Äî 2 local variables, a method,
and a block variable! What output do you think it will produce?</p>

<p>Holy cavorting closures batman! Unlike the method example we saw before,
which blew up when trying to refer to an adjacent local variable, this
code works just fine.</p>

<p>This is due to the ability of blocks to create what is called a
‚Äúclosure.‚Äù Unlike a method scope, which captures its arguments but
ignores surrounding local variables, a closure ‚Äúcloses over‚Äù those
variables and allows them to be referenced from the inner scope.</p>

<p>But how do blocks handle collisions between variables? Let‚Äôs try an
example. More code!</p>

<h4 id="step-5-blocks-with-overlapping-innerouter-variables">Step 5: Blocks with overlapping inner/outer variables</h4>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">new_ingredients</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"banana"</span><span class="p">,</span> <span class="s2">"chocolate chips"</span><span class="p">]</span>
<span class="n">temperature</span> <span class="o">=</span> <span class="mi">375</span>
<span class="nb">method</span> <span class="o">=</span> <span class="s2">"bake"</span>

<span class="n">new_ingredients</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">ingredient</span><span class="o">|</span>
  <span class="nb">method</span> <span class="o">=</span> <span class="s2">"mix"</span>
  <span class="nb">puts</span> <span class="s2">"</span><span class="si">#{</span><span class="nb">method</span><span class="si">}</span><span class="s2"> the </span><span class="si">#{</span><span class="n">ingredient</span><span class="si">}</span><span class="s2"> at </span><span class="si">#{</span><span class="n">temperature</span><span class="si">}</span><span class="s2"> degrees"</span>
<span class="k">end</span>

<span class="nb">puts</span> <span class="nb">method</span>
</code></pre></div></div>

<p>What happens to our variables each time the block is executed?
Especially of interest in this example are the <code class="highlighter-rouge">temperature</code> and <code class="highlighter-rouge">method</code>
variables.</p>

<p>In this case we see that the block variable <code class="highlighter-rouge">temperature</code> ‚Äúshadows‚Äù the
outer variable of the same name within the block. But what happens to
<code class="highlighter-rouge">temperature</code> after the block is done?</p>

<p>And what about <code class="highlighter-rouge">method</code>? How does it change during the execution of the
block?</p>

<p>The ability of blocks to refer to surrounding local variables is
powerful, but it can also be potentially dangerous. We should to pay close
attention to what variables we modify within a block to avoid
accidentally modifying the wrong thing.</p>

<h4 id="check-for-understanding-1">Check for Understanding</h4>

<ul>
  <li>What is a closure?</li>
  <li>How do blocks handle variable naming collisions?</li>
  <li>What is the danger in blocks being able to access surrounding local variables?</li>
</ul>

<h2 id="part-2-classes-and-objects">Part 2: Classes and Objects</h2>

<p>Let‚Äôs look at some more examples to see how these same principles apply
to scopes within objects.</p>

<h4 id="step-1-defining-classes-and-instantiating-them">Step 1: Defining classes and instantiating them</h4>

<p>Create a new file called <code class="highlighter-rouge">object_scopes.rb</code> and add some code to it:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PizzaOven</span>
<span class="k">end</span>

<span class="n">oven</span> <span class="o">=</span> <span class="no">PizzaOven</span><span class="p">.</span><span class="nf">new</span>
<span class="nb">puts</span> <span class="s2">"cookin pizza in the oven: </span><span class="si">#{</span><span class="n">oven</span><span class="si">}</span><span class="s2">"</span>
</code></pre></div></div>

<p>By now we‚Äôre hopefully getting somewhat comfortable with defining
classes and creating objects, so we can probably predict what output
this code will produce:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cookin pizza in the oven: #&lt;PizzaOven:0x007fe7da9de418&gt;
</code></pre></div></div>

<p>We‚Äôve just created a new instance of the <code class="highlighter-rouge">PizzaOven</code> class and output a
description of it by ‚Äúinterpolating‚Äù it into a string.</p>

<h4 id="step-2-classes-can-have-methods-too">Step 2: Classes can have methods too</h4>

<p>As we‚Äôve seen, we can add methods to this class. Let‚Äôs cook some ‚Äòza.
Add a <code class="highlighter-rouge">cook</code> method to our PizzaOven class so our file reads like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PizzaOven</span>
  <span class="k">def</span> <span class="nf">cook</span>
    <span class="nb">puts</span> <span class="s2">"cookin pizza in the oven: </span><span class="si">#{</span><span class="n">oven</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">oven</span> <span class="o">=</span> <span class="no">PizzaOven</span><span class="p">.</span><span class="nf">new</span>
<span class="n">oven</span><span class="p">.</span><span class="nf">cook</span>
</code></pre></div></div>

<p>What‚Äôs going to happen when we run this? We‚Äôd probably like to see the
same output as before (<code class="highlighter-rouge">cookin pizza in the oven: #&lt;PizzaOven:0x007fe7da9de418&gt;</code>).</p>

<p>But in fact we get an error. What happened to the <code class="highlighter-rouge">oven</code> local variable
‚Äî consider why it‚Äôs no longer in scope.</p>

<h4 id="step-3-referring-to-the-current-object">Step 3: Referring to the current object</h4>

<p>Our problem is that we moved the code for printing our cookin statement
<em>inside</em> of the object. We can still access the <code class="highlighter-rouge">oven</code> object if we
want, but the way to do so is different. We need to use a special method
called <code class="highlighter-rouge">self</code>.</p>

<p>Let‚Äôs tweak our <code class="highlighter-rouge">cook</code> method to use <code class="highlighter-rouge">self</code> so we can still output the
info about our oven:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PizzaOven</span>
  <span class="k">def</span> <span class="nf">cook</span>
    <span class="nb">puts</span> <span class="s2">"cookin pizza in the oven: </span><span class="si">#{</span><span class="nb">self</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">oven</span> <span class="o">=</span> <span class="no">PizzaOven</span><span class="p">.</span><span class="nf">new</span>
<span class="n">oven</span><span class="p">.</span><span class="nf">cook</span>
</code></pre></div></div>

<p>In ruby, the method <code class="highlighter-rouge">self</code> will always refer to the <em>current object</em>;
that is, the object inside of which your code is currently executing.</p>

<p>In our case, we have created a class <code class="highlighter-rouge">PizzaOven</code>, defined an <em>instance
method</em> <code class="highlighter-rouge">cook</code>, and called that method on an instance of <code class="highlighter-rouge">PizzaOven</code>.
At the moment when we hit the <code class="highlighter-rouge">puts</code> statement inside of the cook
method, <code class="highlighter-rouge">self</code>, then, will refer to the <em>current</em> <code class="highlighter-rouge">PizzaOven</code> ‚Äî the
specific oven on which the <code class="highlighter-rouge">cook</code> method was called.</p>

<h4 id="check-for-understanding-2">Check for Understanding</h4>

<ul>
  <li>What do we see when we simply try to puts an object?</li>
  <li>How can an instance of a class refer to itself?</li>
  <li>What is an instance method?</li>
</ul>

<h4 id="step-4-instance-methods-with-arguments">Step 4: Instance methods with arguments</h4>

<p>Let‚Äôs look at adding some more methods to our class, this time using
arguments to customize the behavior.</p>

<p>Let‚Äôs add a <code class="highlighter-rouge">temp</code> and <code class="highlighter-rouge">crust_type</code> method and have cook use them
to determine what we‚Äôre cooking:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PizzaOven</span>
  <span class="k">def</span> <span class="nf">cook</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="n">crust_type</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="s2">"mmm, mmm. cookin </span><span class="si">#{</span><span class="n">crust_type</span><span class="si">}</span><span class="s2"> pizza in the oven at </span><span class="si">#{</span><span class="n">temp</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">temp</span>
    <span class="s2">"400 degrees F"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">crust_type</span>
    <span class="s2">"New York Style"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">oven</span> <span class="o">=</span> <span class="no">PizzaOven</span><span class="p">.</span><span class="nf">new</span>
<span class="n">oven</span><span class="p">.</span><span class="nf">cook</span><span class="p">(</span><span class="s2">"100 degrees F"</span><span class="p">,</span> <span class="s2">"Digiorno"</span><span class="p">)</span>
</code></pre></div></div>

<p>Did this produce the output you expected?</p>

<p>We might have expected to see <code class="highlighter-rouge">mmm, mmm. cookin New York Style pizza in the oven at 400 degrees F</code>
‚Äî after all, our <code class="highlighter-rouge">PizzaOven</code> has a <code class="highlighter-rouge">temp</code> method (‚Äú400 degrees F‚Äù) and
<code class="highlighter-rouge">crust_type</code> method (‚ÄúNew Haven Style‚Äù).</p>

<p>But remember that method arguments exist only as local variables defined within the scope of the method.</p>

<p>Even if a method‚Äôs arguments happen to have the same name as another
method on the same object (in this case an instance of <code class="highlighter-rouge">PizzaOven</code>), the
two definitions are completely independent of one another.</p>

<h4 id="step-5-using-method-values-as-arguments-to-other-methods">Step 5: Using method values as arguments to other methods</h4>

<p>Consider another example. Change the code at the bottom of your file to
read:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">oven</span><span class="p">.</span><span class="nf">cook</span><span class="p">(</span><span class="n">oven</span><span class="p">.</span><span class="nf">temp</span><span class="p">,</span> <span class="n">oven</span><span class="p">.</span><span class="nf">crust_type</span><span class="p">)</span>
</code></pre></div></div>

<p>Output:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>mmm, mmm. cookin New York pizza in the oven at 400 degrees F
</code></pre></div></div>

<p>Tasty.</p>

<p>Now we‚Äôve fixed our problem by explicitly passing in the values from the
appropriate <code class="highlighter-rouge">PizzaOven</code> methods into the oven‚Äôs <code class="highlighter-rouge">cook</code> method.</p>

<p>But remember: the fact that the names match in this instance is
irrelevant to the execution of the code. When the interpreter evaluates
<code class="highlighter-rouge">oven.temp</code> and <code class="highlighter-rouge">oven.crust_type</code> in the last line of the file, it gives
no consideration to the fact that the method <code class="highlighter-rouge">cook</code> uses those same
names for its arguments.</p>

<h4 id="step-6-method-argument-names-are-arbitrary">Step 6: Method argument names are arbitrary</h4>

<p>To hopefully drive home the lack of connection between the 2 sides of
calling a method (values being input vs. values being consumed), let‚Äôs
tweak our code once more:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">oven</span><span class="p">.</span><span class="nf">cook</span><span class="p">(</span><span class="n">oven</span><span class="p">.</span><span class="nf">crust_type</span><span class="p">,</span> <span class="n">oven</span><span class="p">.</span><span class="nf">temp</span><span class="p">)</span>
</code></pre></div></div>

<p>What will this code output? Our values are backwards! Again, the <code class="highlighter-rouge">oven.crust_type</code> and <code class="highlighter-rouge">oven.temp</code>
which we are passing <strong>in</strong> to the method are evaluated in a completely
different context from. So something we call <code class="highlighter-rouge">crust_type</code> before passing
it into the method can just as easily be called <code class="highlighter-rouge">temp</code> <em>inside</em> of the
method. The 2 scopes are independent</p>

<h4 id="step-6-default-argument-values">Step 6: Default argument values</h4>

<p>We can also assign what we call ‚Äúdefault‚Äù values for a method. This
technique is often used to allow a method to be called without an
argument in most cases, but still accept a method whenever necessary.</p>

<p>Let‚Äôs add some defaults for our <code class="highlighter-rouge">cook</code> method:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PizzaOven</span>
  <span class="k">def</span> <span class="nf">cook</span><span class="p">(</span><span class="n">temp</span> <span class="o">=</span> <span class="s2">"425 F"</span><span class="p">,</span> <span class="n">crust_type</span> <span class="o">=</span> <span class="s2">"Deep Dish"</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="s2">"mmm, mmm. cookin </span><span class="si">#{</span><span class="n">crust_type</span><span class="si">}</span><span class="s2"> pizza in the oven at </span><span class="si">#{</span><span class="n">temp</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">temp</span>
    <span class="s2">"400 degrees F"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">crust_type</span>
    <span class="s2">"New Haven Style"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">oven</span> <span class="o">=</span> <span class="no">PizzaOven</span><span class="p">.</span><span class="nf">new</span>
<span class="n">oven</span><span class="p">.</span><span class="nf">cook</span>
<span class="n">oven</span><span class="p">.</span><span class="nf">cook</span><span class="p">(</span><span class="n">oven</span><span class="p">.</span><span class="nf">temp</span><span class="p">,</span> <span class="n">oven</span><span class="p">.</span><span class="nf">crust_type</span><span class="p">)</span>
</code></pre></div></div>

<p>How does the <code class="highlighter-rouge">cook</code> method behave differently between these 2
invocations? Notice that the default arguments only get applied in the
case that no argument is provided. Since we first called <code class="highlighter-rouge">cook</code> with no
arguments, ruby will pull in the ‚Äúdefaults‚Äù of <code class="highlighter-rouge">425 F</code> for <code class="highlighter-rouge">temp</code> and
<code class="highlighter-rouge">Deep Dish</code> for <code class="highlighter-rouge">crust_type</code>.</p>

<h4 id="check-for-understanding-3">Check for Understanding</h4>

<ul>
  <li>Does it matter what we name our arguments? Why?</li>
  <li>How do we use default argument values versus methods of the same name?</li>
</ul>

<h4 id="step-7-other-methods-can-be-used-as-default-values">Step 7: Other methods can be used as default values</h4>

<p>Let‚Äôs look at one more potentially confusing example. Currently we‚Äôre
providing static data for our default arguments in the <code class="highlighter-rouge">cook</code> method
(the string <code class="highlighter-rouge">"425 F"</code> and the string <code class="highlighter-rouge">"Deep Dish"</code>).</p>

<p>We could actually use other methods as the default arguments if we so desired.</p>

<p>Let‚Äôs change our code to read like so:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PizzaOven</span>
  <span class="k">def</span> <span class="nf">cook</span><span class="p">(</span><span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="p">,</span> <span class="n">crust_type</span> <span class="o">=</span> <span class="n">crust_type</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="s2">"mmm, mmm. cookin </span><span class="si">#{</span><span class="n">crust_type</span><span class="si">}</span><span class="s2"> pizza in the oven at </span><span class="si">#{</span><span class="n">temp</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">temp</span>
    <span class="s2">"400 degrees F"</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">crust_type</span>
    <span class="s2">"New Haven Style"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">oven</span> <span class="o">=</span> <span class="no">PizzaOven</span><span class="p">.</span><span class="nf">new</span>
<span class="n">oven</span><span class="p">.</span><span class="nf">cook</span>
<span class="n">oven</span><span class="p">.</span><span class="nf">cook</span><span class="p">(</span><span class="n">oven</span><span class="p">.</span><span class="nf">temp</span><span class="p">,</span> <span class="n">oven</span><span class="p">.</span><span class="nf">crust_type</span><span class="p">)</span>
</code></pre></div></div>

<p><strong>WAT</strong>?</p>

<p>What will we see when we run this? In fact, it will produce the same
output both times.</p>

<p>How does ruby allow this? How can we define the method-local variable
<code class="highlighter-rouge">temp</code> in terms of itself?</p>

<p>Well it turns out we‚Äôre not actually defining <code class="highlighter-rouge">temp</code> in terms of itself.
When we perform a variable assignment, there are slightly different
rules for what happens on the left side vs. the right side of the
assignment.</p>

<p>For the left, we‚Äôre creating a new local variable ‚Äì pretty much always.</p>

<p>For the right, we‚Äôre <strong>looking</strong> for a value named <code class="highlighter-rouge">temp</code>, and to find
it we‚Äôll follow the same ‚Äúlookup chain‚Äù we mentioned before ‚Äî look for a
local variable called <code class="highlighter-rouge">temp</code>; if it doesn‚Äôt exist, continue up the chain
and look for an instance method called <code class="highlighter-rouge">temp</code>. In this case we‚Äôll find
one (instance variable <code class="highlighter-rouge">temp</code>) and use it!</p>

<h3 id="video">Video</h3>

<p><a href="https://vimeo.com/129376008">Video</a></p>
:ET