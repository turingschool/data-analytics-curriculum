I"}3<h3 id="warm-up">Warm Up</h3>
<p>We’ve already seen one-to-many, one-to-one, and many-to-many relationships. Create a real world example of each of these (with the database schema and all!).</p>

<h3 id="overview">Overview</h3>
<ul>
  <li>Using associations (creating new objects)</li>
  <li>Complex associations</li>
  <li>Self referential relationships</li>
  <li>Polymorphic associations</li>
  <li>Work Time!</li>
</ul>

<h3 id="using-associations">Using Associations</h3>

<p>Let’s say we have the following in our <code class="highlighter-rouge">db/schema.rb</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  create_table "jockeys", force: :cascade do |t|
    t.string   "name"
    t.integer  "number"
    t.integer  "age"
    t.datetime "created_at",      null: false
    t.datetime "updated_at",      null: false
  end

  create_table "jockey_horses", force: :cascade do |t|
    t.integer  "jockey_id"
    t.integer  "horse_id"
    t.datetime "created_at",      null: false
    t.datetime "updated_at",      null: false
  end

  create_table "horses", force: :cascade do |t|
    t.string   "name"
    t.string   "breed"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end

</code></pre></div></div>

<p>We have a many-to-many relationship between a <code class="highlighter-rouge">Jockey</code> and a <code class="highlighter-rouge">Horse</code>. What associations do we need if we want to easily relate a jockey and a horse? Take a second and think about it.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Jockey &lt; ActiveRecord::Base
	has_many :jockey_horses
	has_many :horses, through: :jockey_horses
end

class JockeyHorse &lt; ActiveRecord::Base
	belongs_to :horse
	belongs_to :jockey
end

class Horse &lt; ActiveRecord::Base
	has_many :jockey_horses
	has_many :jockeys, through: :jockey_horses
end
</code></pre></div></div>
<p>How do we test if this is working correctly? I suggest hopping in the Rails console and try to create related objects.</p>

<p>First, let’s create a jockey, and see if we can call our association methods on our jockey object. Remember, every association you write is another method you have access to - and you should use the method!! Or else what’s the point of going through the trouble to create these associations?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jockey = Jockey.create(name: "Penelope", number: 11, age: 24)
jockey.jockey_horses
jockey.horses
</code></pre></div></div>

<p>We can do the same for the other two objects we have (Horse and JockeyHorse). This is just testing to see if we have any broken code - we are not testing that we’ve related our objects correctly yet. In order to do this, let’s create a new <code class="highlighter-rouge">Horse</code> using the association method our associations have given us.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>jockey = Jockey.first
jockey.horses.create(name: "Pablo", breen: "Pony")
</code></pre></div></div>
<p>If you read the SQL output of this statement, we’ll see that it creates a new <code class="highlighter-rouge">Hores</code> object, saves it in our database, and automatically sets this horse’s <code class="highlighter-rouge">jockey_id</code> to the jockey’s <code class="highlighter-rouge">id</code> that we’ve chained this method onto. Now, if we run <code class="highlighter-rouge">jockey.horses</code>, we should see our horse named “Pablo”.</p>

<p>This is exactly what you should be doing within your applications to make use of your associations!</p>

<h3 id="complex-associations">Complex Associations</h3>

<p>ActiveRecord makes two assumptions when you write an association. If one of it’s assumptions are false, your association will NOT work.</p>

<h4 id="has-many">Has Many</h4>
<p>Let’s say you write <code class="highlighter-rouge">has_many :songs</code> in an <code class="highlighter-rouge">Artist</code> class, ActiveRecord is going to expect two things - one is regarding a class name and the other is regarding what the foreign key is called within the related table. With a <code class="highlighter-rouge">has_many</code> association, ActiveRecord looks for a class called the same name (singular though). If we have:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Artist &lt; ActiveRecord::Base
	has_many :songs
end
</code></pre></div></div>

<p>ActiveRecord needs a <code class="highlighter-rouge">Song</code> class to exist. It also needs for <code class="highlighter-rouge">artist_id</code> to be present in the <code class="highlighter-rouge">songs</code> table (this assumption comes from the name of the class we’ve defined this association within - in this case <code class="highlighter-rouge">Artist</code>). If either of these assumptions are not true, we will need to give this association some optional flags.</p>

<p>Let’s pretend we have <code class="highlighter-rouge">author_id</code> in the <code class="highlighter-rouge">songs</code> table instead of <code class="highlighter-rouge">artist_id</code>, we’ll need to tell ActiveRecord to look for a different foreign key like so:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Artist &lt; ActiveRecord::Base
	has_many :songs, foreign_key: :author_id
end
</code></pre></div></div>

<p>If we don’t have a <code class="highlighter-rouge">Song</code> class and we have a <code class="highlighter-rouge">Record</code> class instead, we’ll have to tell ActiveRecord to look for this class instead by adding the following:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Artist &lt; ActiveRecord::Base
	has_many :songs, foreign_key: :author_id, class_name: "Record"
end
</code></pre></div></div>

<p>Now, ActiveRecord will be able to find the correct related data when you as a specific artist for it’s songs.</p>

<h4 id="belongs-to">Belongs To</h4>
<p>Let’s say you write <code class="highlighter-rouge">belongs_to :artist</code> in a <code class="highlighter-rouge">Song</code> class, ActiveRecord is going to expect two things once again - one is regarding a class name and the other is regarding what the foreign key is called within the table we’ve defined the <code class="highlighter-rouge">belongs_to</code> relationship within. Similarly to the <code class="highlighter-rouge">has_many</code> association, with a <code class="highlighter-rouge">belongs_to</code> association ActiveRecord looks for a class called the same name. So, if we have:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Song &lt; ActiveRecord::Base
	belongs_to :artist
end
</code></pre></div></div>

<p>ActiveRecord needs an <code class="highlighter-rouge">Artist</code> class to exist. If we don’t have this class defined, let’s say we’ve called it <code class="highlighter-rouge">User</code> - we’d need to tell ActiveRecord to look for the <code class="highlighter-rouge">User</code> class when querying instead.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Song &lt; ActiveRecord::Base
	belongs_to :artist, class_name: "User"
end

</code></pre></div></div>

<p>ActiveRecord also needs <code class="highlighter-rouge">artist_id</code> to exist within the <code class="highlighter-rouge">songs</code> table - unless we’ve specified a different class name, then it will look in that corresponding table. In this specific case, it will look for <code class="highlighter-rouge">artist_id</code> within the <code class="highlighter-rouge">users</code> table since we’ve specified <code class="highlighter-rouge">class_name: "User"</code>. If we don’t have <code class="highlighter-rouge">artist_id</code> and instead called it <code class="highlighter-rouge">record_id</code>, we would need to specify what foreign key to look for like so:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Song &lt; ActiveRecord::Base
	belongs_to :artist, class_name: "User", foreign_key: :record_id
end

</code></pre></div></div>

<p>ActiveRecord always makes two assumptions. Sometimes the fields in your database may not be the most easy to read or may not be the most representative of our data. We may have been handed down a database from years and years ago and not be able to change it. We want our associations to be easy to read and follow - so sometimes, we’ll need to use <code class="highlighter-rouge">class_name</code> and <code class="highlighter-rouge">foreign_key</code> as optional flags.</p>

<p>A good example might be with a <code class="highlighter-rouge">User</code> and <code class="highlighter-rouge">Article</code>. If a user writes an article, we may want to ask an article who it’s author is rather than who it’s user is. <code class="highlighter-rouge">article.author</code> is much more readable than <code class="highlighter-rouge">article.user</code>.</p>

<h3 id="example-of-complex-associations">Example of Complex Associations</h3>
<ul>
  <li>Teams, Leagues, Users</li>
</ul>

<h3 id="self-referential-relationships">Self Referential Relationships</h3>
<p>The idea of a self-referential relationship is relatively simple: an instance relates to another instance of the same type.</p>

<p>One very popular example of when this might be used is if you have an application with employees and managers. All managers are also employees and all employees have one manager.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  create_table "employees", force: :cascade do |t|
    t.string   "name"
    t.integer  "manager_id"
    t.integer  "age"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end

</code></pre></div></div>

<p>If we have this <code class="highlighter-rouge">employees</code> table and we want to create associations to both find all of specific <code class="highlighter-rouge">Employee</code>’s managed employees as well as their manager, we can write the following associations.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Employee &lt; ActiveRecord::Base
  belongs_to :manager, class_name: "Employee"
  has_many :managed_employees, class_name: "Employee", foreign_key: :manager_id
end
</code></pre></div></div>

<h3 id="polymorphic-associations">Polymorphic Associations</h3>
<p>Polymorphic associations are AWESOME. With polymorphic associations, a model can belong to more than one other model, on a single association. Read through the <a href="http://guides.rubyonrails.org/association_basics.html#polymorphic-associations">documentation</a> before we dive into an example.</p>

<p>Example: Users, Photos, Articles, Comments</p>

<p>Extra Resources:</p>
<ul>
  <li>Start with the Rails Guide: http://guides.rubyonrails.org/association_basics.html#polymorphic-associations</li>
  <li>Watch this old video on RailsCasts (RIP): http://railscasts.com/episodes/154-polymorphic-association</li>
  <li>Check out this newer article that says the same things: http://karimbutt.github.io/blog/2015/01/03/step-by-step-guide-to-polymorphic-associations-in-rails/</li>
</ul>

<h3 id="self-joins">Self Joins</h3>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  create_table "friendships", force: :cascade do |t|
    t.integer  "follower_id"
    t.integer  "followee_id"
    t.datetime "created_at",  null: false
    t.datetime "updated_at",  null: false
  end

  create_table "users", force: :cascade do |t|
    t.string   "name"
    t.string   "user_name"
    t.datetime "created_at", null: false
    t.datetime "updated_at", null: false
  end
</code></pre></div></div>

<p>If we want to be able to call something like the following:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>penelope = User.find_by(name: "Penelope")
penelope.followers
penelope.followings
</code></pre></div></div>

<p>We’ll need the following associations on our <code class="highlighter-rouge">User</code> and <code class="highlighter-rouge">Friendship</code> models.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class User &lt; ActiveRecord::Base
  has_many :follower_friendships, class_name: "Friendship", foreign_key: :followee_id
  has_many :followers, through: :follower_friendships

  has_many :following_friendships, class_name: "Friendship", foreign_key: :follower_id
  has_many :followings, through: :following_friendships
end

class Friendship &lt; ActiveRecord::Base
  belongs_to :follower, class_name: "User"
  belongs_to :followee, class_name: "User"
end
</code></pre></div></div>

<h3 id="putting-it-all-together">Putting it all Together</h3>
<p>Work through the <a href="https://github.com/case-eee/advanced-association-challenge">advanced association challenge</a></p>
:ET