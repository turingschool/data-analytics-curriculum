I"‡'<h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>Understand the concept of a ‚Äúservice‚Äù in software architecture</li>
  <li>Understand how service design relates to OOP principles such as SOLID and SRP</li>
  <li>Understand how services might be used in a typical web application</li>
  <li>Understand some patterns of service design</li>
  <li>Understand the basic role and functionality of a messaging channel</li>
  <li>Understand both the <strong>proxy</strong> and <strong>smart client</strong> approaches to services</li>
</ul>

<h2 id="discussion--software-design">Discussion ‚Äì Software Design</h2>

<p><strong>Q</strong> How could we describe the overall process of designing software?</p>

<ul>
  <li><strong>A</strong> Solving problems by subdividing them into smaller <strong>units</strong> that
can be encapsulated by a specific piece of software</li>
</ul>

<p><strong>Q</strong> What is required to make something a useful software <strong>unit</strong>?</p>

<ul>
  <li>Needs to do some useful work</li>
  <li>Need some way to receive information about what work needs to be done</li>
  <li>Needs some way to communicate information about what it did</li>
</ul>

<p><strong>Q</strong> What are some of the types of units we use to write software?</p>

<ul>
  <li>expressions/statements</li>
  <li>methods</li>
  <li>classes</li>
  <li>libraries (gems)</li>
  <li>applications</li>
</ul>

<h3 id="fractal-design">Fractal Design</h3>

<p>Recall some of the principles we like to think about when analyzing our code:</p>

<ul>
  <li><a href="http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">SRP</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Law_of_Demeter">Law of Demeter</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Open/closed_principle">Open/Closed Principle</a></li>
</ul>

<p>We‚Äôve seen how object-oriented abstractions like methods, classes, and libraries
give us tools to apply these principles in various ways.</p>

<p>It turns out that (good) software systems exhibit the same design principles at
multiple levels of abstraction:</p>

<ul>
  <li>An expression should easily readable and have clear intent</li>
  <li>Methods within a class should be well-factored and concise</li>
  <li>A class should have a clearly defined responsibility which it fully encapsulates and shouldn‚Äôt
leak information unnecessarily</li>
  <li>A library or sub-system within an application should have a well-designed interface, perform some
useful function and be re-useable in multiple contexts</li>
  <li><strong>So what about an entire application?</strong> Does it exhibit these principles as well?</li>
</ul>

<p>Consider your average rails application. There‚Äôs a very good chance that it does:</p>

<ul>
  <li>View templating / rendering</li>
  <li>Data modeling, persistence, and retrieval</li>
  <li>Network I/O</li>
  <li>User authentication</li>
  <li>Background queuing/processing</li>
  <li>Administrative management/reporting</li>
  <li>‚Ä¶ not to mention the actual business logic, which probably involves several problem domains in its own right</li>
</ul>

<p>Why do we adhere so closely to all of these design principles at a micro level (methods, classes, etc.)
but then turn around and build monolithic applications that absorb every responsibility we can
think of?</p>

<p>This is the problem that a service architecture attempts to attack.</p>

<h3 id="definitions-and-concepts">Definitions and Concepts</h3>

<ul>
  <li>A <strong>Service</strong> is an application designed to function as a unit
within a larger application architecture.</li>
</ul>

<p>Remember that as a software <strong>unit</strong>, the service will need to:</p>

<ul>
  <li><strong>1)</strong> Do some chunk of useful work</li>
  <li><strong>2)</strong> Receive information about what work needs to be done</li>
  <li><strong>3)</strong> Communicate information about the work that it did</li>
</ul>

<p>One of the challenges with services is there are practically infinite shapes they
can take. But based on these 3 ideas, we can see that they will vary along 2 common
axes:</p>

<ul>
  <li><strong>How does the service do its work internally?</strong>  (languages</li>
  <li><strong>How does the service communicate with the outside world?</strong></li>
</ul>

<h3 id="common-service-communication-mechanisms">Common service communication mechanisms</h3>

<ul>
  <li>HTTP - probably most common in today‚Äôs world.</li>
  <li>Pub/Sub - Publisher(s) send messages to channel that subscribers listen to</li>
  <li>Queueing - Producers enqueue work to be retrieved by a worker later</li>
</ul>

<p>Common messaging protocols ‚Äì HTTP w/json or XML, SOAP, Thrift, TCP, UDP
Common pubsub/queueing technologies - Redis (e.g. Resque, Sidekiq), Kafka, ZeroMQ, RabbitMQ</p>

<ul>
  <li>HTTP interfaces support great accessibility and tooling, but lower-level interfaces can sometimes offer performance benefits</li>
  <li>A <strong>Message</strong> is an package of data one application communicates with another</li>
  <li>A <strong>Message Service</strong> is the channel which accepts and delivers a message</li>
</ul>

<p>During the next few weeks we‚Äôll probably be working mostly with services that communicate over HTTP or via a Redis queue.
But it‚Äôs good to have an understanding that these represent only a few of the many options out there.</p>

<h3 id="some-example-services-within-an-mvc-application">Some example services within an MVC application</h3>

<h4 id="the-proxy-approach">The Proxy Approach</h4>

<ul>
  <li>Extracting separate web application to encapsulate some portion of data or logic within the system</li>
  <li>Often starts with traditional DB-backed setup, then pulls out a service to wrap a specific
model or set of models</li>
  <li>From the original application data in the service is accessed via a model-like service layer</li>
  <li>The controller and view shouldn‚Äôt know that the service exists (good OO practices and interface design to allow these refactorings to be done transparently)</li>
</ul>

<h4 id="the-smart-browser-client-approach">The Smart (Browser) Client Approach</h4>

<ul>
  <li>Extracting presentation and interaction logic as separate service</li>
  <li>Allows us to incorporate sophisticated JavaScript clients</li>
  <li>The ‚Äúprimary‚Äù app doesn‚Äôt have to know everything ‚Äì remove templating and User Interaction from its responsibilities</li>
  <li>Client application uses the web application as a data store and API</li>
</ul>

<h2 id="identifying-a-service">Identifying a Service</h2>

<p>Good candidates for extraction to a service‚Ä¶</p>

<ul>
  <li>Have limited and known interactions with other parts of the domain logic (easier extraction)</li>
  <li>Are conceptual pieces of value rather than just pieces of functionality</li>
  <li>Could potentially be reused in a different application</li>
  <li>Application components with special performance requirements</li>
  <li>Application components with special language or technology requirements (need to use a tool
in a certain language, but don‚Äôt want to re-write our whole infrastructure in it)</li>
</ul>

<p>Poor candidates for service extraction‚Ä¶</p>

<ul>
  <li>Need access to large pieces of data from the primary application (has its fingers in all the pies ‚Äì makes extraction hard)</li>
  <li>Are reading and writing primary application data (needs lots of direct acces to a DB)</li>
  <li>High ‚Äúback-and-forth‚Äù data flow components ‚Äì can lead to overly ‚Äúchatty‚Äù API interactions</li>
  <li>‚ÄúFat‚Äù data  ‚Äì e.g. very large data-sets ‚Äì can be challenging for traditional transport mechanisms to handle (service extraction may still be possible with data transfer moved offline)</li>
</ul>

<h2 id="exercise---service-identification">Exercise - Service Identification</h2>

<p>Get into small groups and grab a piece of paper and a pen/pencil.</p>

<p>Consider a service-oriented approach to building your assigned application.
In practice we would probably start with a single ‚Äúmonolithic‚Äù app
and refactor it over time ‚Äì but imagine you‚Äôre going to build with services
from the start.</p>

<p>Some example applications to consider:</p>

<ul>
  <li>github</li>
  <li>pivotal tracker or waffle.io</li>
  <li>instagram</li>
  <li>youtube / vimeo</li>
  <li>pinterest</li>
  <li>stackoverflow</li>
  <li>netflix</li>
</ul>

<p>What services would you use? What data would flow between each service? Sketch
out a diagram. You should be able to come up with at least 5 services.</p>

<h3 id="the-pros-and-cons">The Pros and Cons</h3>

<h4 id="pros">Pros</h4>

<ul>
  <li>lower churn</li>
  <li>connect for free / low cost</li>
  <li>failsafe/redundancy</li>
  <li>easier to reason about</li>
  <li>scaling</li>
  <li>reuse</li>
  <li>uncoupled deployment</li>
  <li>reimplement / experiments</li>
</ul>

<h4 id="cons">Cons</h4>

<ul>
  <li>deployment / ops</li>
  <li>versioning</li>
  <li>testing</li>
  <li>http requests (chatty)</li>
  <li>duplication (creating POROs)</li>
</ul>

<h3 id="the-process-of-building-a-service">The Process of Building a Service</h3>

<p>Duplicate, Validate, Delete:</p>

<ol>
  <li>Implement message sending from the primary app</li>
  <li>Build the service to consume those messages</li>
  <li>Validate the functionality of the service in parallel with the primary application</li>
  <li>Remove functionality from the primary application</li>
</ol>

<p>A note on testing and SOA:</p>

<ul>
  <li>Good high-level (integration) test coverage can be invaluable for transitioning to SOA.</li>
  <li>Well-factored tests at the appropriate layers (unit, functional, integration) will allow you to keep an eye on the high-level functionality while having free-reign to swap out backends as needed</li>
  <li>SOA can pose additional challenges for testing in consumer applications ‚Äì standard DB-based setup mechanisms will no longer be sufficient.</li>
  <li>It is often wise to consider building tooling into your service components (especially clients) to make this process easier</li>
</ul>
:ET