I"ÚV<h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>Learn how to measure the performance of Ruby code</li>
  <li>Practice identifying some common patterns associated with inefficient code</li>
  <li>Understand how size of dataset can impact the performance of code</li>
</ul>

<h2 id="agenda">Agenda</h2>

<ul>
  <li>10 min - Warmup / Discussion</li>
  <li>15 min - Time.now, Benchmark</li>
  <li>5 min  - Break</li>
  <li>25 min - Benchmark continued</li>
  <li>5 min  - Break</li>
  <li>25 min - Benchmark exercises (independent)</li>
  <li>5 min  - Break</li>
  <li>15 min - Introduce Profiling Code</li>
  <li>10 min - Ruby profiler exercise (independent)</li>
  <li>5 min  - Break</li>
  <li>15 min - Introduce Ruby-prof</li>
  <li>10 min - Ruby-prof car exercise</li>
  <li>5 min - Wrap up</li>
</ul>

<h2 id="warmup--discussion">Warmup / Discussion</h2>

<ul>
  <li>Discussion: What does ‚Äúbenchmarking‚Äù or ‚Äúprofiling‚Äù mean in the
general case.</li>
  <li>What metrics might we want to profile for an application?</li>
  <li>How do we decide what metrics are most important for our app?</li>
  <li>How does benchmarking reinforce and inform the optimization process?
(Similar to refactoring without tests, without measurement you‚Äôre not optimizing;
you‚Äôre just changing things)</li>
</ul>

<h2 id="whats-in-a-profiling-tool">What‚Äôs in a Profiling Tool?</h2>

<p>In short, all a perf tool needs to be able to do is measure and output
information about a given metric that we‚Äôre interested in.</p>

<p>Most often this metric is ‚Äútime‚Äù, but memory, storage space,
database queries, or network activity are sometimes often of interest.</p>

<p>Perf tools range from very simple to more complex</p>

<ul>
  <li>Simple profiling with Ruby‚Äôs ‚ÄúTime‚Äù class</li>
  <li>Benchmark (built into Ruby)</li>
  <li>Profile (built into Ruby)</li>
  <li>Ruby-Prof (Gem)</li>
</ul>

<h2 id="simplest-benchmark-timenow">Simplest benchmark: Time.now</h2>

<ul>
  <li>In some cases a very simple tool will suffice</li>
  <li>Don‚Äôt forget you can always manually benchmark something by storing
current time and checking against it after running an instruction</li>
</ul>

<p><strong>For example:</strong></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">60</span><span class="p">).</span><span class="nf">to_a</span>
<span class="n">start_time</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span>
<span class="mi">10000</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span> <span class="n">a</span><span class="p">.</span><span class="nf">shuffle</span> <span class="p">}</span>
<span class="nb">puts</span> <span class="s2">"Shuffling took </span><span class="si">#{</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="o">-</span> <span class="n">start_time</span><span class="si">}</span><span class="s2"> seconds"</span>
</code></pre></div></div>

<p>If we find ourselves using it a lot, we can even wrap this in method for
convenience:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">simple_prof</span><span class="p">(</span><span class="nb">name</span><span class="p">)</span>
  <span class="nb">puts</span> <span class="s2">"profiling </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2">"</span>
  <span class="n">start</span> <span class="o">=</span> <span class="no">Time</span><span class="p">.</span><span class="nf">now</span>
  <span class="n">val</span> <span class="o">=</span> <span class="nb">block_given?</span> <span class="p">?</span> <span class="k">yield</span> <span class="p">:</span> <span class="kp">nil</span>
  <span class="nb">puts</span> <span class="s2">"finished </span><span class="si">#{</span><span class="nb">name</span><span class="si">}</span><span class="s2"> in </span><span class="si">#{</span><span class="no">Time</span><span class="p">.</span><span class="nf">now</span> <span class="o">-</span> <span class="n">start</span><span class="si">}</span><span class="s2">"</span>
  <span class="n">val</span>
<span class="k">end</span>

<span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">60</span><span class="p">).</span><span class="nf">to_a</span>
<span class="n">simple_prof</span><span class="p">(</span><span class="s2">"shuffling an array"</span><span class="p">)</span> <span class="k">do</span>
  <span class="mi">100000</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span> <span class="n">a</span><span class="p">.</span><span class="nf">shuffle</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<h2 id="benchmark">Benchmark</h2>

<ul>
  <li><code class="highlighter-rouge">Benchmark</code> tool is part of Standard Library (must be required)</li>
  <li>It offers performance profiling functionality similar to what we
looked at above but with more features and some conveniences that make
it pleasant to use</li>
  <li>set a variable to run code a certain number of times (x = 1_000_000)</li>
</ul>

<p><strong>Several interfaces to <code class="highlighter-rouge">Benchmark</code></strong>:</p>

<ul>
  <li><code class="highlighter-rouge">.realtime</code> ‚Äì similar to what we did above ‚Äì simple real-time
measurement of a block</li>
  <li><code class="highlighter-rouge">.measure</code> ‚Äì measurement of a block, reporting distinct user, system,
total, and real times</li>
  <li><code class="highlighter-rouge">.bm</code> ‚Äì allows us to run a profiling ‚Äúsession‚Äù with multiple sections
of code in a single batch; reports stats similar to <code class="highlighter-rouge">.measure</code></li>
  <li><code class="highlighter-rouge">.bmbm</code> ‚Äì similar to <code class="highlighter-rouge">.bm</code>, but runs an initial ‚Äúrehearsal‚Äù, then
forces the Garbage Collector to run. This protects our results from
being unevenly impacted by the GC.</li>
</ul>

<p><strong>Benchmark.realtime</strong></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">10000</span><span class="p">).</span><span class="nf">to_a</span><span class="p">;</span><span class="kp">nil</span>
<span class="no">Benchmark</span><span class="p">.</span><span class="nf">realtime</span> <span class="p">{</span> <span class="n">a</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:to_s</span><span class="p">).</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:chars</span><span class="p">).</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:rotate</span><span class="p">)</span> <span class="p">}</span>
<span class="o">=&gt;</span> <span class="mf">0.011097</span> <span class="c1"># outputs simple real time measurement in seconds</span>
</code></pre></div></div>

<p><strong>Benchmark.measure</strong></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">100000</span><span class="p">).</span><span class="nf">to_a</span><span class="p">;</span><span class="kp">nil</span>
<span class="no">Benchmark</span><span class="p">.</span><span class="nf">measure</span> <span class="p">{</span> <span class="n">a</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:to_s</span><span class="p">).</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:chars</span><span class="p">).</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:shuffle</span><span class="p">).</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:join</span><span class="p">)</span> <span class="p">}</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Benchmark::Tms:0x007feef2c3b250 @label="", @real=0.329244, @cstime=0.0, @cutime=0.0, @stime=0.020000000000000018, @utime=0.3100000000000005, @total=0.3300000000000005&gt;</span>
<span class="c1"># ^ returns Benchmark::Tms object which stores our measured time</span>
<span class="c1"># output it to a more readable string with to_s</span>
<span class="no">Benchmark</span><span class="p">.</span><span class="nf">measure</span> <span class="p">{</span> <span class="n">a</span><span class="p">.</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:to_s</span><span class="p">).</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:chars</span><span class="p">).</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:shuffle</span><span class="p">).</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:join</span><span class="p">)</span> <span class="p">}.</span><span class="nf">to_s</span>
<span class="o">=&gt;</span> <span class="s2">"  0.310000   0.020000   0.330000 (  0.329244)</span><span class="se">\n</span><span class="s2">"</span>
</code></pre></div></div>

<p><strong>Benchmark.bm</strong></p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">arr</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">100000</span><span class="p">).</span><span class="nf">to_a</span><span class="p">;</span><span class="kp">nil</span>
<span class="no">Benchmark</span><span class="p">.</span><span class="nf">bm</span> <span class="k">do</span> <span class="o">|</span><span class="n">performance</span><span class="o">|</span>
  <span class="n">performance</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s1">'shuffling'</span><span class="p">)</span> <span class="p">{</span> <span class="mi">10</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span> <span class="n">arr</span><span class="p">.</span><span class="nf">shuffle</span> <span class="p">}</span> <span class="p">}</span>
  <span class="n">performance</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s1">'join'</span><span class="p">)</span> <span class="p">{</span> <span class="mi">10</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span> <span class="n">arr</span><span class="p">.</span><span class="nf">join</span> <span class="p">}</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>example output:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       user     system      total        real
shuffling  0.000000   0.000000   0.000000 (  0.004008)
join  0.040000   0.000000   0.040000 (  0.040415)
</code></pre></div></div>

<p><strong>Benchmark.bmbm</strong></p>

<p>Try running the example above a bunch of times in a row. You‚Äôll likely
see from time to time that the times jump quite a bit. This is usually
due to the Garbage Collector kicking in, causing ruby to pause our code
for a moment</p>

<p>In an attempt to standardize benchmark times,
Benchmark.bmbm runs a ‚Äúrehearsal‚Äù, then runs GC.start, then runs the real thing.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">arr</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="mi">100000</span><span class="p">).</span><span class="nf">to_a</span><span class="p">;</span><span class="kp">nil</span>
<span class="no">Benchmark</span><span class="p">.</span><span class="nf">bmbm</span> <span class="k">do</span> <span class="o">|</span><span class="n">performance</span><span class="o">|</span>
  <span class="n">performance</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s1">'shuffling'</span><span class="p">)</span> <span class="p">{</span> <span class="mi">10</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span> <span class="n">arr</span><span class="p">.</span><span class="nf">shuffle</span> <span class="p">}</span> <span class="p">}</span>
  <span class="n">performance</span><span class="p">.</span><span class="nf">report</span><span class="p">(</span><span class="s1">'join'</span><span class="p">)</span> <span class="p">{</span> <span class="mi">10</span><span class="p">.</span><span class="nf">times</span> <span class="p">{</span> <span class="n">arr</span><span class="p">.</span><span class="nf">join</span> <span class="p">}</span> <span class="p">}</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Output:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Rehearsal ---------------------------------------------
shuffling   0.040000   0.000000   0.040000 (  0.035227)
join        0.360000   0.000000   0.360000 (  0.364264)
------------------------------------ total: 0.400000sec

                user     system      total        real
shuffling   0.040000   0.000000   0.040000 (  0.040185)
join        0.330000   0.000000   0.330000 (  0.324359)
</code></pre></div></div>

<h3 id="what-do-these-times-mean-anyway">What do these times mean anyway?</h3>
<ul>
  <li>‚ÄúReal‚Äù time is also known as ‚Äúwall time‚Äù ‚Äì it‚Äôs how much time
a clock on the wall would measure between the start and end of process</li>
  <li>User time is time spent on running our actual code</li>
  <li>System time is the time spent on running system instructions; this
could include reading from the file system</li>
  <li>Total time is User + System time.</li>
  <li>‚ÄúReal‚Äù time is in theory just a sum of User + System time ‚Äì can we
think of a situation when it would be more?</li>
</ul>

<p><strong>a little Unix context:</strong></p>

<p>The convention of reporting these specific numbers comes from the Unix
<code class="highlighter-rouge">time</code> utility. This utility provides an interface similar to Benchmark
but via the command line rather than via ruby.</p>

<p>Try it out in your terminal (not Pry):</p>

<p><code class="highlighter-rouge">time ruby -e "10000.times { (1..10000).to_a }"</code></p>

<p>To see an example with lots of ‚Äúsystem‚Äù time, try reading from the file
system repeatedly:</p>

<p><code class="highlighter-rouge">time ruby -e "400.times { File.read('/usr/share/dict/words'); nil }"</code></p>

<h3 id="benchmarking-exercises">Benchmarking Exercises</h3>

<p>Now that we‚Äôre armed with some tools, practice on your own. One of the
fun things about Benchmarking is that it gives us a cool way to
learn about Ruby experimentally by measuring its behavior.</p>

<p>Clone this <a href="https://github.com/turingschool/performance_of_code">Repo</a>. In
it you‚Äôll find a simple file (<code class="highlighter-rouge">performance_of_code.rb</code>) which contains a
long list of sample code snippets to profile.</p>

<p>Experiment with uncommenting some of the blocks of code and moving them
into a Benchmark block.</p>

<p>Remember that it‚Äôs often useful to experiment with different numbers of
iterations in loops, etc. to see what effect they have on performance of
the code.</p>

<ul>
  <li>Loops</li>
  <li>Combining Strings</li>
  <li>Array Methods</li>
  <li>Destructive vs. Non-Destructive Methods</li>
  <li>Variable assignment</li>
  <li>Accessing data with attr_reader vs. instance variable</li>
  <li>Reading data from file vs. reading data from memory</li>
  <li>Conditional vs. Rescue</li>
</ul>

<h2 id="profiling-code">Profiling Code</h2>

<p>The terms ‚Äúbenchmarking‚Äù and ‚Äúprofiling‚Äù get used somewhat
interchangeably. However we often say ‚Äúbenchmarking‚Äù to refer to
measuring small, isolated sections of code like we saw above.</p>

<p>When we need to measure performance of the entirety of a longer program,
we may want to use another tool known as a ‚Äúprofiler.‚Äù</p>

<p>As a rule of thumb, Benchmarking is most useful if you already have a
piece of code in mind that you want to investigate. A profiler, on the
other hand, can help you look at <strong>all</strong> of your code and figure out
from a distance which pieces might be causing issues.</p>

<ul>
  <li>Profilers are used to determine which methods are called, how many times they are called,
and how long each method is taking.</li>
  <li>Profilers are useful for finding bottlenecks in your code.</li>
  <li>Profilers are often equipped to measure other metrics such as memory
usage.</li>
</ul>

<h4 id="ruby-profiler">Ruby Profiler</h4>

<p>Ruby ships with a builtin profiling library. Let‚Äôs try using it on the
<code class="highlighter-rouge">fib.rb</code> file included in the performance of code repo:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ruby -rprofile fib.rb
</code></pre></div></div>

<p>You should see some lengthy tabular output with information about what
methods are being called and their relative time consumption.</p>

<ul>
  <li>Unlike benchmark which measures specific sections of code, the
profiler measures whole program</li>
  <li>Profiler highlights which methods consume most time in the program,
helping us isolate bottlenecks</li>
  <li>Often useful as a first step. Once we have a sense of where the
problem is, we can add custom benchmarks to get even more specific</li>
  <li>Reading a profile effectively takes practice</li>
  <li>Try to isolate the parts that are most important (and that you have
control over) from those parts that are incidental noise</li>
</ul>

<h4 id="your-turn---ruby-profiler">Your Turn - Ruby Profiler</h4>

<p>Try using the <code class="highlighter-rouge">-rprofile</code> flag on the included <code class="highlighter-rouge">car.rb</code> file.</p>

<p>See if you can make sense of the output.</p>

<p>Do you notice any particular bottlenecks?</p>

<h4 id="ruby-prof-gem">Ruby-Prof Gem</h4>

<p>The built-in ruby profiler is pretty good, but for even more in-depth analysis,
we can turn to the ruby-prof gem.</p>

<p>This library includes similar profiling features to the <code class="highlighter-rouge">-rprofile</code> ruby
flag, but it has the ability to display the information in some more
interesting formats.</p>

<ul>
  <li>To see how it works, let‚Äôs check out the example <code class="highlighter-rouge">fib_ruby_prof.rb</code> file.</li>
  <li>Try running the file, then check out the output that‚Äôs appeared in the
<code class="highlighter-rouge">tmp</code> directory in the project</li>
  <li>Notice ruby-prof includes several ‚Äúprinters‚Äù that output profile
information in different formats</li>
  <li>Some cool ones are <code class="highlighter-rouge">profile.stack.html</code> and <code class="highlighter-rouge">profile.graph.html</code></li>
</ul>

<p><strong>Dot Printer</strong></p>

<p>Let‚Äôs experiment with another cool printer called the ‚ÄúDot Printer‚Äù.
Try tweaking the code at the bottom of <code class="highlighter-rouge">fib_ruby_prof.rb</code> to use
this printer instead:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  printer = RubyProf::DotPrinter.new(result)
  File.open("./tmp/profile.dot", "w") do |f|
    printer.print(f)
  end
</code></pre></div></div>

<p>This should create 1 more file under tmp, a file called ‚Äúprofile.dot‚Äù</p>

<p>‚Äú.dot‚Äù is a format used for modeling graphs. We can use the unix utility
<code class="highlighter-rouge">dot</code> to transform it into a more readable format like a PDF:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dot -T pdf -o ./tmp/profile.pdf ./tmp/profile.dot
open ./tmp/profile.pdf
</code></pre></div></div>

<p><strong>Note</strong> ‚Äì if you don‚Äôt have the <code class="highlighter-rouge">dot</code> command on your computer (you get a ‚Äúcommand not found‚Äù error when trying to run it), install the graphviz package using homebrew:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew install graphviz
</code></pre></div></div>

<p>If everything has worked, you should see a PDF open which shows a
graphical call stack of our fib program. In this case the call stack is
quite minimal, but notice how many recursive calls to the fib method
there are. Holy exponential growth orders, Batman!</p>

<h4 id="your-turn---profiling-exercise">Your Turn - Profiling Exercise</h4>

<p>Now that you‚Äôve had some exposure to ruby-prof, try it out with the Car
class that we looked at before. Try wrapping the section of code at the
bottom of the file with the RubyProf gem.</p>

<p>You can refer to the <code class="highlighter-rouge">fib_ruby_prof.rb</code> example as a reference.</p>

<ul>
  <li>Can you identify any particular bottlenecks in our Car?</li>
  <li>Are there methods that take a disproportionate percentage of time
relative to their importance?</li>
</ul>

<h2 id="addendum">Addendum</h2>

<p>Note, when I (Cheek) taught this lesson, I based it 80+% off this lesson plan,
but wound up aggregating our notes in <a href="https://gist.github.com/JoshCheek/e4afb1d9e1c2fc72603b">a different repo</a>
(it helps me synthesize my thoughts).  So if you‚Äôre teaching it, you can also reference that repo.</p>
:ET