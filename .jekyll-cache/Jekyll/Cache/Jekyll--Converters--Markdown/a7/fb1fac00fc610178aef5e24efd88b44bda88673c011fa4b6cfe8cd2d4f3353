I"ﬂ<h1 id="caching-data">Caching Data</h1>

<h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>Discuss differences between Fragment/Template Caching and Data Caching</li>
  <li>Understand how data caching can used to speed up slow computations</li>
  <li>Practice using Redis to store cached data</li>
</ul>

<h2 id="structure">Structure</h2>

<ul>
  <li>Discussion: Data Caching Concepts</li>
  <li>Tutorial: <a href="http://tutorials.jumpstartlab.com/topics/performance/caching_data.html">http://tutorials.jumpstartlab.com/topics/performance/caching_data.html</a></li>
</ul>

<h2 id="discussion">Discussion</h2>

<p>When adding caching to web applications, we can think of 2 general approaches available:</p>

<ul>
  <li>Cache the ‚Äúend result‚Äù of a request, thus speeding things up by skipping whatever
  computations would have been required to generate the result.</li>
  <li>Cache the results of the individual computations needed to generate the response, thus
  making it fast to re-generate when needed.</li>
</ul>

<p><strong>Fragment Caching ‚Äì Approach A</strong></p>

<p>So far we have looked at Template or ‚Äúfragment‚Äù caching, which falls into the first category. Ultimately
your web application is a fancy apparatus for taking inputs via HTTP and returning
an HTTP Response (generally containing HTML or JSON). Thus caching portions of the HTML or JSON itself
represent caching the ‚Äúend product‚Äù. If the HTML you need is already available in a cache, we don‚Äôt need
to do whatever computations were required to generate it in the first place.</p>

<p><strong>Data Caching ‚Äì Approach B</strong></p>

<p>Today, we‚Äôre going to look at another approach which focuses on using caching to speed up individual
computations or pieces of information rather than caching the final chunk of rendered markup.
If your page spends 90% of its time processing 2 expensive methods, we can imagine how much faster
the action would be if we could simply retrieve the results of our expensive methods from a cache.
Even though we may still need to re-render some markup, this is generally quite fast as long as
the required data is readily available.</p>

<h3 id="when-to-data-cache">When to Data Cache</h3>

<p>In order to get a better idea of which situations are well-suited to data caching, let‚Äôs
think about some of the downsides of Fragment Caching:</p>

<ul>
  <li>Not very granular (have to grab a whole swath of markup and whatever data is included with it)</li>
  <li>Not applicable to other contexts (sharing data between API and HTML endpoints; sharing data between
  web responses and offline tasks)</li>
  <li>Difficult to ‚Äúset‚Äù data from other contexts (e.g. pre-generating cached data)</li>
</ul>

<p>The big advantage data caching gives us over caching markup is granularity and specificity.
With data caching its easy to isolate slow actions to the smallest possible context, and then
cache them accordingly. (We‚Äôll often cache data at a method level)</p>

<p>Additionally, when caching data, we‚Äôre working with more general or universal formats ‚Äì i.e. Integers,
Strings, Lists/Sets. This is good especially in a larger application because its much more
likely to be re-useable in another context. Your JSON API is not able to get much benefit
from the blobs of HTML cached by your templates. But it <em>can benefit</em> from re-using more general
data cached at an object or method level.</p>

<p>In general, moving our caching to a data layer rather than a view layer gives us more flexibility
to access the data from other contexts.</p>

<p>Want to re-use the cached data between different response
formats or API versions? Simply access the same methods from your appropriate controllers or templates.</p>

<p>Want to make sure your requests never hit a ‚Äúcold‚Äù cache? We could design a system where the application
only Reads from the cache, and there is a separate offline process (often a cron job or background worker)
which refreshes the data on a regular basis. This would be challenging if the offline job needed
to access the application‚Äôs templates and view-layer logic to render complete HTML, but
if all that is required are simple data types, then it is fairly simple.</p>

<p>Similarly, we could imagine larger architectures with multiple applications reading from the same
data cache (perhaps even from multiple languages or application frameworks).</p>

<h3 id="what-kinds-of-data-are-good-to-cache">What kinds of data are good to cache?</h3>

<p>In general we want to be writing the simplest data possible into our caches.
This means:</p>

<ul>
  <li>Basic data types are best ‚Äì integers and strings</li>
  <li>If you need to cache a more complex data structure,
  consider serializing it to JSON and storing the string
  representation</li>
</ul>

<h2 id="your-turn--data-caching-tutorial">Your Turn ‚Äì Data Caching Tutorial</h2>

<p>Now that we‚Äôve discussed some of the larger concepts behind caching data,
try it yourself with the <a href="http://tutorials.jumpstartlab.com/topics/performance/caching_data.html">Caching Data Tutorial</a>. This tutorial takes us through using Redis as a data cache
to speed up the slow computations on the JSBlogger Dashboard Page.</p>

<p>In this example, we‚Äôll see how the Blogger Dashboard is a good
fit for data caching because it involves numerous statistics
that are expensive to calculate but can be represented easily
as simple data (strings or integers) and accessed through
standard method interfaces (<code class="highlighter-rouge">Article.total_word_count</code>, etc).</p>
:ET