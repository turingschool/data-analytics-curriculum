I"	Ö<h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>Discuss performance limitations of database queries with regard to
increased DB scale and load</li>
  <li>Discuss common ActiveRecord techniques for managing increased database scale.</li>
  <li>Practice using each technique against a large JSBlogger dataset</li>
  <li>See some techniques for handling less common, more complicated
ActiveRecord queries</li>
  <li>Get more practice expressing complex relational logic via ARel</li>
</ul>

<h2 id="setup---blogger-with-db-load">Setup - Blogger with DB Load</h2>

<p>For this lesson, we‚Äôll use a special branch of blogger configured with a large
dataset. Set this up like so:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone -b blogger-perf-workshop https://github.com/JumpstartLab/blogger_advanced.git
cd blogger_advanced
bundle
rake sample_data:load
</code></pre></div></div>

<p>You should see some postgres output running through your terminal. Once
it‚Äôs done, fire up your rails console and check the <code class="highlighter-rouge">count</code> of the Comment
model. You should have a lot (300k+) of them.</p>

<h2 id="discussion---sql-performance-limitations">Discussion - SQL Performance Limitations</h2>

<h3 id="q-why-are-developers-so-concerned-with-database-performance">Q: Why are developers so concerned with database performance?</h3>

<p>If you follow much of the tech (and especially web development) blog/think-o-sphere,
you‚Äôll probably notice lots of discussion around database performance limitations and
optimizations. It appears as a frequent topic of interview questions, blog posts, conference
talks, etc.</p>

<p>Let‚Äôs discuss a few reasons why:</p>

<ul>
  <li>At a high level, how might we describe the ‚Äúarchitectural shape‚Äù of most web apps?
(DB-heavy; low algorithmic complexity; HTTP necessitates lots of i/o even for repeated reqs)</li>
  <li>How would we describe the performance profile of most (naive) SQL operations?
(find on 10 rows vs find on 10000 rows? where on 10 rows vs where on 10000 rows?)</li>
</ul>

<p>(<strong>Demo - Slow Queries on Blogger Dataset</strong>)</p>

<p>Students should watch as instructor demonstrates a few queries against the large blogger
dataset.</p>

<p>Especially focus on:</p>

<ul>
  <li>Some operations will scale consistently (i.e. constant time) ‚Äì last, first, count, find (indexed)</li>
  <li>Some operations will scale linearly with number of rows (where, find_by)</li>
</ul>

<p>Example: <code class="highlighter-rouge">Article.find_by(title: Article.last.title)</code></p>

<p>On master w/10 rows (sqlite)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>irb(main):001:0&gt; Article.find_by(title: Article.last.title)
  Article Load (0.1ms)  SELECT  "articles".* FROM "articles"   ORDER BY "articles"."id" DESC LIMIT 1
  Article Load (0.2ms)  SELECT  "articles".* FROM "articles"  WHERE "articles"."title" = 'Suscipit Dolores Nihil Et Vero Soluta 9' LIMIT 1
=&gt; #&lt;Article id: 10, title: "Suscipit Dolores Nihil Et Vero Soluta 9", body: "Earum amet voluptatum sunt. Qui doloribus laborum ...", created_at: "2015-07-08 18:57:43", updated_at: "2015-07-13 01:57:43", author_id: 3&gt;
</code></pre></div></div>

<p>On perf branch with 70k rows (postgres)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>irb(main):001:0&gt; Article.find_by(title: Article.last.title)
  Article Load (1.6ms)  SELECT  "articles".* FROM "articles"   ORDER BY "articles"."id" DESC LIMIT 1
  Article Load (17.1ms)  SELECT  "articles".* FROM "articles"  WHERE "articles"."title" = 'Non Harum Nemo Culpa In Id 70000' LIMIT 1
=&gt; #&lt;Article id: 70001, title: "Non Harum Nemo Culpa In Id 70000", body: "Velit ut veniam dolorem. Molestiae qui aut laudant...", created_at: "2015-04-02 14:16:42", updated_at: "2015-04-27 02:16:42", author_id: 3347&gt;
</code></pre></div></div>

<p>Example: <code class="highlighter-rouge">Comment.where(article_id: 7).count</code></p>

<p>On master w/10 rows (sqlite)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>irb(main):004:0&gt; Comment.where(article_id: 7).count
   (0.3ms)  SELECT COUNT(*) FROM "comments"  WHERE "comments"."article_id" = 7
=&gt; 6
</code></pre></div></div>

<p>On perf branch with 340k rows (postgres)</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>irb(main):008:0&gt; Comment.where(article_id: 7).count
   (55.3ms)  SELECT COUNT(*) FROM "comments"  WHERE "comments"."article_id" = 7
   =&gt; 7
</code></pre></div></div>

<h3 id="a-it-turns-out-that">A: It turns out that:</h3>

<ul>
  <li>An average web app is very database reliant ‚Äì at their core most of them are just
tools for displaying information from a data store and inserting it back in.</li>
  <li>The performance of SQL operations is relatively <em>inelastic</em>. The baseline often gives
great perf for small datasets, but for larger datasets the linear time growth is unacceptable.</li>
</ul>

<h3 id="q-what-about-database-load">Q: What about database ‚Äúload‚Äù?</h3>

<ul>
  <li>What‚Äôs the difference between performance of a single query and load/performance of the entire DB?</li>
  <li>What sort of limitations might we run into as the DB <em>load</em> increases? (Even if avg query
time is relatively good)</li>
</ul>

<h3 id="a-a-db-is-also-relatively-inelastic-from-the-perspective-of-load-as-well">A: A DB is also relatively inelastic from the perspective of load as well</h3>

<p>Consider the <code class="highlighter-rouge">Comment.where(article_id: 7).count</code> example above. If our avg
query time is <code class="highlighter-rouge">0.3 ms</code> for that query, how many can we run in a second?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1000 ms / 0.3 ms per query = 3,333 queries per second
</code></pre></div></div>

<p>Not bad.</p>

<p>What about in the slower example?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1000 ms / 55 ms per query = 18 queries per second
</code></pre></div></div>

<p>Unsurprisingly, that‚Äôs a lot less. But most importantly, what happens
if we start to go <em>over</em> 18 queries per second?</p>

<p>With some exceptions (parallel query access, etc) a DB does have hard limits
to how much it can process in a given amount of time. Surpass that limit, and it
just can‚Äôt keep up ‚Äì the query queue will start to grow, so that even a query
which by itself takes 20 ms will take 80 ms to get processed.</p>

<p>Since queries are ultimately triggered by user requests, this means users are
waiting as well, and the whole thing crawls toward a standstill. This brings
us to the dreaded web application database bottleneck, and explains
why it‚Äôs such an important topic in web application performance and
architecture discussions.</p>

<p>(example anecdote ‚Äì infamous twitter fail whale and world cup 2008)</p>

<h2 id="avoiding-the-db-bottleneck--sql-and-activerecord-performance-techniques">Avoiding the DB Bottleneck ‚Äì SQL and ActiveRecord Performance Techniques</h2>

<p>Fortunately this doesn‚Äôt have to be us. Modern databases are quite powerful and
give us a lot of tuning and optimization tools. All we have to do is learn them.</p>

<p>Let‚Äôs talk through a few of these:</p>

<ol>
  <li>Measuring and Analyzing Queries (if you can‚Äôt measure it, you can‚Äôt fix it)</li>
  <li>Improving query times with indexing</li>
  <li>Removing N+1 queries with <code class="highlighter-rouge">ActiveRecord::Base.includes</code></li>
  <li>Reducing query size with <code class="highlighter-rouge">select</code> and <code class="highlighter-rouge">pluck</code></li>
  <li>Consolidating data storage with hstore / json</li>
</ol>

<h2 id="1-measuring-and-analyzing-queries">1. Measuring and Analyzing Queries</h2>

<p>As with all performance work, when tuning a DB we want to focus our
efforts on the ‚Äúbiggest wins‚Äù, i.e. the bottlenecks. Optimizing
a query that takes 0.5 ms probably won‚Äôt help our application much,
but optimizing one that takes 1 s will.</p>

<p>Additionally, ActiveRecord can sometimes take us by surprise with the
queries it generates, so we‚Äôll look at some tools for getting more
detail about what exactly ActiveRecord plans to do in response to a
given query.</p>

<p>Let‚Äôs look at a few tools:</p>

<ol>
  <li>ActiveRecord built-in query logging</li>
  <li>NewRelic / Skylight query tracking</li>
  <li>ActiveRecord#to_sql</li>
  <li>ActiveRecord#explain</li>
</ol>

<h4 id="1-log-file--console">1. Log File &amp; Console</h4>

<p>In Rails 3.2+, ActiveRecord logs query strings and query times of
all SQL it executes. This information will appear both in application</p>

<p><strong>Exercise (5 minutes): Using SQL Query Time output</strong></p>

<p>Students use ActiveRecord from the Blogger rails console to find the following information, and note
the reported query times:</p>

<ol>
  <li>The last article ordered by <code class="highlighter-rouge">created_at</code> date</li>
  <li>The first Comment</li>
  <li>All comments attached to the article with the title ‚ÄúEarum Sequi Labore A Corporis Tenetur 66999‚Äù</li>
  <li>All comments posted by the author ‚ÄúBrayan Larkin‚Äù</li>
</ol>

<h4 id="2-rpm">2. RPM</h4>

<p>Within New Relic‚Äôs RPM, you can look into the ‚ÄúDetails‚Äù of a request and drill down into the SQL.
If you want to know where a query came from, look for the ‚ÄúRails‚Äù link and scan through the stack trace.</p>

<p><strong>Exercise (10 minutes): Use Newrelic in Dev Mode to View Queries</strong></p>

<ol>
  <li>Start your rails server and visit a sample article page (e.g. <a href="http://localhost:3000/articles/68">http://localhost:3000/articles/68</a>)</li>
  <li>Visit the <a href="http://localhost:3000/newrelic">development newrelic page</a></li>
  <li>Find the Article#show request you made and click the ‚ÄúShow SQL‚Äù link to view sql statements</li>
  <li>Find the 3 slowest queries from the request.</li>
  <li>Open the blogger source. Starting from the Controller and working down into the Views,
try to guess which specific pieces of code triggered the 3 queries you saw in the SQL log.</li>
</ol>

<h4 id="3-to_sql">3. <code class="highlighter-rouge">to_sql</code></h4>

<p><code class="highlighter-rouge">ActiveRelation#to_sql</code> returns a string of the literal SQL used to generate that relation.</p>

<p>This can be a really excellent tool for understanding how adding more ARel method calls and parameters affect the resulting SQL.</p>

<p><strong>Demo: instructor demonstrates using to_sql on a few basic queries</strong></p>

<p><strong>Exercise (3 minutes): Using to_sql</strong></p>

<p>Try running <code class="highlighter-rouge">to_sql</code> on some queries in the console. Experiment
with several different queries to find:</p>

<ol>
  <li>A query that uses <code class="highlighter-rouge">SELECT some_table.*</code> in its execution</li>
  <li>A query that uses a <code class="highlighter-rouge">WHERE</code> clause in its execution</li>
  <li>A query that uses an <code class="highlighter-rouge">ORDER BY </code> clause in its execution</li>
</ol>

<h4 id="4-explain">4. <code class="highlighter-rouge">explain</code></h4>

<p>Viewing the raw SQL for a query can be a good place to start debugging it, but there‚Äôs actually
more to a query than just a string of SQL statements.</p>

<p>Under the hood, the database is responsible for reading strings of
SQL statements and fetching the requested data from its storage.</p>

<p>It does this by generating a ‚Äúquery plan‚Äù ‚Äì a type of algorithm describing
the steps needed to find a given piece of data.</p>

<p>This can also be a useful piece of information to have when troubleshooting
queries, and fortunately ActiveRecord makes it available to us
via the <code class="highlighter-rouge">.explain</code> method.</p>

<p><strong>Demo: instructor demonstrates using explain on a few basic queries</strong></p>

<p><strong>Exercise: SQL explain</strong></p>

<p>Use Arel to write queries for the following pieces of information:</p>

<ol>
  <li>The <em>second 5</em> articles</li>
  <li>The article with ID 70000 (note: you won‚Äôt be able to use explain with <code class="highlighter-rouge">find_by</code>, so you may need to rephrase this query using <code class="highlighter-rouge">where</code>)</li>
  <li>The <em>first 3</em> comments with Article ID 2</li>
</ol>

<p>Then use <code class="highlighter-rouge">explain</code> on each query and note the response ActiveRecord gives you.</p>

<p><strong>Discussion: Query Plan Types ‚Äì Sequential Scan vs Index</strong></p>

<h2 id="2-improving-performance-with-indices">2. Improving Performance with Indices</h2>

<p>What difference did we notice using SQL Explain between
finding articles by ID vs just grabbing 5 in order out of the table?</p>

<p>An index is one of the easiest ways to improve performance when querying
your tables.</p>

<p><strong>Discussion: How is an Index like a Hash?</strong></p>

<p><strong>Demo: Instructor Demos Hash vs. Array retrieval perf while adding records</strong></p>

<p><strong>Discussion: Instructor talks through the points about indices <a href="http://tutorials.jumpstartlab.com/topics/performance/queries.html#indices">here</a></strong></p>

<p><strong>Exercise: Indexing Comments on Article ID</strong></p>

<p>One of the most common types of columns to index is a foreign key. This
provides a lot of benefit because we tend to query on these columns frequently.</p>

<p>For example, consider how we look up the comments associated with a given
article. Using ActiveRecord, we can simply request <code class="highlighter-rouge">Article.find(2).comments</code>.</p>

<p>But at the database layer, this requires a query which goes through the comments
table and pulls out all the rows with a matching <code class="highlighter-rouge">article_id</code> of 2.</p>

<p>Practice indexing using this example.</p>

<ol>
  <li>Check the current SQL methodology for finding article-related comments
by using <code class="highlighter-rouge">.explain</code> to explain the query for finding all comments
associated with the first article.</li>
  <li>Generate a migration to add an index to the <code class="highlighter-rouge">comments</code> table on the
<code class="highlighter-rouge">article_id</code> column.</li>
  <li>Run the migration then re-try the query from before. Note the change
in the SQL explanation.</li>
</ol>

<h2 id="3-removing-n1-queries-using-includes">3. Removing N+1 Queries using <code class="highlighter-rouge">includes</code></h2>

<p>Sometimes we run into performance trouble not from the speed of a single
query but from the <em>number</em> of queries a piece of code generates.</p>

<p>This is often called an <strong>N+1</strong> query. To understand why, let‚Äôs look
at an example.</p>

<p><strong>Exercise: Students Generate an N+1 Query</strong></p>

<p>In your Rails console, write a piece of code that does the following:</p>

<ol>
  <li>Find the first 5 Articles</li>
  <li>For each article: <strong>a)</strong> Print its title to the terminal and <strong>b)</strong> For each of its comments, print the comment‚Äôs Author Name</li>
  <li>Scan through the terminal output this produces and pull out the lines
indicating query executions. What do you notice about them?</li>
</ol>

<p><strong>Discussion: N+1 - name and symptoms</strong></p>

<p><strong>Discussion: Includes as an ActiveRecord Feature</strong></p>

<p>One thing to keep in mind is that many of the features (especially indexing
and SQL explaining) we‚Äôve been looked at are things baked into the
database engine which ActiveRecord simply gives us a convenient interface
to.</p>

<p><code class="highlighter-rouge">ActiveRelation.includes</code> is a convenient feature to help us eliminate N+1
queries by moving a bunch of small queries into a single bulk query.</p>

<p>However this is something implemented at the Ruby / ActiveRelation layer rather
than something baked specially into the DB.</p>

<p>When using <code class="highlighter-rouge">.includes</code>, ActiveRecord <em>automatically</em> makes a second query on our
behalf. This helps us avoid the N+1 scenario because it take ssomething that
was previously:</p>

<ul>
  <li>1 query for a collection of articles</li>
  <li>A bunch (N) of small queries for groups of comments</li>
</ul>

<p>and turns it into:</p>

<ul>
  <li>1 query for a collection of articles</li>
  <li>1 query for a bunch of comments associated with those articles</li>
</ul>

<p><strong>Without includes:</strong></p>

<ol>
  <li>Make a query for a collection of articles</li>
  <li>Start iterating through the articles</li>
  <li>Make a query for the comments attached to the current article</li>
  <li>Do something with the comments</li>
  <li>Repeat 2 through 3 until we run out of articles</li>
</ol>

<p><strong>With includes:</strong></p>

<ol>
  <li>Make a query for a collection of articles</li>
  <li>ActiveRecord automatically generates a query to fetch all
comments associated with those specific articles</li>
  <li>Iterate through the articles</li>
  <li>Iterate through the comments attached to the current article,
but we don‚Äôt need to make a query since AR already did it for us</li>
  <li>Repeat 3-4</li>
</ol>

<p><strong>Exercise: Use includes to avoid N+1 queries in previous example</strong></p>

<p>Re-write your console printing snippet of code to use
<code class="highlighter-rouge">includes</code>. Read through all the lines of output produces, and
note the lines representing query executions. Are they different
from our initial example? How? Is the overall time faster?</p>

<h2 id="4-saving-time-by-fetching-less-data--pluck-and-select">4. Saving Time by Fetching Less Data ‚Äì <code class="highlighter-rouge">pluck</code> and <code class="highlighter-rouge">select</code></h2>

<p>So far we‚Äôve looked at a technique to re-structure the way the DB engine
retrieves data we request (indexing) and a way to get ActiveRecord to
generate more optimal query patterns on our behalf (inclusion).</p>

<p>The next techniques are perhaps more subtle, but allow us
to gain a bit of extra performance in some situations by limiting
the amount of data we retrieve from the database.</p>

<p><strong>Exercise: Identify What Data an Average ARel Query Retrieves</strong></p>

<ol>
  <li>In console, generate a query to fetch the last 6 comments.</li>
  <li>Read the SQL output for the generated query.</li>
  <li>What columns is ARel fetching from the table on our behalf? How do we know?</li>
</ol>

<p><strong>Exercise: Executing Raw SQL via the AR Adapter</strong></p>

<p>So far we‚Äôve interacted with ActiveRecord exclusively through its
Ruby interface (<code class="highlighter-rouge">where</code>, <code class="highlighter-rouge">limit</code>, <code class="highlighter-rouge">order</code>, <code class="highlighter-rouge">take</code>, etc). But it also
provides us with a mechanism for executing raw SQL if we wanted to.</p>

<p>This is done using the method <code class="highlighter-rouge">#execute</code> on our ActiveRecord ConnectionAdapter.
We can access this via <code class="highlighter-rouge">ActiveRecord::Base.connection.execute</code>.</p>

<ol>
  <li>Read the console output from the previous example (find last 6 comments) again
and identify the SQL statement it executed</li>
  <li>Use <code class="highlighter-rouge">ActiveRecord::Base.connection.execute</code> to execute this SQL statement yourself.
Note that the console output may include some string sanitization that you will want
to omit when executing the SQL yourself.</li>
  <li>Call <code class="highlighter-rouge">#to_a</code> on the results to retrieve them as Ruby objects</li>
  <li>What type of results do you get back? How are these different from the normal
AR objects we‚Äôre used to getting back from our queries?</li>
</ol>

<p><strong>Discussion: ARel default queries and deserialization</strong></p>

<ul>
  <li>Why does ARel default to retrieving all columns?</li>
  <li>What type of objects do we get back from a standard ARel query?</li>
  <li>What work is ARel doing behind the scenes to make this work?</li>
  <li>In what scenarios might we be able to do without those objects / use
a more simplified version of the data?</li>
</ul>

<p><strong>Demo: Instructor Demonstrates using Pluck / Select to limit data access</strong></p>

<p>Main Points</p>

<ul>
  <li>Pluck and Select can be easily chained onto other ARel queries</li>
  <li>Select is not used as frequently ‚Äì sometimes surprising to get an ActiveRecord
object without all of its attributes (<code class="highlighter-rouge">MissingAttributeError</code>) so watch out for that</li>
  <li>Pluck is great when you‚Äôre going to fetch some records then iterate through them
and only use certain attributes (e.g. <code class="highlighter-rouge">Comment.all.map(&amp;:body)</code> ‚Äì just use <code class="highlighter-rouge">pluck</code>)</li>
</ul>

<p><strong>Exercise: Use Pluck</strong></p>

<ol>
  <li>Use pluck to fetch only the bodies of Comments attached to articles 7,9,182,and 6009</li>
  <li>Use pluck to fetch only the titles of Articles written by the 587th Author</li>
</ol>

<h2 id="5-consolidating-queries-by-rethinking-data-storage">5. Consolidating Queries by Rethinking Data Storage</h2>

<p>As a general rule, we tend to store data in small, relatively ‚Äúatomic‚Äù chunks
in our DB. This idea is sometimes referred to as Database ‚Äúnormalization‚Äù.</p>

<p>But in some scenarios it can impose performance overhead, especially if we require
a lot of columns to store a loosely organized or ‚Äúsparse‚Äù dataset.</p>

<p>Alternatively, we can sometimes suffer from overhead for frequently fetching data
which may not actually change much (if ever).</p>

<p>We can often reduce these problems by re-structuring some of our approaches to
how the data is modeled and stored in the DB.</p>

<h4 id="example-1-using-static-storage-for-frequently-queried-static-data">Example 1: Using Static Storage for Frequently Queried Static Data</h4>

<p>Many applications have sets of static data that don‚Äôt change.  A common example would be a list of state names with abbreviations to be used in a form. Our first thought might be to store this in a ‚ÄúStates‚Äù table with a <code class="highlighter-rouge">state name</code> and <code class="highlighter-rouge">state abbrev</code> column.</p>

<p>But if your app uses this data a lot, this will mean a lot of trips to the Database for
information which actually doesn‚Äôt change (and hence doesn‚Äôt really need the mutability
that a databse provides).</p>

<p>Data like this can often be pulled out into a static constant, perhaps in a model
or an initializer.</p>

<h3 id="static-data">Static Data</h3>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="c1"># config/initializers/states.rb</span>
<span class="no">STATE_ABBREVIATIONS</span> <span class="o">=</span> <span class="p">{</span>
  <span class="s2">"MD"</span> <span class="o">=&gt;</span> <span class="s2">"Maryland"</span><span class="p">,</span>
  <span class="s2">"ME"</span> <span class="o">=&gt;</span> <span class="s2">"Maine"</span><span class="p">,</span>
  <span class="o">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Thanks to the global accessibility of ruby constants, this <code class="highlighter-rouge">STATE_ABBREVIATIONS</code> hash
is now accessible everywhere in the application.</p>

<h4 id="example-2-serialized-columns">Example 2: Serialized Columns</h4>

<p>Another possible way to restructure your data is to serialize structures such as arrays
or hashes into a single column in the table.</p>

<p>Data stored in this way is relatively ‚Äúschema-less‚Äù, meaning there are no rigid
expectations on its shape as there would be with normal, typed DB columns.</p>

<p>This can give us a lot of flexibility to store data whose shape we may not entirely
know in advance. It also gives us a way to capture some of the flexibility of a ‚ÄúNOSQL‚Äù
datastore within our existing relational DB.</p>

<p><strong>Exercise: Serializing Article Metadata to the DB</strong></p>

<ol>
  <li>Generate a migration to add a new column called <code class="highlighter-rouge">metadata</code> to the Articles table. Its type
should be <code class="highlighter-rouge">string</code>.</li>
  <li>Migrate the DB</li>
  <li>Set up the appropriate serialization logic in the model by
telling ActiveRecord to <code class="highlighter-rouge">serialize :metadata</code> in the Article class</li>
  <li>Create a new article (or update an existing one), giving it some
metadata of <code class="highlighter-rouge">{read_on: Date.today, rating: 5}</code>. Save the article</li>
  <li>Reload the article and inspect its <code class="highlighter-rouge">metadata</code> attribute. What
is the format of this object?</li>
</ol>

<p><strong>See Also: HStore Postgres extension</strong></p>

<h3 id="appendinx--addenda--miscellany">Appendinx / Addenda / Miscellany</h3>

<h4 id="recap-quiz">Recap Quiz</h4>

<p>Go through the questions in this quiz to see how much you remember from
the previous session (none of this is tracked or graded; it‚Äôs just a tool to help jog your memory): https://turing-quiz.herokuapp.com/quizzes/query-perf-recap.</p>

<h4 id="more-exercises">More Exercises</h4>

<p>Let‚Äôs get some more hands-on experience with improving query performance
by working through the exercises in the tutorial: <a href="http://tutorials.jumpstartlab.com/topics/performance/queries.html#exercises">http://tutorials.jumpstartlab.com/topics/performance/queries.html#exercises</a></p>

<h4 id="recap-joins-vs-includes">Recap: Joins vs. Includes</h4>

<p>Recall that <code class="highlighter-rouge">#includes</code> is a handy technique for avoiding N+1 queries by
pre-fetching associated data.</p>

<p>Consider our previous example using comments and approvals:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>a = Article.includes(comments: :approval).first
a.comments.select{|c| c.approved?}.count
</code></pre></div></div>

<p>Here we are actually pre-fetching data for 2 related models along with
our article. The Comment records (associated to our article by a foreign
key and a belongs_to association) and the Approval records (associated
to articles only via the intermediate comment records).</p>

<p>This allows us to avoid making additional queries later if we want to
display the approval or comment data itself (in a nested partial, for
example). But let‚Äôs check out the queries ARel is performing here:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Article Load (0.1ms)  SELECT "articles".* FROM "articles" LIMIT 1
Comment Load (0.1ms)  SELECT "comments".* FROM "comments" WHERE "comments"."article_id" IN (8)
Approval Load (0.2ms)  SELECT "approvals".* FROM "approvals" WHERE "approvals"."comment_id" IN (6, 7, 8)
</code></pre></div></div>

<p>Notice that for each model, we are running a <code class="highlighter-rouge">SELECT....* FROM...</code> on
the corresponding table. This is great if we intend to actually use the
data (rendering it in a UI or some such), but if we aren‚Äôt using the
data, it‚Äôs a bit wasteful.</p>

<p>Let‚Äôs look at an example where we might want to query against only a
specific portion of the data. Suppose we wanted to find all the comments
which have been approved. Our current technique of using <code class="highlighter-rouge">includes</code>
allows us to efficiently find the approval information for a specific
comment. But it doesn‚Äôt help us much with querying against the combined
comment-approval data in bulk.</p>

<p>To do this, we might use <code class="highlighter-rouge">joins</code> to effectively combine the 2 tables and
then query against all of it at once. So, for example, to find only the
comments approved by user 1:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Comment.joins(:approval).where(approvals: {approved_by: 1}).count
</code></pre></div></div>

<p>Here, thanks to the joins, we are able to query against data from the
comments table and the approvals table at the same time. This ability to
perform queries across multiple tables in the DB is ultimately what
makes relational databases so powerful, and the <code class="highlighter-rouge">joins</code> method is our
main way for accessing this power through rails.</p>

<p>In Summary:</p>

<ul>
  <li>Includes ‚Äì easier to use, less fine grained ‚Äì ‚Äúgrab everything just
in case‚Äù</li>
  <li>Joins ‚Äì allows greater control but requires more specificity ‚Äì ‚Äúlet
me avoid bloat by specifying exactly what I need‚Äù</li>
  <li>Includes intentionally uses multiple queries to fetch all the required
data (and then caches this data in memory)</li>
  <li>Joins uses actual SQL joins to allow us to address multiple tables in
a single query</li>
</ul>

<h4 id="using-references-to-automate-creating-assocations">Using references to automate creating assocations</h4>

<p>As of Rails 4, The <code class="highlighter-rouge">ActiveRecord::Migration</code> table creation system now includes a
<code class="highlighter-rouge">references</code> method which automates creating foreign keys for
associations.</p>

<p>So in the past we have always created associations in a migration with
this approach:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class CreatePizzas &lt; ActiveRecord::Migration
¬†¬†def change
¬†¬†¬†¬†create_table :pizzas do |t|
¬†¬†¬†¬†¬†¬†t.string¬† :name
      t.integer :pizza_chef_id
¬†¬†¬†¬†¬†¬†t.timestamps
¬†¬†¬†¬†end
¬†¬†end
end
</code></pre></div></div>

<p>Using the Rails 4 syntax, we could simply specify:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class CreatePizzas &lt; ActiveRecord::Migration
¬†¬†def change
¬†¬†¬†¬†create_table :pizzas do |t|
¬†¬†¬†¬†¬†¬†t.string¬† :name
      t.references :pizza_chefs
¬†¬†¬†¬†¬†¬†t.timestamps
¬†¬†¬†¬†end
¬†¬†end
end
</code></pre></div></div>

<p>and Rails will name the column for us. This is especially useful when
generating a model, since Rails can also add the ActiveRecord
association methods as well:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>rails g model Pizza pizza_chef:references
</code></pre></div></div>

<p>This will give us a migration including the reference column:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class CreatePizzas &lt; ActiveRecord::Migration
  def change
    create_table :pizzas do |t|
      t.references :pizza_chef, index: true

      t.timestamps
    end
  end
end
</code></pre></div></div>

<p>And a <code class="highlighter-rouge">pizza.rb</code> model file with the appropriate <code class="highlighter-rouge">belongs_to</code>
association already added:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Pizza &lt; ActiveRecord::Base
  belongs_to :pizza_chef
end
</code></pre></div></div>

<p>Ultimately this is simply a time-saving technique. In some situations
you may even prefer the explicitness of adding them manually, but if
you‚Äôre confident about the assocations you need to set up, using
references can save you a few seconds.</p>

<h4 id="scopes-with-arguments">Scopes with Arguments</h4>

<p>We‚Äôve discussed scopes several times in the past, most often for
pre-configuring common queries to be run against specific column states
(find me all the orders which have the status ‚Äúpaid‚Äù, all the articles
published on today‚Äôs date, etc).</p>

<p>But scopes aren‚Äôt limited to querying against static data values ‚Äì
thanks to the fact that they‚Äôre implemented using lambdas, we can define
scopes which accept arguments as well.</p>

<p>For example, suppose we wanted to allow users to find only Articles
created after a specific date. To do this, it would be handy if we had a
scope which was limited not just to Today‚Äôs date, but to any variable
date we might pass in.</p>

<p>This can be done using a scope argument:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Article &lt; ActiveRecord::Base
¬†¬†scope :published_after, -&gt;(time) { where("created_at &gt; ?", time) }
end
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Article.published_after(10.months.ago).count
</code></pre></div></div>

<h4 id="homework-problem-recaps">Homework Problem Recaps</h4>

<p>Remember these lovely AR homework problems? Let‚Äôs revisit them to
discuss some that we didn‚Äôt get to before and to see if there are any
new questions that come up: https://gist.github.com/stevekinney/7bd5f77f87be12bd7cc6.</p>

<h4 id="notes-for-next-time">Notes For Next Time</h4>

<p>This session was first added for the 2/15 - 3/15 module. During several
previous ActiveRecord sessions (https://github.com/turingschool/lesson_plans/blob/master/ruby_04-apis_and_scalability/query_performance.markdown, and homework review for https://gist.github.com/stevekinney/7bd5f77f87be12bd7cc6) we had run out of time with 1409 before working through all of the material.</p>

<p>This session served as a bit of mopping up to cover the remaining
material from those sessions, and to try to get students some more
practice writing more complicated AR queries in general.</p>

<p>Ultimately it would probably make sense to break some of these
monolithic AR sessions into multiple smaller sessions on specific topics
so that we are better able to cover all the material. But for the moment
this is how this particular lesson came to be and why it‚Äôs a bit of a
hodgepodge.</p>
:ET