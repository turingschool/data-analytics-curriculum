I"ÏD<h2 id="instructor-notes">Instructor Notes</h2>

<p>At this point, students should understand that JavaScript is synchronous but browser APIs allow it to work asynchronously.</p>

<p>Some of the students probably used fetch or ajax in their mod 3/4 personal project as well, so much of this wonâ€™t be brand new to some students.</p>

<h3 id="prep">Prep</h3>

<p>Have the following tabs open in browser:</p>
<ul>
  <li>Hedgehog Party in development to show them how the GET request is working.</li>
  <li>Hedgehog Party Repo</li>
  <li>CSS Tricks article on Error Handling - https://css-tricks.com/using-fetch/#article-header-id-5</li>
</ul>

<p>Prep a message to cohort with Hedgehog Party Repo - https://github.com/turingschool-examples/fetch-hedgehog-party</p>

<h2 id="slides">Slides</h2>

<ul>
  <li>Available <a href="../slides/fetch">here</a></li>
</ul>

<h2 id="learning-goals">Learning Goals</h2>

<p>By the end of this lesson, you will â€¦</p>

<ul>
  <li>explain what a Promise is</li>
  <li>explain the advantages of using the Fetch API and Promises</li>
  <li>be able to write GET, POST, and DELETE requests using the Fetch API</li>
  <li>be familiar with patterns to organize/refactor fetch requests</li>
</ul>

<h2 id="warm-up">Warm Up</h2>

<p>SLIDE:</p>

<p>With a partner, use prior knowledge/educated guesses to discuss what you see happening at each line of this function. Also jot down any questions that arise from look at this.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">fetchDiscussions</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">/api/v1/discussions</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">response</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">())</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">rawDiscussions</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">cleanDiscussions</span><span class="p">(</span><span class="nx">rawDiscussions</span><span class="p">))</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">error</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">({</span> <span class="nx">error</span> <span class="p">}));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>DISCUSS:</p>

<ul>
  <li>ask 4 different students what is happening at lines 1-4</li>
  <li>response.json() - parses it from response stream to a JSON object</li>
  <li>cleanDiscussions - we can assume thatâ€™s a helper function somewhere else in the project</li>
</ul>

<h2 id="promises">Promises</h2>

<p>SLIDE:</p>

<blockquote>
  <p>A Promise is an object that represents the eventual completion or failure of an asynchronous operation, and itâ€™s returning value.</p>
</blockquote>

<p>3 states of Promises:</p>

<ul>
  <li>Pending</li>
  <li>Resolved/Fulfilled (with a return value from your async operation)</li>
  <li>Rejected (with an error message from your async operation)</li>
</ul>

<p>SAY:</p>

<p>Knowing the three states is helpful when debugging</p>

<h2 id="why-use-promises">Why Use Promises?</h2>

<p>SLIDE:</p>

<p>Promises allow you to multi-task a bit in JavaScript. They provide a cleaner and more standardized method of dealing with tasks that need to happen in sequence. With Promises, we have more control over what happens with the outcomes of our async processes.</p>

<p>SAY:</p>

<p>Promises are a mechanism to handle async JS.</p>

<h2 id="when-to-use-promises">When to use Promises</h2>

<p>SLIDE:</p>

<p>The short answer: whenever youâ€™re handed a promise by an API you didnâ€™t write, where the author chose to use promises. This includes many modern web APIs such as <code class="highlighter-rouge">fetch</code>.</p>

<p>SAY:</p>

<p>When you read the documentation for a library that uses promises, one of the first sentences will likely say â€˜this is a promise-based libraryâ€™. There are some APIs that still use callbacks rather than promises (the <code class="highlighter-rouge">geolocation</code> API, for example). Youâ€™ll want to read the documentation closely to see if the library expects you to use a promise or callback. So for once, we donâ€™t really have to be in charge of making a decision here â€“ we can let the tools and technologies weâ€™re using dictate whether or not we should be using promises.</p>

<h3 id="advantages-of-promises">Advantages of Promises</h3>

<p>SLIDE:</p>

<ul>
  <li>You are getting an IOU that youâ€™re holding on to rather than giving your code away as you would with callbacks.</li>
  <li>Error handling is less broken. Itâ€™s not a silver bullet. Synchronous functions either <code class="highlighter-rouge">return</code> or throw an error. In a similar vein, your promises will either become <em>resolved</em> by a value or become <em>rejected</em> with an error.</li>
  <li>You can catch errors along the way and deal with them in a way that is <em>similar</em> to synchronous code.</li>
  <li>Chaining promises is easy and does not result in callback hell.</li>
</ul>

<p>SAY:</p>

<p>So besides the obvious syntactical benefits, what are some of the others advantages of promises?</p>

<p>SLIDE:</p>

<p>But wait, thereâ€™s more.</p>

<ul>
  <li><code class="highlighter-rouge">Promise.all</code> takes an array of promises and waits until all of the promises are resolved. This solves the nastiness involved in doing this with callbacks.</li>
  <li><code class="highlighter-rouge">Promise.race</code> takes an array of promises and resolves as soon as any one of them fulfill. This would allow you to hit 3 API endpoints and then move on when we heard back from whichever one came back first.</li>
</ul>

<p>SAY:</p>

<p>There are two common methods used - I would be shocked if you could complete QS without using Promise.all (hint hint).</p>

<h2 id="promises-with-fetch-requests">Promises with Fetch Requests</h2>

<p>SLIDE:</p>

<p>Handling the response of a fetch request might look something like this:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">/api/v1/discussions</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">response</span> <span class="o">=&gt;</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">())</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">discussions</span> <span class="o">=&gt;</span> <span class="nx">renderDiscussions</span><span class="p">(</span><span class="nx">discussions</span><span class="p">))</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">error</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">({</span> <span class="nx">error</span> <span class="p">}))</span>
</code></pre></div></div>

<p>SAY:</p>

<p>Every fetch request we make will return a Promise object that contains our response data. This allows us to easily react to the type of response we get once itâ€™s available.</p>

<p>While we wait for the server to return our response, the rest of our application can continue executing other code in the meantime. Once the response object is available, our firstÂ <code class="highlighter-rouge">.then()</code>Â block will fire. The response object returns a lot of extra information that we donâ€™t necessarily need. All we want in this scenario is a JSON object of our discussions data which we can get by callingÂ <code class="highlighter-rouge">response.json()</code>.</p>

<p>Converting the body to a JSON data structure withÂ <code class="highlighter-rouge">response.json()</code>Â actually returns another Promise. (Converting the data to a particular type can take significant time, which is why we have this additional Promise step before we can begin working with out data.) Because weâ€™re getting another Promise object back, we can simply chain anotherÂ <code class="highlighter-rouge">.then()</code>Â block where we actually receive our project data. We can then render it to the DOM with our imaginary <code class="highlighter-rouge">renderDiscussions()</code> function. Notice how we are using another <code class="highlighter-rouge">.then()</code> statement. This is called Promise Chaining. We do this because each <code class="highlighter-rouge">.then()</code> results in a new Promise.</p>

<p>If for any reason the request failed, theÂ <code class="highlighter-rouge">.catch()</code>Â block will be fired and we will log the error to the console.</p>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch">Fetch</a></p>

<h2 id="what-do-promises-give-us">What do Promises Give Us?</h2>

<p>By using a Promise object, a function does two things:</p>

<ol>
  <li>It automatically becomes asynchronous, allowing it to run in the background and giving the rest of our code a change to continue execution.</li>
  <li>It gives us access to two methods - <code class="highlighter-rouge">.then</code> and <code class="highlighter-rouge">.catch</code></li>
</ol>

<p>SLIDE:</p>

<p><img src="https://wtcindia.files.wordpress.com/2016/06/promises.png?w=605" alt="inline" /></p>

<p>SAY:</p>

<p>If the function completes successfully, the Promise object is considered resolved, and our <code class="highlighter-rouge">.then()</code> block will execute. Within this block, we are automatically given a result that we can work with (e.g. data from an API endpoint). In this example, we are given project data for our students and weâ€™ll render them to the DOM.</p>

<p>If the function fails for any reason, our Promise object is considered rejected, and our <code class="highlighter-rouge">.catch()</code> block will execute instead. Within this block, we are automatically given an error that we can use to notify the user that something went wrong.</p>

<h2 id="a-typical-fetch-request">A Typical Fetch Request</h2>

<p>SLIDE:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">fetchDiscussions</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">/api/v1/discussions</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">response</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">())</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">rawDiscussions</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">cleanDiscussions</span><span class="p">(</span><span class="nx">rawDiscussions</span><span class="p">))</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">error</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">({</span> <span class="nx">error</span> <span class="p">}));</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">postDiscussions</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">/api/vi/discussions</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">method</span><span class="p">:</span> <span class="dl">'</span><span class="s1">POST</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">headers</span><span class="p">:</span> <span class="p">{</span> <span class="dl">'</span><span class="s1">Content-Type</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">application/json</span><span class="dl">'</span> <span class="p">},</span>
    <span class="na">body</span><span class="p">:</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>
      <span class="na">discussionName</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Movies</span><span class="dl">'</span><span class="p">,</span>
      <span class="na">totalPoints</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>SAY:</p>

<p>THINK PAIR SHARE: What differences do you notice between a GET and POST?</p>

<p>SLIDE:</p>

<p><code class="highlighter-rouge">fetch()</code> takes TWO arguments:</p>

<ul>
  <li>URL or API endpoint (always)</li>
  <li>object of configuration settings for the request. This may contain what kind of request weâ€™re making and any data we might need to pass along with it (optional)</li>
</ul>

<h2 id="hedgehog-party---20-minutes-per-step">Hedgehog Party - 20 minutes per step</h2>

<p>Clone down the Hedgehog Party Repo. Look through the JavaScript in <code class="highlighter-rouge">public/index.js</code> - we already have a get request up and running to get, then append, all the hedgies in the database onto the DOM. Make sure you open up the app in the browser and keep your Dev Tools open while working. You should be pairing with your Quantified Self partner for this activity.</p>

<p><strong>Step 1:</strong> Choose a driver. Together, write the request to POST a new hedgehog. See the README for info on what is expected in the request.</p>

<p><strong>Step 2:</strong> Now, the other partner should drive. Work together to write the request to DELETE a hedgehog from the invite list.</p>

<p>NOTE: Both tasks require network requests as well as DOM manipulation. This is good practice for Quantified SelfðŸ˜Š</p>

<h2 id="error-checking">Error Checking</h2>

<p>Give students 20 minutes to implement error handling:</p>

<p>Read about error handling <a href="https://css-tricks.com/using-fetch/#article-header-id-5">here</a>, then try to implement similar error handling in our GET request.</p>

<p>For further investigation if it just doesnâ€™t make sense to them:</p>

<p>Check out the example below. Our second button makes an unsuccessful request with a 404 response so why does it seem to still succeed?</p>

<blockquote>
  <p>codepen snippet here</p>
</blockquote>

<p>The promise returned from <code class="highlighter-rouge">fetch()</code> will only reject on network failure or if anything prevented the request from completing. This means it wonâ€™t reject on a response of 404 or 500 from the server but will return a <code class="highlighter-rouge">status.ok</code> status set to false.</p>

<p>To handle responses that do not return a successful status, we can create a response handler. If the response is <code class="highlighter-rouge">ok</code> we continue processing the data as we did above. If it is not we use <code class="highlighter-rouge">Promise.reject</code> to trigger our catch handler and pass it an error object with the <code class="highlighter-rouge">status</code>, <code class="highlighter-rouge">statusCode</code> and any addition json information we get from the server.</p>

<h2 id="organizing-fetch-requests">Organizing Fetch Requests</h2>

<p>There probably wonâ€™t be time to go over this is class; refer students for it for their FE projects as a refactoring opportunity.</p>

<h2 id="interview-questions">Interview Questions</h2>

<p>Pair up with your Quantified Self partner and practice answering the following interview questions:</p>

<ul>
  <li>What are the advantages of using fetch?</li>
  <li>What do you know about Promises? Can you give an example of when youâ€™ve used one?</li>
</ul>

<p>Be ready to share you answer(s) with the class when we wrap up.</p>

<h2 id="additional-resources">Additional Resources</h2>
<ul>
  <li><a href="https://davidwalsh.name/fetch">David Walsh fetch API</a></li>
  <li><a href="https://css-tricks.com/using-fetch/">CSS Tricks Using Fetch</a></li>
</ul>

<p>Be aware that AJAX can also be used to make client side request to a server. Fetch has become more poplar in recent years as it is built into Javascript, works on almost all browsers, and doesnâ€™t require jQuery. If you want to learn more check out this old lesson <a href="./archive/ajax-refresher.md">AJAX Refresher</a></p>
:ET