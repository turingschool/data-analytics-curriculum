I".&<h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>Identify the elements of the MVC design pattern</li>
  <li>Describe the single responsibility of each of the Model, View, and Controller</li>
  <li>Describe how data is passed through the MVC pattern</li>
</ul>

<h2 id="vocabulary">Vocabulary</h2>
<ul>
  <li>MVC</li>
  <li>Model</li>
  <li>View</li>
  <li>Controller</li>
  <li>DSL (Domain Specific Language)</li>
</ul>

<h2 id="warmup">Warmup</h2>

<ul>
  <li>In your own words, what are the primary responsibilities of the models, views, and controllers in Task Manager?</li>
</ul>

<h2 id="lecture">Lecture</h2>

<h3 id="overview">Overview</h3>

<ul>
  <li><strong>Models</strong> - Interact with the database. Holds other methods related to a particular resource (e.g. a <code class="highlighter-rouge">task</code>)</li>
  <li><strong>Views</strong> - Templates for pages that we will display to our user. Frequently contain placeholders for data, making them dynamic.</li>
  <li><strong>Controllers</strong> - Coordinate the response to an HTTP request. In Task Manager, we just had one, but it is common to have multiple controllers.</li>
</ul>

<h3 id="controller">Controller</h3>

<p>Look at your Task Manager <code class="highlighter-rouge">routes.rb</code>.</p>

<ul>
  <li>Routes in Rails are defined as part of its DSL (Domain Specific Language).</li>
  <li>The first keyword, a predefined method, of these routes corresponds with the <strong>HTTP verb</strong> the request is making to the route.</li>
  <li>The argument this method takes is a string version of the <strong>path</strong> the request is being made to.</li>
  <li>The second argument specifies which controller action should handle the request. The DSL syntax is <code class="highlighter-rouge">&lt;controller&gt;#&lt;action&gt;</code></li>
</ul>

<p>Look at your <code class="highlighter-rouge">tasks_controller.rb</code>:</p>

<ul>
  <li>Each route maps to a controller <strong>action</strong></li>
  <li>A controller <strong>action</strong> is a <strong>method</strong> defined in a Controller class</li>
  <li>Controller <strong>methods</strong> and <strong>actions</strong> are synonymous</li>
  <li>Controllers send commands to models to perform database interactions
    <ul>
      <li>ex: the <code class="highlighter-rouge">index</code> action retrieves all the tasks</li>
      <li>ex: the <code class="highlighter-rouge">create</code> action saves a new task</li>
    </ul>
  </li>
  <li>Controllers pass data to views via instance variables</li>
  <li>Controllers can either render a view or redirect
    <ul>
      <li>by default, a controller will render a view file with the same name as the action. It will look for the file in a folder named the same as the resource (in this case “tasks”) in the <code class="highlighter-rouge">views</code> folder.</li>
      <li>You can redirect using the <code class="highlighter-rouge">redirect_to</code> method.</li>
      <li>You can also manually say which view you want to render using the <code class="highlighter-rouge">render</code> method, but it’s best to use the default convention when it applies.</li>
    </ul>
  </li>
</ul>

<h3 id="model">Model</h3>

<p>Look at your Task model.</p>

<ul>
  <li>Nothing! So where do we get the ability to call methods like <code class="highlighter-rouge">Task.all</code> and <code class="highlighter-rouge">Task.find</code>?</li>
  <li>Every controller within the controllers directory will have access to EVERY model in the database.</li>
  <li>The file naming conventions for models is singular.</li>
  <li>A model that inherits from <code class="highlighter-rouge">ApplicationRecord</code> should have a corresponding table in the Database.</li>
</ul>

<h3 id="view">View</h3>

<p>Look at a view from Task Manager</p>

<ul>
  <li>By default, Rails looks for our views in a <code class="highlighter-rouge">/views</code> directory.</li>
  <li>Use ERB (embedded ruby) to describe how data should be used to create HTML
    <ul>
      <li><code class="highlighter-rouge">&lt;%= %&gt;</code> renders the return value of the enclosed statement. Use this when you need something to be a part of the HTML document sent to the User.
        <ul>
          <li>ex: <code class="highlighter-rouge">&lt;p&gt;&lt;%= task.description %&gt;&lt;/p&gt;</code>    <br />
<strong>This piece of code will be extremely useful for assigning</strong> <code class="highlighter-rouge">id</code> <strong>attributes dynamically, which is important for testing. Bookmark this piece of code!</strong></li>
          <li>ex: <code class="highlighter-rouge">&lt;div id="task-&lt;%= task.id %&gt; &gt;"</code></li>
        </ul>
      </li>
      <li><code class="highlighter-rouge">&lt;% %&gt;</code> does not render the return value. Use this when you don’t want the return value to become part of the HTML. Typically, these are used for Ruby statements that control other statements.
        <ul>
          <li>ex: <code class="highlighter-rouge">&lt;% tasks.each do |task| %&gt;</code> … <code class="highlighter-rouge">&lt;% end %&gt;</code></li>
          <li>ex: <code class="highlighter-rouge">&lt;% if @tasks %&gt;</code> … <code class="highlighter-rouge">&lt;% end %&gt;</code></li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="putting-it-all-together">Putting it All Together</h3>

<ul>
  <li>Someone sends a request to your application. That request includes:
    <ul>
      <li>An HTTP verb (GET, POST, etc.)</li>
      <li>A URI path (<code class="highlighter-rouge">/tasks</code>, <code class="highlighter-rouge">/</code>, <code class="highlighter-rouge">/tasks/2</code>)</li>
    </ul>
  </li>
  <li>Rails inspects the verb/path combo and determines what controller action to call based on what routes you’ve defined in <code class="highlighter-rouge">routes.rb</code></li>
  <li>Within that controller action, we:
    <ol>
      <li>Perform any data manipulation we need using our model</li>
      <li>Collect any data we need to use in our view (using a model as a go-between)</li>
      <li>Render a view or redirect</li>
    </ol>
  </li>
</ul>

<p>Let’s draw a diagram to represent this process.</p>

<details><summary>MVC Diagram</summary>
<img src="./images/mvc_rails.png" alt="Rails MVC Diagram" />
</details>

<h3 id="logic-responsibilities">Logic “Responsibilities”</h3>

<p>The MVC Design Pattern describes the primary responsibility of each portion of code that we’ll describe a little bit deeper here.</p>

<h4 id="models--data-logic">Models – Data Logic</h4>

<p>We saw earlier that the Model is responsible for interaction with the database. In MVC, we say that the Model is responsible for “data logic”. <em>Calculations, filtering of data, or other manipulation of data should happen at the Model level.</em> When fetching data from a Model, the Model should only return raw data in an appropriate data structure – usually an array, but can also be a hash.</p>

<p>A Model generally does not alter data. For example, it would be appropriate for the Model to calculate the average age of all students, but it should NOT ‘round’ that data to, say, two decimal places. It can force the result to be a floating point number with <code class="highlighter-rouge">.to_f</code>, but it should return raw data as much as possible.</p>

<h4 id="views--presentation-logic">Views – Presentation Logic</h4>

<p>Views have very little logic in them, generally just if/else statements and perhaps doing some basic iteration over a dataset. <em>The primary goal of a View is to manipulate raw data given to it by a Controller to present that data</em> in a way that is useful to our users.</p>

<p>If a View has access to an instance variable, or a collection of instances in an array that it is iterating over, it’s appropriate for the View to call “instance methods” from the Model class if needed. A View should not call <em>class</em> methods except in extremely rare cases where a data builder requires it, such as a drop-down select in a form for example.</p>

<h4 id="controllers--business-logic-or-application-logic">Controllers – Business Logic, or Application Logic</h4>

<p>Our Controllers are the “traffic cop” between our Models and our Views. Based on the incoming request, each controller method knows precisely which Model(s) it needs to utilize to fetch or write data, and will generally hand that data off to a View for presentation.</p>

<p>Controllers should limit their database actions to very simple lookups, or creation of a resource. A controller should not do very much data manipulation, that “data logic” is the role of the Model. Likewise, the controller should pre-fetch as much data as possible so the View does not call Class methods from the Models.</p>

<h3 id="experiment">Experiment</h3>

<ul>
  <li>
    <p>Add a new route and view so that the user can successfully visit <code class="highlighter-rouge">localhost:3000/easteregg</code> and see a new view of your choice.</p>
  </li>
  <li>
    <p>Add a new route so that the user can go to <code class="highlighter-rouge">localhost:3000/showmethetasks</code> and be redirected to all of the tasks.</p>
  </li>
</ul>

<p>NOTE: For task 2, You should not have to create a new view.</p>

<p><strong>Let’s also quickly talk about why the 2nd path isn’t a good idea.</strong></p>

<h3 id="recap">Recap</h3>
<ul>
  <li>What does MVC stand for?</li>
  <li>What are the “logic responsibilities” for each part of the MVC pattern?</li>
  <li>How is data passed through the MVC pattern?</li>
  <li>What is the difference between <code class="highlighter-rouge">&lt;%= %&gt;</code> and <code class="highlighter-rouge">&lt;% %&gt;</code>?</li>
</ul>
:ET