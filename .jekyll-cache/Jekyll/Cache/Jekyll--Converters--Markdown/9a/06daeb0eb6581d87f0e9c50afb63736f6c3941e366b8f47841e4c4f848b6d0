I"Ü-<h2 id="goals">Goals</h2>

<ul>
  <li>Describe ‚Äúnormalization‚Äù of a database</li>
  <li>Describe some best practices around optimization of tables</li>
  <li>Describe how indexing mechanics work at a high level</li>
</ul>

<h2 id="vocabulary">Vocabulary</h2>

<ul>
  <li>Normalization</li>
  <li>B-Tree</li>
</ul>

<h2 id="slides">Slides</h2>

<p>Available <a href="../slides/database_normalization_and_optimization">here</a></p>

<h2 id="warm-up">Warm-Up</h2>

<ul>
  <li>Read <a href="https://www.essentialsql.com/get-ready-to-learn-sql-database-normalization-explained-in-simple-english/">this</a> article on database normalization.</li>
  <li>In your own words summarize what database normalization is.</li>
</ul>

<h3 id="defining-key-terms">Defining Key Terms</h3>

<ul>
  <li><strong>Normalization</strong> - An optimization and reorganization of database tables that removes data duplication</li>
  <li><strong>B-Tree</strong> - A data structure, a generalized version of a ‚Äúbinary tree‚Äù, sometimes called a ‚Äútrie‚Äù, which is commonly used for storing indexes within PostgreSQL</li>
</ul>

<h2 id="normalization">Normalization</h2>

<p>‚ÄúNormalization‚Äù is usually done by examining our database table structure to look for duplicated data, usually strings, and find ways to replace those values with something which is faster to store and search.</p>

<p>For example, let‚Äôs take a look at one potential schema for a database linking students and courses.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">ActiveRecord</span><span class="o">::</span><span class="no">Schema</span><span class="p">.</span><span class="nf">define</span><span class="p">(</span><span class="ss">version: </span><span class="mi">20171204033005</span><span class="p">)</span> <span class="k">do</span>

  <span class="c1"># These are extensions that must be enabled in order to support this database</span>
  <span class="n">enable_extension</span> <span class="s2">"plpgsql"</span>

  <span class="n">create_table</span> <span class="s2">"courses"</span><span class="p">,</span> <span class="ss">force: :cascade</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
    <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="s2">"title"</span>
    <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="s2">"description"</span>
  <span class="k">end</span>

  <span class="n">create_table</span> <span class="s2">"students"</span><span class="p">,</span> <span class="ss">force: :cascade</span> <span class="k">do</span> <span class="o">|</span><span class="n">t</span><span class="o">|</span>
    <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="s2">"first_name"</span>
    <span class="n">t</span><span class="p">.</span><span class="nf">string</span> <span class="s2">"last_name"</span>
    <span class="n">t</span><span class="p">.</span><span class="nf">bigint</span> <span class="s2">"course_id"</span>
    <span class="n">t</span><span class="p">.</span><span class="nf">integer</span> <span class="s2">"score"</span>
    <span class="n">t</span><span class="p">.</span><span class="nf">index</span> <span class="p">[</span><span class="s2">"course_id"</span><span class="p">],</span> <span class="ss">name: </span><span class="s2">"index_students_on_course_id"</span>
  <span class="k">end</span>

<span class="k">end</span>
</code></pre></div></div>

<p>Given that <code class="highlighter-rouge">course_id</code> exists on the students table, we might assume a one-to-many relationship between courses and students. What if the actual relationship was many-to-many? Without changing the database, how would we record the fact that a student was enrolled in multiple courses?</p>

<p>We could potentially put multiple course ids in the <code class="highlighter-rouge">course_id</code> column. We could also have multiple <code class="highlighter-rouge">course_id</code> columns (e.g. <code class="highlighter-rouge">course_1_id</code>, <code class="highlighter-rouge">course_2_id</code>, etc.). Or we could have multiple rows that had the same first/last name for a student. However, none of these solutions would be <em>normalized</em>.</p>

<p>How could we adjust the structure of the database to record a many-to-many relationship between students?</p>

<h3 id="why-normalize">Why Normalize</h3>

<p>Imagine for a moment we did not normalize the database, but instead pursued one of the other solutions described above. How would we find all of the students enrolled in a particular course? What opportunities for error/corrupted information would exist?</p>

<p>How does normalization help resolve these potential issues?</p>

<h3 id="practice">Practice</h3>

<ul>
  <li>Imagine you were going to create a database to store the information in the JSON hash below. How might you structure your database?</li>
</ul>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">payload</span> <span class="o">=</span> <span class="s1">'{
  "url":"http://jumpstartlab.com/blog",
  "requestedAt":"2013-02-16 21:38:28 -0700",
  "respondedIn":37,
  "referredBy":"http://jumpstartlab.com",
  "requestType":"GET",
  "eventName": "socialLogin",
  "userAgent":"Mozilla/5.0 (Macintosh; Intel Mac OS X 10_8_2) AppleWebKit/537.17 (KHTML, like Gecko) Chrome/24.0.1309.0 Safari/537.17",
  "resolutionWidth":"1920",
  "resolutionHeight":"1280",
  "ip":"63.29.38.211"
}'</span>
</code></pre></div></div>

<ul>
  <li>
    <p>Review <a href="https://www.kaggle.com/unitednations/global-commodity-trade-statistics/data">this</a> commodity trade data. How might you structure a normalized database to store this data?</p>
  </li>
  <li>
    <p>Review <a href="https://www.kaggle.com/aashita/nyt-comments/data">this</a> New York Times article data. How might you structure a normlalized database to store this data?</p>
  </li>
</ul>

<h2 id="how-are-tables-and-indexes-actually-stored-in-postgresql">How are tables and indexes actually stored in PostgreSQL</h2>

<p>Clone (or re-use) the <a href="https://github.com/turingschool-examples/roster">roster repo</a>. Run bundle to install any missing gems, then run rake db:{create,migrate,seed}.</p>

<p>From a terminal prompt, run psql roster-development. Use \q within the psql shell to exit back to your terminal prompt.</p>

<p>Based on the <code class="highlighter-rouge">belongs_to</code> and <code class="highlighter-rouge">has_many</code> attributes in our <code class="highlighter-rouge">/app/models/student.rb</code> and <code class="highlighter-rouge">/app/models/course.rb</code>, we can see how ActiveRecord constructs our tables. But what do these actually look like in PostgreSQL? Let‚Äôs take a look.</p>

<p>Run <code class="highlighter-rouge">psql roster-development</code> in a new terminal window. Here, we can execute a SQL command to list all of our students:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roster-development=# select * from students;
id | first_name |  last_name  | course_id | score
----+------------+-------------+-----------+-------
 1 | Brian      | Zanti       |         1 |     3
 2 | Megan      | McMahon     |         1 |     4
 3 | Josh       | Mejia       |         3 |     2
 4 | Mike       | Dao         |         3 |     3
 5 | Dione      | Wilson      |         2 |     2
 6 | Ian        | Douglas     |         2 |     4
 7 | Cory       | Westerfield |         4 |     3
 8 | Sal        | Espinosa    |         1 |     2
(8 rows)
</code></pre></div></div>

<p>This, however, doesn‚Äôt tell us very much about the table itself, only the data within it. Let‚Äôs examine the <em>structure</em> of the table:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>roster-development=# \d students
                                   Table "public.students"
   Column   |       Type        | Collation | Nullable |               Default
------------+-------------------+-----------+----------+--------------------------------------
 id         | bigint            |           | not null | nextval('students_id_seq'::regclass)
 first_name | character varying |           |          |
 last_name  | character varying |           |          |
 course_id  | bigint            |           |          |
 score      | integer           |           |          |
Indexes:
    "students_pkey" PRIMARY KEY, btree (id)
    "index_students_on_course_id" btree (course_id)
</code></pre></div></div>

<p>This view allows us to see how ActiveRecord‚Äôs schema actually built the table in PostgreSQL. Other databases like SQLite and MySQL will use different ‚Äòtypes‚Äô for the fields, and may use different index types, but let‚Äôs break this down into its components.</p>

<p><strong>Pair up and examine the following:</strong></p>

<ul>
  <li>we see the <code class="highlighter-rouge">id</code> field and <code class="highlighter-rouge">course_id</code> fields are a type called <code class="highlighter-rouge">bigint</code> ‚Äì what is a <code class="highlighter-rouge">bigint</code> data type?</li>
  <li>a ‚Äúvarying‚Äù character type used for the student‚Äôs first and last names means the database will accept a string of changing length, instead of a fixed-length string (eg, this field is always 15-characters long)</li>
  <li>the <code class="highlighter-rouge">score</code> field is an <code class="highlighter-rouge">integer</code> ‚Äì how is that different from a <code class="highlighter-rouge">bigint</code>?</li>
  <li>we can also see that the <code class="highlighter-rouge">id</code> field is marked as <code class="highlighter-rouge">not null</code> ‚Äì what does this mean?</li>
  <li>the ‚Äúdefault‚Äù value for an <code class="highlighter-rouge">id</code>, if not provided, will use a <code class="highlighter-rouge">sequence</code> (‚Äúseq‚Äù) ‚Äì what is a <code class="highlighter-rouge">sequence</code> in PostgreSQL?</li>
</ul>

<h3 id="what-are-btree-indexes">What are ‚Äúbtree‚Äù indexes?</h3>

<p>We can also see from the output that we have a single <code class="highlighter-rouge">PRIMARY KEY</code> on our <code class="highlighter-rouge">(id)</code> field, which uses a <code class="highlighter-rouge">btree</code> type, and that our <code class="highlighter-rouge">course_id</code> field also uses a <code class="highlighter-rouge">btree</code> index type.</p>

<p>A b-tree is like the ‚Äúprefix‚Äù tree that you may have used in the <a href="http://backend.turing.io/module1/projects/complete_me">Complete Me</a> project in Mod 1, where each node in the tree can have multiple children. We won‚Äôt dive into the theory of it, but this is the most-used index type within PostgreSQL.</p>

<h2 id="additional-resources">Additional Resources</h2>

<ul>
  <li>the theory of <a href="https://en.wikipedia.org/wiki/B-tree">b-tree data structures</a></li>
  <li><a href="http://www.devshed.com/c/a/mysql/an-introduction-to-database-normalization/">DevShed - An Introduction to Database Normalization</a></li>
  <li><a href="http://mikehillyer.com/articles/an-introduction-to-database-normalization/">Mike Hillyer‚Äôs Blog Post - intro to database normalization</a></li>
  <li><a href="https://www.youtube.com/watch?v=K7vzLrGCV50&amp;list=PLQ9AAKW8HuJ5m0rmHKL88ZyjOIKejvrj0">Watch Sharif Ramadan‚Äôs intro to 1NF, 2NF and 3NF databases. They‚Äôre only about 4 minutes each.</a></li>
</ul>
:ET