I"ø8<p>This lesson plan was last updated to work with Rails 5.2.0 and Ruby 2.4.1</p>

<p><a href="../slides/background_workers">slides</a></p>

<h3 id="learning-goals">Learning Goals</h3>

<p>By the end of this lesson, you will know/be able to:</p>

<ul>
  <li>Explain when you would want to use a background worker</li>
  <li>Be able to implement a basic background process</li>
  <li>What ActiveJob is and how it is similar to ActiveRecord</li>
</ul>

<h4 id="intro">Intro</h4>

<p>When building websites, it‚Äôs important to keep your response times down. Long-running requests tie up server resources, degrade user perception of your site, and make it hard to manage failures.</p>

<p>There‚Äôs a solution to this: return a successful response, and then schedule some computation to happen later, outside the original request/response cycle.</p>

<h5 id="do-you-need-a-job-queue">Do you need a job queue?</h5>

<p>How do you identify areas of the application that can benefit from a background job? Some common areas for asynchronous work:</p>

<ul>
  <li>Data Processing - e.g. generating thumbnails or resizing images</li>
  <li>3rd Party APIs - interacting with a service outside of your site</li>
  <li>Maintenance - expiring old sessions, sweeping caches</li>
  <li>Email - a request that causes an email to be sent</li>
</ul>

<p>Applications with good OO design make it easy to send jobs to workers, poor OO makes it hard to extract jobs since responsibilities tend to overlap.</p>

<h3 id="1-app-setup">1: App Setup</h3>

<p>Let‚Äôs look at an example of backgrounding a task using Sidekiq.
We‚Äôll use the ‚ÄúWorking-It‚Äù application for the following demo.
Clone and bundle it like so:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone git@github.com:turingschool-examples/work-it.git
cd work-it
bundle
rake db:{create,migrate}
rails s
</code></pre></div></div>

<p>Workin-it is a simple app that takes an email and a random thought to generate an email with a giphy about your thought. Start the server <code class="highlighter-rouge">rails s</code> and you should be able to view the app at <code class="highlighter-rouge">http://localhost:3000</code> which has form inputs for an email address and a thought. When you submit that form you should feel the pain of a slow page load.</p>

<p>Why?</p>

<p>Check out our <code class="highlighter-rouge">UserNotifierMailer</code> mailer. A 5 second delay has been hard-coded in to simulate a real-life delay.</p>

<h3 id="2-mailcatcher-for-local-email-processing">2: Mailcatcher for Local Email Processing</h3>

<p>Now test that the application is working by entering an email address
and any thought you may have right now. You should
see an email in the mailcatcher UI with the thought-giphy.</p>

<p>Notice that this process takes a very long time. What we have here is a perfect candidate for a background process:</p>

<ul>
  <li>Operation is slow</li>
  <li>User‚Äôs interaction with the process is already asynchronous (submit
the form <em>then</em> go check their email)</li>
  <li>Operation is well-encapsulated behind the UserNotifier interface</li>
  <li>Operation requires relatively little data as inputs (email address
and random thought).</li>
</ul>

<p>Sidekiq and Resque are the 2 most popular queuing libraries for Ruby.
For this application, we‚Äôll use Sidekiq.</p>

<h3 id="3-dependency--redis">3: Dependency ‚Äì Redis</h3>

<p>Like Resque, Sidekiq uses Redis as a database to store queued jobs, so first make
sure you have redis installed and running.</p>

<p>Run <code class="highlighter-rouge">redis-server</code></p>

<p>If you don‚Äôt already have redis, install it with homebrew:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>brew update &amp;&amp; brew install redis
</code></pre></div></div>

<p>Then run <code class="highlighter-rouge">redis-server</code>.</p>

<p>This command starts the redis server on port 6379. Once the redis server is running it is ready to queue jobs that still need to be done.</p>

<p>You can check if your redis process is running by executing the command
<code class="highlighter-rouge">redis-cli</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ redis-cli
127.0.0.1:6379&gt;
</code></pre></div></div>

<p>The need for running our Redis server now is similar to how Postgres must be running in order for ActiveRecord to interact with our database.</p>

<h3 id="4-activejob-and-sidekiq-setup">4: ActiveJob and Sidekiq Setup</h3>

<p>Sidekiq is the adapter we‚Äôll be using with Rails‚Äô ActiveJob. ActiveJob was introduced in Rails 4.2 as a way of interacting with these background worker adapters more easily.</p>

<p>A worker class inheriting from <code class="highlighter-rouge">ActiveJob::Base</code> will have access to job enqueing methods, as well as many callbacks. Those can be seen <a href="http://edgeguides.rubyonrails.org/active_job_basics.html">here</a>.</p>

<p>We can add the sidekiq gem to our Gemfile:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gem 'sidekiq'
</code></pre></div></div>

<p>bundle the app and you should now be able to run a sidekiq
process by executing the command:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>bundle exec sidekiq
</code></pre></div></div>

<p>You should get the fancy Sidekiq ASCII logo in your terminal:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>         s
          ss
     sss  sss         ss
     s  sss s   ssss sss   ____  _     _      _    _
     s     sssss ssss     / ___|(_) __| | ___| | _(_) __ _
    s         sss         \___ \| |/ _` |/ _ \ |/ / |/ _` |
    s sssss  s             ___) | | (_| |  __/   &lt;| | (_| |
    ss    s  s            |____/|_|\__,_|\___|_|\_\_|\__, |
    s     s s                                           |_|
          s s
         sss
         sss
</code></pre></div></div>

<p>We also need to configure ActiveJob to use sidekiq as its adapter:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># config/application.rb</span>
<span class="k">class</span> <span class="nc">Application</span> <span class="o">&lt;</span> <span class="no">Rails</span><span class="o">::</span><span class="no">Application</span>
  <span class="c1">#</span>
  <span class="n">config</span><span class="p">.</span><span class="nf">active_job</span><span class="p">.</span><span class="nf">queue_adapter</span> <span class="o">=</span> <span class="ss">:sidekiq</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="5-making-a-job">5: Making a Job</h3>

<p>Now we have sidekiq running with our application, but so far it doesn‚Äôt
do anything for us. Let‚Äôs create a worker to handle our Workin-it email.</p>

<p>ActiveJob looks for jobs in the <code class="highlighter-rouge">app/jobs</code> directory. These job files will typically end in <code class="highlighter-rouge">_job</code> as to avoid namespace collisions.</p>

<p>Rails 4.2 introduced a generator for these jobs:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rails</span> <span class="n">generate</span> <span class="n">job</span> <span class="n">gif_sender</span>
</code></pre></div></div>

<p>The above will create <code class="highlighter-rouge">GifSenderJob</code> saved to the <code class="highlighter-rouge">app/jobs</code> directory.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">GifSenderJob</span> <span class="o">&lt;</span> <span class="no">ActiveJob</span><span class="o">::</span><span class="no">Base</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="6-defining-job-operations">6: Defining Job Operations</h3>

<p>Within a Sidekiq job, the instance method <code class="highlighter-rouge">#perform</code> is what gets
called whenever a job appears for our worker to do. Other methods can live within the job class, but <code class="highlighter-rouge">#perform</code> is what will be invoked when running the worker.</p>

<p>Let‚Äôs think about what needs to go in here and about what inputs are required for
the worker to do its job:</p>

<ul>
  <li>Needs to take in the email address and thought (since these
are the parameters needed to send the email)</li>
  <li>Needs to send an email using the <code class="highlighter-rouge">UserNotifier</code></li>
</ul>

<p>Given these constraints, it might look something like:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">GifSenderJob</span> <span class="o">&lt;</span> <span class="no">ActiveJob</span><span class="o">::</span><span class="no">Base</span>
  <span class="k">def</span> <span class="nf">perform</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">thought</span><span class="p">)</span>
    <span class="no">UserNotifierMailer</span><span class="p">.</span><span class="nf">send_randomness_email</span><span class="p">(</span><span class="n">email</span><span class="p">,</span> <span class="n">thought</span><span class="p">).</span><span class="nf">deliver_now</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>If you went the generate route for creating <code class="highlighter-rouge">GifSenderJob</code>, you may see something that looks like:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">queue_as</span> <span class="ss">:default</span>
</code></pre></div></div>

<p>This helper allows us to designate which workers queue our job should run on (should we have multiple workers).</p>

<p>By default, ActionMailer jobs run on the <code class="highlighter-rouge">mailers</code> queue. Changing <code class="highlighter-rouge">default</code> to something like <code class="highlighter-rouge">urgent</code> would redirect these jobs.</p>

<h3 id="7-queueing-jobs--sidekiqworkerperform_async">7: Queueing Jobs ‚Äì Sidekiq::Worker.perform_async</h3>

<p>The Sidekiq worker defines what actual work will be done whenever
our background process is invoked. Now we just need to actually
invoke it.</p>

<p>With Sidekiq, we dispatch a job for a worker to do later by
calling ActiveJob‚Äôs class method <code class="highlighter-rouge">.perform_later</code> on our worker and
providing it whatever arguments are needed for the job.</p>

<p>Under the hood, the <code class="highlighter-rouge">.perform_later</code> method writes data into
Redis indicating the type of job which needs to be done
and the data associated with it. The workers (in a separate
process) are monitoring the queue so that whenever new jobs
appear, they can spring into action and do them!</p>

<p>These workers can also perform jobs syncronously if needed. In that case, the method <code class="highlighter-rouge">.perform_now</code> would be used.</p>

<p>But enough chit-chat, let‚Äôs see what it looks like to actually
queue the job. Recall that we were previously sending the
email directly from our <code class="highlighter-rouge">MailersController</code>. Let‚Äôs replace
the line that was sending the email with this line to
queue our job instead:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">GifSenderJob</span><span class="p">.</span><span class="nf">perform_later</span><span class="p">(</span><span class="n">params</span><span class="p">[</span><span class="ss">:mailers</span><span class="p">][</span><span class="ss">:email</span><span class="p">],</span> <span class="n">params</span><span class="p">[</span><span class="ss">:mailers</span><span class="p">][</span><span class="ss">:thought</span><span class="p">])</span>
</code></pre></div></div>

<p>Remember ‚Äì the arguments passed in to the <code class="highlighter-rouge">.perform_later</code> method here
will eventually be handed to your worker‚Äôs <code class="highlighter-rouge">#perform</code> method, so make
sure they match up.</p>

<p>Let‚Äôs try this out now - hopefully that painful delay is no more!</p>

<h3 id="8-sidekiq-dashboard">8: Sidekiq Dashboard</h3>

<p>Sidekiq and Resque provide dashboards for us to monitor our local job queues.</p>

<p>They both run using Sinatra, so to enable them, we need to add Sinatra to our Gemfile:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">gem</span> <span class="s1">'sinatra'</span>
</code></pre></div></div>

<p>Then, in our routes file, we‚Äôll need to mount the Sidekiq dashboard:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">require</span> <span class="s1">'sidekiq/web'</span>
<span class="n">mount</span> <span class="no">Sidekiq</span><span class="o">::</span><span class="no">Web</span> <span class="o">=&gt;</span> <span class="s1">'/sidekiq'</span>
</code></pre></div></div>

<p>Now you can navigate to <code class="highlighter-rouge">http://localhost:3000/sidekiq/</code>. This dashboard is very useful for testing out jobs and recieving confirmation that everything is queued according to plan.</p>

<h2 id="checks-for-understanding">Checks for Understanding</h2>

<ul>
  <li>What is a background worker? Why would you use a background worker?</li>
  <li>What is Sidekiq?</li>
  <li>What is Redis?</li>
  <li>How do Sidekiq, Redis, and Rails interact? Draw a diagram?</li>
</ul>

<h3 id="video">Video</h3>

<ul>
  <li><a href="https://vimeo.com/131505902">Link to optional video</a></li>
</ul>

<h3 id="repository">Repository</h3>

<ul>
  <li><a href="https://github.com/turingschool-examples/work-it/">Work-it Repo</a></li>
</ul>

<h3 id="outside-resources--further-reading">Outside Resources / Further Reading</h3>

<ul>
  <li><a href="https://github.com/turingschool/lesson_plans/blob/master/ruby_04-apis_and_scalability/background_workers_revisited.markdown">background workers revisited</a></li>
  <li><a href="https://github.com/turingschool/lesson_plans/blob/master/ruby_04-apis_and_scalability/workers_at_scale.markdown">workers at scale</a></li>
</ul>
:ET