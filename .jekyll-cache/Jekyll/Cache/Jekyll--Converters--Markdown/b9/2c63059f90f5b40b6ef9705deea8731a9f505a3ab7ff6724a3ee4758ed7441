I"ˆ<h1 id="jsblogger-performance-dojo">JSBlogger Performance Dojo</h1>

<h3 id="learning-goals">Learning Goals</h3>

<ul>
  <li>Apply the performance techniques we‚Äôve been discussing to a semi-realistic example application</li>
  <li>Get some experience working with a large seed dataset (750k+ records)</li>
  <li>Use a performance profiling tool (NewRelic) to pinpoint bottlenecks</li>
</ul>

<h2 id="warmupsetup">Warmup/Setup</h2>

<p>For this tutorial, we‚Äôll be using the blogger-perf-workshop branch of the JS Blogger
project to practice making performance improvements to a rails
application.</p>

<p>To get started, you‚Äôll need to clone the <code class="highlighter-rouge">blogger-perf-workshop</code> branch of
the JSBlogger project. To do this, follow the instructions in that
branch‚Äôs <a href="https://github.com/JumpstartLab/blogger_advanced/tree/blogger-perf-workshop#blogger-advanced----perf-workshop">README</a>.</p>

<h3 id="caveats-before-you-begin">Caveats before you begin</h3>

<p>This branch includes a pre-constructed dataset which populates the DB
with a large amount of records ‚Äì 5k authors, 70k articles, 300k+
comments, and 300k+ taggings. This is intended to get us closer to the
sorts of datasets we might see in production systems, and really drive
home the impact of SQL/AREL techniques like using indices and avoiding
n+1 queries.</p>

<p>As it stands, the performance of the app is <strong>seriously</strong> bad. You‚Äôll
likely find that several of the pages won‚Äôt even finish rendering in
less than 30-60 seconds.</p>

<p>So it is going to take a lot of work to whip the thing into shape.</p>

<p>But fear not, noble optimizers! You‚Äôre up to the challenge.</p>

<p>Dig in and remember the key tenets of performance optimization work:</p>

<ul>
  <li>Go after the biggest wins first</li>
  <li>Make decisions based on data / benchmarks</li>
  <li>Consider which optimizations will improve specific operations in the
app VS which might have a ‚Äúhalo effect‚Äù to other parts of the app.
(e.g. caching a chunk of markup vs adding a db index)</li>
</ul>

<h2 id="intro--caching-crash-course">Intro ‚Äì Caching Crash Course</h2>

<p>‚ÄúCaching‚Äù is an optimization technique involving saving the result of
some computation so that it can be re-used later. Usually we do this
because the computation is expensive in some way (perhaps in terms of
time, bandwidth, memory consumption, etc).</p>

<p>Caching can often provide an ‚Äúeasy way out‚Äù of certain optimization problems,
since when you cache something you don‚Äôt necessarily make it faster,
you simply make it happen less often.</p>

<p>Within this project we‚Äôll likely want to cache 2 types of information:</p>

<ol>
  <li>Chunks of rendered HTML (we often call this fragment or markup caching since we‚Äôre
caching fragments of markup)</li>
  <li>Small bits of ‚Äúexpensive‚Äù data (we often call this data caching since‚Ä¶data)</li>
</ol>

<p>Markup caching is almost always done in view templates and data
caching in our models or other ‚Äúbackend‚Äù ruby classes.</p>

<p>Markup caching is quite easy, simply wrap some chunk of HTML
in a cache block and voila:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;% cache do %&gt;
  &lt;h1&gt;hi there this will be cached&lt;/h1&gt;
&lt;% end %&gt;
</code></pre></div></div>

<p>Sometimes, you‚Äôll need to specify an optional cache key to
differentiate your cached markup from other cached markup:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;% cache("article-#{params[:id]}") do %&gt;
  &lt;h1&gt;&lt;%= @article.title %&gt;&lt;/h1&gt;
&lt;% end %&gt;
</code></pre></div></div>

<p>Caching data is also straightforward and is done using
the <code class="highlighter-rouge">Rails.cache</code> interface:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class MySweetModel
  def self.my_slow_business_intelligence_method
    Rails.cache.fetch("top-daily-rev") do
	  calculate_top_daily_revenue
    end
  end
end
</code></pre></div></div>

<p>Things that make a good fit for data caching include:</p>

<ul>
  <li>Ids or slugs of specific data entities (‚Äúmost popular article‚Äù, ‚Äúmost
frequently read author‚Äù, etc)</li>
  <li>Small JSON payloads describing important or expensive-to-generate data</li>
  <li>Sets or collections of data (‚Äúids of all articles for a tag‚Äù, etc ‚Äì
read up on some of redis‚Äô set-manipulation features if you find
yourself doing this frequently)</li>
</ul>

<p><strong>Pull-Through Caching</strong></p>

<p>In both of these examples we are exploiting the cache‚Äôs
ability to ‚Äúpull through‚Äù any results that are uncached.
That is, when we use the <code class="highlighter-rouge">cache</code> template helper or the
<code class="highlighter-rouge">Rails.cache.fetch</code> method, the cache will first look to
see if the specified key has data in it. If so, it will
simply return that data.</p>

<p>If not, the cache will evaluate the provided block, store
the result in the provided key, and then return it back to
you. This way next time you need to look up the same value,
it will already be present in the cache.</p>

<h2 id="optimization-walkthrough">Optimization Walkthrough</h2>

<p>Now that we have some scant basics under our belt, let‚Äôs see
what we can do to tame this unruly beast.</p>

<h3 id="step-1--articlesshow">Step 1 ‚Äì Articles#show</h3>

<p>This is the only page of the app that isn‚Äôt completely dying, so let‚Äôs
start here. For me this page is generally rendering between 150 - 250
ms.</p>

<p>This is not bad but let‚Äôs see if we can get it under 100ms. This
shouldn‚Äôt be too difficult and can likely be accomplished with one or
more of the following techniques:</p>

<ul>
  <li>DB indices on one or more of the foreign keys we‚Äôre using</li>
  <li>AREL Includes to save an extra query or 2</li>
  <li>Counter Cache for comment counts</li>
</ul>

<h3 id="step-2--articlesindex">Step 2 ‚Äì Articles#Index</h3>

<p>Now things will start to get more interesting. For me this page is
completely un-usable at the moment, and it will take a good bit of work
to even get it ‚Äúunder control‚Äù to the point that we can start doing more
refined optimizations.</p>

<p>For starters, try to think about what, in general, is making the page
slow. There are likely a number of culprits, but ultimately even with
some clever DB optimizations in place, we likely just have too much data
to be rendering all of the articles on a single page.</p>

<p>So for starters, look for ways to cut down the number of articles we‚Äôre
rendering on each <code class="highlighter-rouge">GET /articles</code> request (hint hint: pagination‚Ä¶).</p>

<p>Then you should be able to look at some more fine-grained tweaks to the
page as well. This one may be more challenging than <code class="highlighter-rouge">Articles#show</code>, but
try to get it rendering under 200ms.</p>

<h3 id="step-3--dashboardshow">Step 3 ‚Äì Dashboard#show</h3>

<p>Similar to Articles#index, this page will likely be unusable to start
with. However the major problems we need to address will likely be slightly different
in nature ‚Äì While the Index needed to churn through a huge number of
articles in a repetitive fashion, the dashboard needs to ingest data
from across the application‚Äôs schema in order to produce some
statistics.</p>

<p>As such we‚Äôll likely need to use a combination of clever query
optimizations and data or markup caching to get this page under control.</p>

<p>This page is probably the hardest one of the 3, but see if you can get
it to render in under 300ms (ideally without just markup-caching the
whole thing‚Ä¶)</p>

<p><strong>Hint:</strong> One useful technique for dealing with pathologically slow
pages can be to just comment out big chunks of the markup to start.
When a page takes over 30 seconds to render it can be really challenging
to even make progress.</p>

<p>By temporarily removing large chunks of logic from the rendering flow,
we can gradually improve the performance of the page by focusing on
smaller pieces at a time.</p>
:ET