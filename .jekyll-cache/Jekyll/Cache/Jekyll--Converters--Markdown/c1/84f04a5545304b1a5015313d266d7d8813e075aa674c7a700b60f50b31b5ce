I"ˇ><h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>Use <code class="highlighter-rouge">joins</code> to collect information from multiple tables</li>
  <li>Use <code class="highlighter-rouge">group</code> to group results by a common characteristic</li>
  <li>Use <code class="highlighter-rouge">order</code> to order grouped results</li>
  <li>Compare SQL queries to ActiveRecord queries</li>
</ul>

<h2 id="vocabulary">Vocabulary</h2>
<ul>
  <li>SQL Query (Standard Query Language)</li>
  <li>ActiveRecord Query</li>
  <li>joins (JOIN)</li>
  <li>group (GROUP BY)</li>
  <li>order (ORDER BY)</li>
</ul>

<h2 id="warmup">Warmup</h2>

<ul>
  <li>What new ActiveRecord methods did you learn over the weekend?</li>
  <li>How would you do the following in SQL?
    <ul>
      <li>Join results from multiple tables?</li>
      <li>Order results</li>
      <li>Group results</li>
    </ul>
  </li>
</ul>

<h2 id="lecture">Lecture</h2>

<p>Thus far we‚Äôve talked about using ActiveRecord to create, find, and delete records, as well as to find related records on other tables. In your project, you‚Äôve begun using ActiveRecord to query your database for more analytical purposes. Today we‚Äôre going to review three ActiveRecord methods that will help you with some of those analytics.</p>

<p>To give us some context to work within, clone down the <a href="https://github.com/turingschool-examples/roster">roster repo</a>.</p>

<h3 id="joins">Joins</h3>

<p>The <code class="highlighter-rouge">.joins</code> method creates a <code class="highlighter-rouge">JOIN</code> query at the SQL level. What does this do?</p>

<p>Assume we have the following tables.</p>

<p>courses:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>| id | title | description                             |
|----|-------|-----------------------------------------|
| 1  | BE M1 | OOP with Ruby                           |
| 2  | BE M2 | Web Applications with Ruby              |
| 3  | BE M3 | Professional Rails Applications         |
| 4  | BE M4 | Client-Side Development with JavaScript |
</code></pre></div></div>
<p>students:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>| id | first_name | last_name   | course_id | score |
|----|------------|-------------|-----------|-------|
| 1  | Brian      | Zanti       | 1         | 3     |
| 2  | Megan      | McMahon     | 1         | 4     |
| 3  | Josh       | Mejia       | 3         | 2     |
| 4  | Mike       | Dao         | 3         | 3     |
| 5  | Ian        | Douglas     | 2         | 2     |
| 6  | Dione      | Wilson      | 2         | 4     |
| 7  | Cory       | Westerfield | 4         | 3     |
| 8  | Sal        | Espinosa    | 1         | 2     |
</code></pre></div></div>

<p>In another tab, let‚Äôs open a connection to <code class="highlighter-rouge">psql</code></p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ psql
$ \c roster-development
</code></pre></div></div>

<p>If you get an error trying to run the above commands try this instead:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ psql --dbname roster-development
</code></pre></div></div>

<p>A <code class="highlighter-rouge">JOIN</code> query would look something like this:</p>

<pre><code class="language-SQL">SELECT * FROM courses JOIN students ON students.course_id = courses.id;
</code></pre>

<p>And it would result in a table like the following:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>| id | title | description                             | id | first_name | last_name   | course_id | score |
|----|-------|-----------------------------------------|----|------------|-------------|-----------|-------|
| 1  | BE M1 | OOP with Ruby                           | 1  | Brian      | Zanti       | 1         | 3     |
| 1  | BE M1 | OOP with Ruby                           | 2  | Megan      | McMahon     | 1         | 4     |
| 3  | BE M3 | Professional Rails Applications         | 3  | Josh       | Mejia       | 3         | 2     |
| 3  | BE M3 | Professional Rails Applications         | 4  | Mike       | Dao         | 3         | 3     |
| 2  | BE M2 | Web Applications with Ruby              | 5  | Ian        | Douglas     | 2         | 4     |
| 2  | BE M2 | Web Applications with Ruby              | 6  | Dione      | Wilson      | 2         | 2     |
| 4  | BE M4 | Client-Side Development with JavaScript | 7  | Cory       | Westerfield | 4         | 3     |
| 1  | BE M1 | OOP with Ruby                           | 8  | Sal        | Espinosa    | 1         | 2     |
</code></pre></div></div>
<p>Notice that there is duplicated information in the table that resulted from this JOIN.</p>

<p>How does this look in ActiveRecord?</p>

<p>First, in order to create the query, we use the ActiveRecord <code class="highlighter-rouge">.joins</code> method. Note that this is a <strong>class</strong> method. It creates a new table with a row for each record that would be in the resulting table.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In the Course model</span>
<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">with_students</span>
  <span class="n">joins</span><span class="p">(</span><span class="ss">:students</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1"># From Tux</span>
<span class="no">Course</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:students</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">=&gt;</span> <span class="c1">#&lt;ActiveRecord::Relation [#&lt;Course id: 1, title: "BE M1", description: "OOP with Ruby"&gt;, #&lt;Course id: 1, title: "BE M1", description: "OOP with Ruby"&gt;, #&lt;Course id: 1, title: "BE M1", description: "OOP with Ruby"&gt;, #&lt;Course id: 2, title: "BE M2", description: "Web Applications with Ruby"&gt;, #&lt;Course id: 2, title: "BE M2", description: "Web Applications with Ruby"&gt;, #&lt;Course id: 3, title: "BE M3", description: "Professional Rails Applications"&gt;, #&lt;Course id: 3, title: "BE M3", description: "Professional Rails Applications"&gt;, #&lt;Course id: 4, title: "BE M4", description: "Client-Side Development with JavaScript"&gt;]&gt;</span>
</code></pre></div></div>

<p>If we add <code class="highlighter-rouge">.count(:id)</code> to the end of those statements, we will get eight, even though there are only four courses. This is because the resulting table would have eight rows.</p>

<p>The Course objects that are returned from this query will only know about Course attributes. In order to access attributes from both tables, we need to add one more piece:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In the Course model</span>
<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">with_students</span>
  <span class="nb">select</span><span class="p">(</span><span class="s2">"courses.*, students.*"</span><span class="p">).</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:students</span><span class="p">)</span>
<span class="k">end</span>

<span class="c1"># From Tux</span>
<span class="no">Course</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"courses.*, students.*"</span><span class="p">).</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:students</span><span class="p">)</span>
</code></pre></div></div>

<p>With that in place, we can get student attributes out of our Course object, like so:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>From tux
Course.select("courses.*, students.*")
  .joins(:students)
  .first
  .first_name
</code></pre></div></div>

<p>More on how we might use <code class="highlighter-rouge">.joins</code> shortly.</p>

<h3 id="group">Group</h3>

<ul>
  <li>Group will take the result set and condense common rows by performing a calculation on the data.</li>
  <li>We can only group on columns that are part of our ‚Äúselect‚Äù statement.</li>
  <li><strong>We can‚Äôt group data without a calculation (count, sum, average, etc).</strong></li>
</ul>

<p>Example:</p>

<pre><code class="language-SQL"># In SQL:
SELECT students.course_id, count(students.id) AS student_count FROM students GROUP BY students.course_id;
</code></pre>
<p>The return looks something like this:</p>

<pre><code class="language-SQL">course_id  | student_count
-----------+---------------
         3 |             2
         4 |             1
         2 |             2
         1 |             3
(4 rows)
</code></pre>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In the Student model</span>
<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">count_by_course_id</span>
  <span class="n">group</span><span class="p">(</span><span class="ss">:course_id</span><span class="p">).</span><span class="nf">count</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Will return a hash like the following:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="mi">3</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">}</span>
</code></pre></div></div>

<p>The keys are the course_id and the values are the count of how many students in that course.</p>

<p><strong>ActiveRecord will return a hash if we include a .group instruction, and then end our statement with an ‚Äòaggregation‚Äô instruction like .count, .sum or .average</strong> Once ActiveRecord sees that aggregation command, a hash object is returned and no further ActiveRecord commands will work.</p>

<ul>
  <li>in <code class="highlighter-rouge">tux</code>
<code class="highlighter-rouge">Student.group(:course_id).count.order(:course_id)</code></li>
</ul>

<p>If we don‚Äôt want a hash, we have to build our own <code class="highlighter-rouge">.select()</code> statement to get an array of objects instead:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Course</span><span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:students</span><span class="p">).</span><span class="nf">select</span><span class="p">(</span><span class="s2">"courses.id, count(students.id) AS student_count"</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="ss">:id</span><span class="p">)</span>
<span class="n">or</span>
<span class="no">Student</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"course_id, count(id) AS student_count"</span><span class="p">).</span><span class="nf">group</span><span class="p">(</span><span class="ss">:course_id</span><span class="p">)</span>
</code></pre></div></div>

<p>Likewise, using an aggregate function earlier in the ‚Äúchain‚Äù of commands can return a calculation result instead of allowing us to chain additional instructions.</p>

<p>Example in <code class="highlighter-rouge">tux</code>: <code class="highlighter-rouge">Student.count.group(:course_id)</code></p>
<ul>
  <li>tells us we can‚Äôt do a <code class="highlighter-rouge">group</code> operation on an integer because <code class="highlighter-rouge">Student.count</code> returned an integer</li>
</ul>

<h3 id="order">Order</h3>

<p>Assume we want to take the same request, but now sort it by the count, getting the courses with the lowest counts of students first. We could use order.</p>

<pre><code class="language-SQL"># In SQL
SELECT students.course_id, count(students.id) AS student_count FROM students GROUP BY students.course_id ORDER BY student_count;
</code></pre>

<p>This will return us a table like so:</p>

<pre><code class="language-SQL">course_id | student_count
-----------+---------------
         4 |             1
         3 |             2
         2 |             2
         1 |             3
(4 rows)
</code></pre>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># In the Student model</span>
<span class="k">def</span> <span class="nc">self</span><span class="o">.</span><span class="nf">count_by_course_id</span>
  <span class="n">group</span><span class="p">(</span><span class="ss">:course_id</span><span class="p">).</span><span class="nf">order</span><span class="p">(</span><span class="s2">"count_all"</span><span class="p">).</span><span class="nf">count</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Now the resultant hash would look something like the following:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="mi">4</span> <span class="o">=&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span> <span class="o">=&gt;</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span> <span class="o">=&gt;</span> <span class="mi">3</span><span class="p">}</span>
</code></pre></div></div>

<p>Interestingly, if you add a <code class="highlighter-rouge">select</code> clause with a calculation as an argument, it is possible for a <code class="highlighter-rouge">group</code> and <code class="highlighter-rouge">order</code> query to return objects. For example:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Course</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"courses.*, avg(score) AS avg_score"</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">joins</span><span class="p">(</span><span class="ss">:students</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">group</span><span class="p">(</span><span class="ss">:course_id</span><span class="p">,</span> <span class="ss">:id</span><span class="p">)</span>
  <span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"avg_score DESC"</span><span class="p">)</span>
</code></pre></div></div>

<p>This query will return a collection of Course objects. The first will be the Course with the highest avg_score.</p>

<p>We can order by multiple attributes, for example we could order students by last name then first name:
<code class="highlighter-rouge">Student.order("last_name desc, first_name asc")</code></p>

<p>We can also write this in hash notation:
<code class="highlighter-rouge">Student.order(last_name: :desc, first_name: :asc)</code></p>

<h2 id="checks-for-understanding">Checks for Understanding</h2>

<ul>
  <li>What does a <code class="highlighter-rouge">.joins</code> query do in ActiveRecord?</li>
  <li><code class="highlighter-rouge">.group</code>?</li>
  <li><code class="highlighter-rouge">.order</code>?</li>
  <li><code class="highlighter-rouge">.select</code>?</li>
  <li>What does a <code class="highlighter-rouge">.group</code> query return when you have <code class="highlighter-rouge">.count</code> on the end?</li>
  <li>Without it?</li>
</ul>
:ET