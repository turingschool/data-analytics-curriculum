I"ÿ<h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>Understand the basic concepts of Big-O Notation</li>
  <li>Understand why we analyze algorithms in terms of asymptotic and
worst-case performance</li>
  <li>Understand why we care about the algorithmic complexity of our
programs on a practical level</li>
  <li>Explore the performance characteristics of some common ruby operations</li>
</ul>

<h3 id="other-topics">Other Topics</h3>

<ul>
  <li>Big-O (upper bound) vs. Omega Notation (lower bound) vs. Theta Notation (upper and lower bound)</li>
</ul>

<h2 id="structure">Structure</h2>

<ul>
  <li>10 - Warmup Discussion - introduce concept of Big-O</li>
  <li>15 - Example - Video consumption via Amazon delivery vs. downloads</li>
  <li>5 - Break</li>
  <li>25 - Exercise ‚Äì exploring Big-O in Ruby using Arrays and Hashes</li>
  <li>5 - Break</li>
  <li>25 -</li>
</ul>

<h3 id="big-o-notation--what-is-it">Big-O Notation ‚Äì What is it?</h3>

<ul>
  <li>Big-O as shorthand notation vs Big-O as catch-all term for algorithmic
analysis techniques</li>
  <li>Asymptotic Analysis ‚Äì practice of analyzing algorithms‚Äô performance
as they approach some upper bound</li>
  <li>How does asymptotic analysis allow us to simplify the process of
analyzing an algorithm‚Äôs performance?</li>
  <li>Why do we only care about performance of an algo as it reaches a large
upper bound?</li>
</ul>

<h3 id="big-o-notation--real-world-example">Big-O Notation ‚Äì real-world example</h3>

<p>Consider the example of Pierre, a voracious Cinemaphile and Amazon Prime
subscriber. Pierre can access some of the films he wants to view by
downloading them in digital format, but some of them he has to have
shipped from Amazon‚Äôs warehouse.</p>

<p>He can only download 1 film at a time, but he can order as many as he
wants for delivery. However downloading a film takes 2 hours, while
delivery takes 2 days.</p>

<p>How long does it take Pierre to receive 2 films a piece by each delivery
method?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>2 films * 2hrs/film download time = 4 hours
2 films * 2 days delivery time = 2 days
</code></pre></div></div>

<p>Obviously, the download method is faster ‚Äì if Pierre‚Äôs films are
available online, he would be <em>fou</em> not to access them this way.</p>

<p>But what if Pierre is trying to watch <em>a lot</em> of movies? Say, 10,000
movies.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>10000 films * 2hrs/film download time = 20k hours (833 days)
10000 films * 2 days delivery time = 2 days
</code></pre></div></div>

<p><em>ZUT!</em> As we can see, once the number of films (<code class="highlighter-rouge">n</code>) grows above a
certain threshold, delivery overtakes downloading as the most efficient
method of film acces.</p>

<p><strong>Visualizing Algorithmic Performance:</strong></p>

<p>Can we find a way to describe, mathematically, what is happening in the
example above? What would it look like if we plotted these
time-relationships on a simple graph?</p>

<ul>
  <li>Constant time (delivery) vs. Linear time (download)</li>
</ul>

<h3 id="why-care-only-about-performance-for-large-n">Why care only about performance for large N?</h3>

<p>As humans, we might be more likely to deal with 10 films rather than
10000 films. But it turns out that when working with computers we often
<em>do</em> want to deal with the larger number.</p>

<ul>
  <li>How can we analyze an algorithm in terms of its ‚Äúorder of growth‚Äù?</li>
  <li>Startup costs and ‚Äúinitial idiosyncrasies‚Äù ‚Äì need to discount small
constants</li>
  <li>Initial times can be misleading (delivery vs. download) when compared
with growth rates</li>
</ul>

<h3 id="exercise--an-example-in-ruby">Exercise ‚Äì An example in Ruby</h3>

<p>We can find plenty of examples of data structures and algorithms
we use as programmers which exhibit behaviors similar to the example
above. Experiment with 2 ‚Äì looking up elements by value in an array and
a hash</p>

<ul>
  <li>Introduction ‚Äì Ruby‚Äôs Benchmark library</li>
  <li>How do we find a value in an array? In a Hash?</li>
</ul>

<ol>
  <li>Open an IRB session and define 2 methods in it. We‚Äôll use these to
generate sample data for our examination:</li>
</ol>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">array_of_length</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="p">(</span><span class="mi">1</span><span class="o">..</span><span class="n">n</span><span class="p">).</span><span class="nf">to_a</span>
<span class="k">end</span>

<span class="k">def</span> <span class="nf">hash_of_length</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
  <span class="no">Hash</span><span class="p">[(</span><span class="mi">1</span><span class="o">..</span><span class="n">n</span><span class="p">).</span><span class="nf">zip</span><span class="p">((</span><span class="mi">1</span><span class="o">..</span><span class="n">n</span><span class="p">).</span><span class="nf">map</span><span class="p">(</span><span class="o">&amp;</span><span class="ss">:to_s</span><span class="p">))]</span>
<span class="k">end</span>
</code></pre></div></div>

<ol>
  <li>Create a hash of length 10 and an array of length 10 and experiment
with finding different elements. Use benchmark to measure the outputs
of your results:</li>
</ol>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>h = hash_of_length(10)
a = array_of_length(10)
Benchmark.measure { h[10] }.to_s
Benchmark.measure { a.find { |i| i == 10 } }.to_s
</code></pre></div></div>

<ol>
  <li>These results are likely too small to make meaningful inferences
from. Try some larger examples, using lengths of <code class="highlighter-rouge">100</code>, <code class="highlighter-rouge">1000</code>,
<code class="highlighter-rouge">10_000</code>, <code class="highlighter-rouge">100_000</code>, and <code class="highlighter-rouge">1_000_000</code>. In each example find the last
element of the list, and make note of the times you observe.</li>
</ol>

<p><strong>Discussion ‚Äì Order of Growth of reading from a Hash vs. reading from
an Array</strong></p>

:ET