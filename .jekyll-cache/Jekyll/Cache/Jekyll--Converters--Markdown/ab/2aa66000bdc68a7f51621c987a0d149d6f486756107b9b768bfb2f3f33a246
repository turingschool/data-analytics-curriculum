I"+<h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>Understand what a hash function is</li>
  <li>Understand the key characteristics of hash functions that are used to hash passwords</li>
  <li>Become familiar with two of the most common hash functions, MD5 and SHA-256</li>
</ul>

<h2 id="vocabulary">Vocabulary</h2>

<ul>
  <li>Hash Function</li>
  <li>Hash/Digest</li>
  <li>Collision</li>
  <li>Determinism</li>
</ul>

<h1 id="part-1-intro-to-hash-functions">Part 1: Intro to Hash Functions</h1>

<h2 id="what-is-a-hash-function">What is a Hash Function?</h2>

<p><a href="https://en.wikipedia.org/wiki/Hash_function">From Wikipedia</a>: “A hash function is any function that can be used to map data of arbitrary size onto data of a fixed size”.</p>

<p>An important distinction to make here is that a Hash Function is different than a Ruby Hash. They are similar, but not the same thing.</p>

<p>In the following diagram (also from Wikipedia), we are using a Hash Function to take names and map them to numbers.</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/58/Hash_table_4_1_1_0_0_1_0_LL.svg/1920px-Hash_table_4_1_1_0_0_1_0_LL.svg.png" alt="Hash Function" /></p>

<h3 id="vocabulary-1">Vocabulary</h3>

<ul>
  <li><strong>Collision</strong> - When two different inputs map to the same output. You can see this in the example above. Two names map to the same number.</li>
  <li><strong>Hash</strong> or <strong>Digest</strong> - The output of a hash function. There are other names, but those are the two we will use most often.</li>
</ul>

<h3 id="key-characteristics-of-a-hash-function">Key Characteristics of a Hash Function</h3>

<ol>
  <li><strong>Deterministic</strong> - The same input will give the same output</li>
  <li><strong>Collision Resistant</strong> - It is unlikely that different inputs will map to the same output</li>
  <li><strong>Fixed Size Output</strong> - The output will always be the same size no matter the input</li>
</ol>

<h3 id="uses-for-hash-functions">Uses for Hash Functions</h3>

<p>Hash Functions have many uses, including but not limited to storing data (often called Hash Tables), Caching, and finding duplicate records. The SHA-1 hash function is used to create the git commit hash.</p>

<p>The most common and probably most important use of Hash Functions is for storing passwords.</p>

<p><strong>We never ever ever store a user’s raw password in a database.</strong></p>

<p>So instead, we store a hash of their password.</p>

<h3 id="key-characteristics-for-password-hash-functions">Key Characteristics for Password Hash Functions</h3>

<ol>
  <li><strong>One Way</strong> - A hash can be easily computed for an input, but it is infeasible (note: not impossible), to reverse it. In the example above, this would mean that it would be easy to go from a name to a number, but infeasible to go from a number to a name.</li>
  <li><strong>Discontinuous</strong> - Inputs that are similar do not have a similar output. In the example above, if we hashed the name “Sam Do”, it should not be close to the hashed value of 4 for “Sam Doe”.</li>
</ol>

<h1 id="part-2-hashing-exploration">Part 2: Hashing Exploration</h1>

<p>This exploration will use the following two hash functions:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">hash_me_1</span><span class="p">(</span><span class="n">snack</span><span class="p">)</span>
  <span class="n">snack</span><span class="p">.</span><span class="nf">length</span> <span class="o">%</span> <span class="mi">6</span>
<span class="k">end</span>
</code></pre></div></div>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">hash_me_2</span><span class="p">(</span><span class="n">snack</span><span class="p">)</span>
  <span class="n">hash1</span> <span class="o">=</span> <span class="p">(</span><span class="n">snack</span><span class="p">.</span><span class="nf">length</span> <span class="o">*</span> <span class="mi">13</span><span class="p">)</span> <span class="o">%</span> <span class="mi">7</span>
  <span class="n">hash2</span> <span class="o">=</span> <span class="p">(</span><span class="n">snack</span><span class="p">.</span><span class="nf">length</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">6</span>
  <span class="p">((</span><span class="n">hash1</span> <span class="o">+</span> <span class="n">hash2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">7</span><span class="p">).</span><span class="nf">to_s</span> <span class="o">+</span> <span class="n">hash1</span><span class="p">.</span><span class="nf">to_s</span> <span class="o">+</span> <span class="n">hash2</span><span class="p">.</span><span class="nf">to_s</span><span class="p">;</span>
<span class="k">end</span>
</code></pre></div></div>

<p>Process:</p>

<ol>
  <li>Take a snack</li>
  <li>Using <code class="highlighter-rouge">hash_me_1</code> (defined above), compute a digest based on the name of the snack (excluding spaces)</li>
  <li>Place your snack in the bin labeled with the digest you computed</li>
  <li>Discuss with the other people at your bin:
    <ul>
      <li>Does this hash function have the characteristics we discussed earlier?</li>
    </ul>
  </li>
  <li>Repeat steps 2 - 4 for <code class="highlighter-rouge">hash_me_2</code></li>
  <li>Eat snack</li>
</ol>

<h1 id="part-3-hashing-in-action">Part 3: Hashing in Action</h1>

<p>You’ve done some hash building in the physical space. Let’s practice doing it with the machine, using better algorithms.</p>

<h2 id="tools">Tools</h2>

<p>We are going to experiment with two of the most common hash functions:</p>

<ul>
  <li><a href="https://ruby-doc.org/stdlib-2.4.0/libdoc/digest/rdoc/Digest/MD5.html">MD5</a></li>
  <li><a href="https://ruby-doc.org/stdlib-2.1.0/libdoc/digest/rdoc/Digest.html">Sha256</a></li>
</ul>

<p>You should use the <code class="highlighter-rouge">hexdigest</code> method for computing digests for both MD5 and SHA-256.</p>

<h2 id="instructions">Instructions</h2>

<p>We’ll provide timing constraints on the board. If you’re moving quickly and feeling confident, complete the <em>Extension</em> questions. But if you’re not, make sure you complete all the non-Extension exercises first.</p>

<h2 id="activity-1-md5-and-sha-256">Activity 1: MD5 and SHA-256</h2>

<p>Collaborating with the person next to you, experiment and discuss answers to these questions:</p>

<ol>
  <li>What is the MD5 digest of your snack string?</li>
  <li>What is the Sha256 digest of the same string?</li>
  <li>Repeat both MD5 hashing and Sha256 hashing, but change the input to include a one-letter-off typo. What do you notice about the output? What if you add a blank space to the end of the string? What if you change the capitalization of one letter?</li>
  <li>Multiply your string 1000x (like “chipschipschipschips…” and hash it again through each algorithm. What’s notable about the output as compared to previous runs?</li>
</ol>

<p><em>Then, in your own notebook, jot quick notes to solidify your learning:</em></p>

<ol type="a">
  <li>How does a small change to the input of a hash change the output?</li>
  <li>Why does the answer to "A" matter?</li>
  <li>How does a massive change to the size of the input change the output?</li>
  <li>Based on this analysis, can you come up with three potential use cases for hash functions *besides* passwords?</li>
</ol>

<h4 id="extension">Extension</h4>

<p>Feeling good about hashing? Try answering these questions:</p>

<ol>
  <li>Which algorithm (MD5 / Sha256) is faster? Can you prove it using a dataset of at least 200 inputs and calculating the percentage speed difference?</li>
  <li>Is the percentage difference consistent if you increase the size of each individual input data by 100 times?</li>
  <li>Is there a scenario where you’d want to intentionally choose a <em>slower</em> algorithm? Why?</li>
</ol>

<h2 id="activity-2-bad-secrets">Activity 2: Bad Secrets</h2>

<p>Let’s test your understandings by completing this section on your own. Use your pair as a resource if you get stuck, but try to complete the work on your own.</p>

<p>A hashing function is said to be “one-way” which is often useful in security, but it’s not fool-proof. Say you hack into my application and are able to retrieve all my users’ hashed passwords. You find that the account with username <code class="highlighter-rouge">boss@example.com</code> has this hashed password:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>3e40106b8f4332e18d76e94124d9c82a
</code></pre></div></div>

<p>Based on the length of the digest you guess it’s an MD5. You know that some users, particularly bosses, are lazy and they do dumb things like re-use their 4-digit ATM pin for their password. But the application required a password of eight digits, so they might have repeated the pin.</p>

<p><em>Work out answers to the following questions in your notebook:</em></p>

<ol>
  <li>What’s this user’s password?</li>
  <li>Would the user’s password have been “more secure” if they used eight letters rather than eight numbers? Explain your thinking.</li>
</ol>

<h4 id="extension-1">Extension</h4>

<p>A <a href="https://en.wikipedia.org/wiki/Rainbow_table">“rainbow table”</a> makes this reverse engineering much faster.</p>

<ol>
  <li>Can you generate a CSV file that has two columns: the first column contains all possible 8-digit codes following the 4+4 rule above, then the second column has the MD5 digest for that input.</li>
  <li>If you now have an MD5 digest for an input that is expected to follow the 4+4 rule, how long does it take you to “crack” a password using the rainbow table?</li>
  <li>Could you generate a similar table for the all words of eight or more letters in the dictionary? (hint: you have a text file dictionary on your filesystem at <code class="highlighter-rouge">/usr/share/dict/words</code>)</li>
  <li>Some developers choose to make passwords more obscure by applying the hashing algorithm more than once (ie: original input into the algorithm, then that output into the algorithm again). Can you expand your dictionary table with columns for double-hashing, quad-hashing, and octo-hashing? As our time is limited, you might need to constrain your input set ;)</li>
</ol>

<h1 id="checks-for-understanding">Checks for Understanding</h1>

<ul>
  <li>What is a Hash Function?</li>
  <li>What is a Collision?</li>
  <li>Define each of the following Hash Function characteristics and explain why they are important:
    <ul>
      <li>Deterministic</li>
      <li>Collision Resistant</li>
      <li>Fixed Sized Output</li>
      <li>One Way</li>
      <li>Discontinuous</li>
    </ul>
  </li>
</ul>
:ET