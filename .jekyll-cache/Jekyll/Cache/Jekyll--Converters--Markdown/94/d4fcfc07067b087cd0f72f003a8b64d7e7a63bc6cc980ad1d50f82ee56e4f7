I"ß<h2 id="learning-goals">Learning Goals</h2>

<p>By the end of this lesson, you will …</p>

<ul>
  <li>explain what a Promise is</li>
  <li>explain the advantages of using the Fetch API and Promises</li>
  <li>be able to write GET, POST, and DELETE requests using the Fetch API</li>
  <li>be familiar with patterns to organize/refactor fetch requests</li>
</ul>

<h2 id="slides">Slides</h2>

<p>Available <a href="../slides/fetch_refresher">here</a></p>

<h2 id="javascript---synchronous-or-asynchronous">JavaScript - synchronous or asynchronous?</h2>

<ul>
  <li>Only one block of code can run at a time (in the order that it is written/appears)</li>
  <li>JS is only asynchronous in the sense that it can perform some asynchronous operations (non-blocking)</li>
  <li>Tasks that can not be completed immediately are going to complete asynchronously</li>
</ul>

<p>See the <a href="http://backend.turing.io/module4/lessons/asynchronicity-in-javascript">Async JS lesson</a> for a deeper dive!</p>

<p>This means that our code is read and executed line-by-line in the order that it’s written:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">thisFunctionWillExecuteFirst</span><span class="p">();</span>
<span class="nx">thisFunctionWillExecuteSecond</span><span class="p">();</span>
<span class="nx">thisFunctionWillExecuteThird</span><span class="p">();</span>
<span class="nx">thisIsGoingToTakeForever</span><span class="p">();</span>
<span class="nx">iHaveToWaitOnAllTheseOtherSlowPokesAboveMe</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="when-might-we-want-our-code-to-operate-in-an-async-manner">WHEN might we want our code to operate in an async manner?</h3>

<p>The most common example of an async process we will run into on the client-side is a network request. Making a trip to the server can take a significant amount of time, and our applications would be painfully slow if they stopped the rest of our code from executing.</p>

<p>Asynchronous JavaScript will be processed in the background - it will not block the execution of the code that follows it. This comes in handy when we want to pull a slow or expensive operations out of the default synchronous flow of execution.</p>

<p>The hot way to do this right is by using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promises</a>, which handle asynchronous JavaScript.</p>

<h2 id="why-use-promises">Why Use Promises?</h2>

<p>Promises allow you to multi-task a bit in JavaScript. They provide a cleaner and more standardized method of dealing with tasks that need to happen in sequence. (For example, we couldn’t have possibly called <code class="highlighter-rouge">renderDetailsForProjects()</code> until we actually received the projects data from <code class="highlighter-rouge">getProjectsForStudents()</code>). With Promises, we have more control over what happens with the outcomes of our async processes.</p>

<h3 id="an-alternative-to-callbacks">An Alternative to Callbacks</h3>

<p>A Promise is essentially an IOU that says “Ok, I’m going to get you the information you requested, just give me a second. In the meantime, go do whatever else you need to do, and I’ll let you know when I’m ready.” This is almost similar to event listeners that you may have written in the past. Take a click handler for example:</p>

<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">$</span><span class="p">(</span><span class="dl">'</span><span class="s1">#clickity-click</span><span class="dl">'</span><span class="p">).</span><span class="nx">click</span><span class="p">(()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">doSomething</span><span class="p">();</span>
<span class="p">});</span>
</code></pre></div></div>

<p>When this code first executes, it doesn’t actually fire <code class="highlighter-rouge">doSomething()</code>. It simply binds the handler to our <code class="highlighter-rouge">clickity-click</code> element. It says: “Take note of <code class="highlighter-rouge">clickity-click</code> and wait for a user to click on it. Once that event happens, run the <code class="highlighter-rouge">doSomething</code> function.” Recognize how it takes the execution of <code class="highlighter-rouge">doSomething()</code> out of the natural synchronous flow and holds onto it for later – to execute only after a click event has occurred. This is a common convention in client-side JavaScript and is called the <strong>callback pattern</strong>.</p>

<p>The callback pattern, in short, is when you pass a function as an argument to another function to be executed later.  This pattern has historically been wildly popular because it’s easy to implement. But it has a few problems:</p>

<ul>
  <li>You’re giving away your code to be executed later.
    <ul>
      <li>You can hope that this will be when you expect and as many times as you expect. But no promises (pun unintended, but I’m going with it).</li>
    </ul>
  </li>
  <li>Doing things like executing callbacks in parallel and waiting for all of them to come back is tricky.</li>
  <li>Doing things in series where one callback hands its data to the next callback is also tricky. (This has the delightful nickname of “callback hell.”)</li>
  <li>Error handling is inherently broken. There are a bunch of clever ways around this:
    <ul>
      <li>Pass two callbacks—one for a successful outcome and one for an unsuccessful outcome.</li>
      <li>Use the Node.js “error-first” style of callbacks where the first argument is always an error object, which is typically set to <code class="highlighter-rouge">null</code> in the event that we reached a successful outcome. This is incredibly pessimistic.</li>
    </ul>
  </li>
</ul>

<p>Let’s take a look at some more intricate examples of the callback pattern. Using jQuery’s <code class="highlighter-rouge">getJSON</code> method, (which can be written with callbacks <em>or</em> promises), we could make a network request that takes three arguments. The first is the endpoint we want to hit, the second is our success callback and the third is our error callback:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">$</span><span class="p">.</span><span class="nx">getJSON</span><span class="p">(</span><span class="dl">'</span><span class="s1">/api/v1/students.json</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">students</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">students</span><span class="p">);</span>
<span class="p">},</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">error</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// No more access to students out here.</span>
</code></pre></div></div>

<p>In the function above, we need to do everything with <code class="highlighter-rouge">students</code> right then and there. We can’t give ourselves access to <code class="highlighter-rouge">students</code> outside of that success handler. When re-written as a promise, we could access students from anywhere and perform multiple actions on the data when it returns by leveraging <code class="highlighter-rouge">.then()</code>:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">students</span> <span class="o">=</span> <span class="nx">$</span><span class="p">.</span><span class="nx">getJSON</span><span class="p">(</span><span class="dl">'</span><span class="s1">/api/v1/students.json</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">students</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">students</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">doSomethingWithStudents</span><span class="p">(</span><span class="nx">students</span><span class="p">))</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">error</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">({</span> <span class="nx">error</span> <span class="p">}));</span>

<span class="c1">// somewhere else, possibly further down in our code:</span>
<span class="nx">students</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">students</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">doAnotherThingWithStudents</span><span class="p">(</span><span class="nx">students</span><span class="p">));</span>
</code></pre></div></div>

<p>The callback pattern also falls apart when we need to do multiple operations in sequence:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// get the student data</span>
<span class="nx">$</span><span class="p">.</span><span class="nx">getJSON</span><span class="p">(</span><span class="dl">'</span><span class="s1">/api/v1/students.json</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">students</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>

  <span class="c1">// get the projects for all students</span>
  <span class="nx">getProjectsForStudents</span><span class="p">(</span><span class="nx">students</span><span class="p">,</span> <span class="p">(</span><span class="nx">projects</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>

    <span class="c1">// get the grades for each project</span>
    <span class="nx">getGradesForProjects</span><span class="p">(</span><span class="nx">projects</span><span class="p">,</span> <span class="p">(</span><span class="nx">grades</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>

      <span class="c1">// finally, do something with all our student/project/grade data</span>
      <span class="nx">doSomethingImportantWithAllThisData</span><span class="p">(</span><span class="nx">students</span><span class="p">,</span> <span class="nx">projects</span><span class="p">,</span> <span class="nx">grades</span><span class="p">);</span>

    <span class="c1">// handle errors getting student data</span>
    <span class="p">},</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">({</span> <span class="nx">error</span> <span class="p">});</span>
    <span class="p">})</span>

  <span class="c1">// handle errors getting project data</span>
  <span class="p">},</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">({</span> <span class="nx">error</span> <span class="p">});</span>
  <span class="p">})</span>

<span class="c1">// handle errors getting grade data</span>
<span class="p">},</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">({</span> <span class="nx">error</span> <span class="p">});</span>
<span class="p">});</span>

</code></pre></div></div>

<p>Or in other words…</p>

<p><img src="https://pbs.twimg.com/media/COYihdoWgAE9q3Y.jpg" alt="callback hell street fighters" /></p>

<p>Ugh. This is what we refer to as callback hell. The code becomes super nesty and difficult to follow. Without comments, it’s not clear which error callbacks are associated with which operation, and there is a lot of repeat code. When re-written using promises, we can consolidate and flatten a lot of this syntax:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">$</span><span class="p">.</span><span class="nx">getJSON</span><span class="p">(</span><span class="dl">'</span><span class="s1">/api/students.json</span><span class="dl">'</span><span class="p">)</span>
   <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">students</span> <span class="o">=&gt;</span> <span class="nx">getProjectsForStudents</span><span class="p">(</span><span class="nx">students</span><span class="p">))</span>
   <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">projects</span> <span class="o">=&gt;</span> <span class="nx">getGradesForProjects</span><span class="p">(</span><span class="nx">projects</span><span class="p">))</span>
   <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">grades</span> <span class="o">=&gt;</span> <span class="nx">doSomethingImportantWithAllThisData</span><span class="p">(</span><span class="nx">grades</span><span class="p">))</span>
   <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">({</span> <span class="nx">error</span> <span class="p">}));</span>
</code></pre></div></div>

<p>This reads a lot better than that callback example, right? If you came back to this code in a few weeks or months, you’d probably still be able to grok the general idea of what it does.</p>

<p><em>Note: Going forward, it is best to use the <code class="highlighter-rouge">fetch</code> API for making network requests. Using <code class="highlighter-rouge">getJSON</code> in this lesson is purely to demonstrate the difference between a callback implementation and promise implementation. <code class="highlighter-rouge">fetch</code> can only be used with Promises and is steadily becoming the industry standard.</em></p>

<h3 id="advantages-of-promises">Advantages of Promises</h3>
<p>So besides the obvious syntactical benefits, what are some of the others advantages of promises?</p>

<ul>
  <li>You are getting an IOU that you’re holding on to rather than giving your code away as you would with callbacks.</li>
  <li>Error handling is less broken. It’s not a silver bullet. Synchronous functions either <code class="highlighter-rouge">return</code> or throw an error. In a similar vein, your promises will either become <em>resolved</em> by a value or become <em>rejected</em> with an error.</li>
  <li>You can catch errors along the way and deal with them in a way that is <em>similar</em> to synchronous code.</li>
  <li>Chaining promises is easy and does not result in callback hell.</li>
</ul>

<p>But wait, there’s more.</p>

<ul>
  <li><code class="highlighter-rouge">Promise.all</code> takes an array of promises and waits until all of the promises are resolved. This solves the nastiness involved in doing this with callbacks.</li>
  <li><code class="highlighter-rouge">Promise.race</code> takes an array of promises and resolves as soon as any one of them fulfill. This would allow you to hit 3 API endpoints and then move on when we heard back from whichever one came back first.</li>
</ul>

<h2 id="when-to-use-promises">When to use Promises</h2>

<p>Now that we have a better understanding of how and why to use Promises, what about the when? When do you actually want to use a Promise?</p>

<p>The short answer: whenever you’re handed a promise by an API you didn’t write, where the author chose to use promises. This includes many modern browser APIs such as <code class="highlighter-rouge">fetch</code>.</p>

<p>When you read the documentation for a library that uses promises, one of the first sentences will likely say ‘this is a promise-based library’. There are some APIs that still use callbacks rather than promises (the <code class="highlighter-rouge">geolocation</code> API, for example). You’ll want to read the documentation closely to see if the library expects you to use a promise or callback. So for once, we don’t really have to be in charge of making a decision here – we can let the tools and technologies we’re using dictate whether or not we should be using promises.</p>

<h2 id="explore">Explore</h2>

<p>With a partner, use prior knowledge/educated guesses to discuss what you see happening at each line of this function. Also jot down any questions that arise from look at this.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">fetchDiscussions</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">/api/vi/discussions</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">response</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">())</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">rawDiscussions</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">cleanDiscussions</span><span class="p">(</span><span class="nx">rawDiscussions</span><span class="p">))</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">error</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">({</span> <span class="nx">error</span> <span class="p">}));</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="a-typical-fetch-request">A Typical Fetch Request</h2>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">postDiscussions</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">/api/vi/discussions</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">method</span><span class="p">:</span> <span class="dl">'</span><span class="s1">POST</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">headers</span><span class="p">:</span> <span class="p">{</span> <span class="dl">'</span><span class="s1">Content-Type</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">application/json</span><span class="dl">'</span> <span class="p">},</span>
    <span class="na">body</span><span class="p">:</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>
      <span class="na">discussionName</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Foo</span><span class="dl">'</span><span class="p">,</span>
      <span class="na">totalPoints</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
    <span class="p">});</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>What differences do you notice between a GET and POST?</p>

<p><code class="highlighter-rouge">fetch()</code> takes TWO arguments:</p>

<ul>
  <li>URL or API endpoint (always)</li>
  <li>object of configuration settings for the request. This may contain what kind of request we’re making and any data we might need to pass along with it (optional)</li>
</ul>

<h2 id="promises">Promises</h2>

<p>3 states of Promises:</p>

<ul>
  <li>Pending</li>
  <li>Resolved/Fulfilled (with a return value from your async operation)</li>
  <li>Rejected (with an error message from your async operation)</li>
</ul>

<p>Every fetch request we make will return a Promise object that contains our response data. This allows us to easily react to the type of response we get once it’s available.</p>

<p>Handling the response of a fetch request might look something like this:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">/api/v1/discussions</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
  <span class="na">method</span><span class="p">:</span> <span class="dl">'</span><span class="s1">POST</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">headers</span><span class="p">:</span> <span class="p">{</span> <span class="dl">'</span><span class="s1">Content-Type</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">application/json</span><span class="dl">'</span> <span class="p">},</span>
  <span class="na">body</span><span class="p">:</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">({</span>
    <span class="na">discussionName</span><span class="p">:</span> <span class="dl">'</span><span class="s1">Foo</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">totalPoints</span><span class="p">:</span> <span class="mi">100</span><span class="p">,</span>
  <span class="p">})</span>
<span class="p">})</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">response</span> <span class="o">=&gt;</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">())</span>
<span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">discussions</span> <span class="o">=&gt;</span> <span class="nx">renderDiscussions</span><span class="p">(</span><span class="nx">discussions</span><span class="p">))</span>
<span class="p">.</span><span class="k">catch</span><span class="p">((</span><span class="nx">error</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">({</span> <span class="nx">error</span> <span class="p">}))</span>
</code></pre></div></div>

<p>While we wait for the server to return our response, the rest of our application can continue executing other code in the meantime. Once the response object is available, our first <code class="highlighter-rouge">.then()</code> block will fire. The response object returns a lot of extra information that we don’t necessarily need. All we want in this scenario is a JSON object of our discussions data which we can get by calling <code class="highlighter-rouge">response.json()</code>.</p>

<p>Converting the body to a JSON data structure with <code class="highlighter-rouge">response.json()</code> actually returns another Promise. (Converting the data to a particular type can take significant time, which is why we have this additional Promise step before we can begin working with out data.) Because we’re getting another Promise object back, we can simply chain another <code class="highlighter-rouge">.then()</code> block where we actually receive our project data. We can then render it to the DOM with our imaginary <code class="highlighter-rouge">renderDiscussions()</code> function. Notice how we are using another <code class="highlighter-rouge">.then()</code> statement. This is called Promise Chaining. We do this because each <code class="highlighter-rouge">.then()</code> results in a new Promise.</p>

<p>If for any reason the request failed, the <code class="highlighter-rouge">.catch()</code> block will be fired and we will log the error to the console.</p>

<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch">Fetch</a></p>

<h2 id="error-checking">Error Checking</h2>

<p>Check out the example below. Our second button makes an unsuccessful request with a 404 response so why does it seem to still succeed? Read more about error handling <a href="https://css-tricks.com/using-fetch/#article-header-id-5">here</a>.</p>

<p data-height="348" data-theme-id="0" data-slug-hash="aEvBvz" data-default-tab="js,result" data-user="kat3kasper" data-embed-version="2" data-pen-title="Fetch Error Handling" class="codepen">See the Pen <a href="https://codepen.io/kat3kasper/pen/aEvBvz/">Fetch Error Handling</a> by Katelyn Kasperowicz (<a href="https://codepen.io/kat3kasper">@kat3kasper</a>) on <a href="https://codepen.io">CodePen</a>.</p>
<script async="" src="https://production-assets.codepen.io/assets/embed/ei.js"></script>

<p>The promise returned from <code class="highlighter-rouge">fetch()</code> will only reject on network failure or if anything prevented the request from completing. This means it won’t reject on a response of 404 or 500 from the server but will return a <code class="highlighter-rouge">status.ok</code> status set to false.</p>

<p>To handle responses that do not return a successful status, we can create a response handler. If the response is <code class="highlighter-rouge">ok</code> we continue processing the data as we did above. If it is not we use <code class="highlighter-rouge">Promise.reject</code> to trigger our catch handler and pass it an error object with the <code class="highlighter-rouge">status</code>, <code class="highlighter-rouge">statusCode</code> and any addition json information we get from the server.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">function</span> <span class="nx">handleResponse</span><span class="p">(</span><span class="nx">response</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Convert the readable stream to json</span>
  <span class="k">return</span> <span class="nx">response</span><span class="p">.</span><span class="nx">json</span><span class="p">()</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">json</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nx">response</span><span class="p">.</span><span class="nx">ok</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// if the response returns a status code outside of 200-299 throw an error</span>
        <span class="kd">const</span> <span class="nx">error</span> <span class="o">=</span> <span class="p">{</span>
          <span class="na">status</span><span class="p">:</span> <span class="nx">response</span><span class="p">.</span><span class="nx">status</span><span class="p">,</span>
          <span class="na">statusText</span><span class="p">:</span> <span class="nx">response</span><span class="p">.</span><span class="nx">statusText</span><span class="p">,</span>
          <span class="nx">json</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="nb">Promise</span><span class="p">.</span><span class="nx">reject</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span>
      <span class="p">}</span>
      <span class="c1">// if the response is ok return the json object</span>
      <span class="k">return</span> <span class="nx">json</span>
    <span class="p">})</span>
<span class="p">}</span>

<span class="nx">fetch</span><span class="p">(</span><span class="s2">`http://localhost:3000/api/v1/posts`</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">handleResponse</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">data</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// Now data is in a format we are more used to i.e. {"posts": [{"title": "Fetch Refresher", "author": "Katelyn Kasperowicz"},..]}</span>
  <span class="p">})</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="c1">// When there is an error in the handleResponse function we can access the error object given to us by the Promise reject</span>
  <span class="p">})</span>
</code></pre></div></div>

<h2 id="organizing-fetch-requests">Organizing Fetch Requests</h2>

<p>In the examples above, the success or failure of our <code class="highlighter-rouge">fetch()</code> requests are handled by anonymous functions. By changing these, we can start to organize and DRY up our code.</p>

<p>I’d suggest grouping all of these to-be-named functions together (…hint, hint…in a file…).</p>

<p>Let’s refactor this example:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">http://localhost:3000/api/v1/posts</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">handleResponse</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">((</span><span class="nx">posts</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">posts</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">post</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">.posts-box</span><span class="dl">"</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span><span class="nx">post</span><span class="p">)</span>
    <span class="p">})</span>
  <span class="p">})</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">error</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span>
  <span class="p">})</span>
</code></pre></div></div>

<p>Say we created one function responsible for appending posts and another to log our error to the console:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">appendPosts</span> <span class="o">=</span> <span class="p">(</span><span class="nx">posts</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">posts</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">post</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">$</span><span class="p">(</span><span class="dl">"</span><span class="s2">.posts-box</span><span class="dl">"</span><span class="p">).</span><span class="nx">append</span><span class="p">(</span><span class="nx">post</span><span class="p">)</span>
  <span class="p">})</span>
<span class="p">}</span>

<span class="kd">const</span> <span class="nx">errorLog</span> <span class="o">=</span> <span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We could then slim down our <code class="highlighter-rouge">fetch()</code> call to just this:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">http://localhost:3000/api/v1/posts</span><span class="dl">'</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">handleResponse</span><span class="p">)</span>
  <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">appendPosts</span><span class="p">)</span>
  <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">errorLog</span><span class="p">)</span>
</code></pre></div></div>

<p>Notice how we still need to handle the call with <code class="highlighter-rouge">.then()</code> and <code class="highlighter-rouge">.catch().</code></p>

<h3 id="going-further---organizing-requests-as-event-handlers">Going Further - Organizing Requests as Event Handlers</h3>

<p>It’s very likely you’ll be using <code class="highlighter-rouge">fetch()</code> requests as event handlers.</p>

<p>For example, on submit of a form, we make a POST request with the form data.</p>

<p>Just like we organized our <code class="highlighter-rouge">fetch()</code> handlers above, we can organize our event handlers similarly.</p>

<p>If we were working with form data like this:</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nx">$</span><span class="p">(</span><span class="dl">'</span><span class="s1">form</span><span class="dl">'</span><span class="p">).</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">submit</span><span class="dl">'</span><span class="p">,</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">http://example.com/articles</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">method</span><span class="p">:</span> <span class="dl">'</span><span class="s1">post</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">headers</span><span class="p">:</span> <span class="p">{</span>
      <span class="dl">'</span><span class="s1">Content-Type</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">application/json</span><span class="dl">'</span>
    <span class="p">},</span>
    <span class="na">body</span><span class="p">:</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">article</span><span class="p">)</span>
  <span class="p">})</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">handleResponse</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">appendArticle</span><span class="p">)</span>
    <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">errorLog</span><span class="p">)</span>
<span class="p">})</span>
</code></pre></div></div>

<p>We can refactor that so our event bindings live together, our <code class="highlighter-rouge">fetch()</code> calls live together, and our <code class="highlighter-rouge">fetch()</code> handlers live together.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// event bindings live nicely as one liners</span>
<span class="nx">$</span><span class="p">(</span><span class="dl">'</span><span class="s1">form</span><span class="dl">'</span><span class="p">).</span><span class="nx">on</span><span class="p">(</span><span class="dl">'</span><span class="s1">submit</span><span class="dl">'</span><span class="p">,</span> <span class="nx">postArticle</span><span class="p">)</span>

<span class="kd">const</span> <span class="nx">requestOptions</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">method</span><span class="p">:</span> <span class="dl">'</span><span class="s1">post</span><span class="dl">'</span><span class="p">,</span>
  <span class="na">headers</span><span class="p">:</span> <span class="p">{</span> <span class="dl">'</span><span class="s1">Content-Type</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">application/json</span><span class="dl">'</span> <span class="p">},</span>
  <span class="na">body</span><span class="p">:</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">article</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Fetch call is nice and tidy on its own</span>
<span class="kd">const</span> <span class="nx">postArticle</span> <span class="o">=</span> <span class="p">(</span><span class="nx">event</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">event</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">()</span>
  <span class="k">return</span> <span class="nx">fetch</span><span class="p">(</span><span class="dl">'</span><span class="s1">http://example.com/articles</span><span class="dl">'</span><span class="p">,</span> <span class="nx">requestOptions</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">handleResponse</span><span class="p">)</span>
    <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">appendArticle</span><span class="p">)</span>
    <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">errorLog</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="interview-questions">Interview Questions</h2>

<p>Pair up with your Quantified Self partner and practice answering the following interview questions:</p>

<ul>
  <li>What are the advantages of using fetch?</li>
  <li>What are promises used for? Can you give an example of when you’ve used one?</li>
</ul>

<p>Be ready to share you answer(s) with the class when we wrap up.</p>

<h2 id="work-time">Work Time</h2>

<p>Pair up with your Quantified Self partner and discuss the following:</p>

<ul>
  <li>What are some use cases for <code class="highlighter-rouge">fetch()</code>? Name some cards from your project that will require a <code class="highlighter-rouge">fetch()</code> request to complete.</li>
  <li>What information do you need before you can make a <code class="highlighter-rouge">fetch()</code> request?</li>
  <li>How do you access the response from the request?</li>
</ul>

<p>Once you’ve answered those, work to implement the variety of <code class="highlighter-rouge">fetch()</code> requests necessary to GET, POST, DELETE, etc. to the Quantified Self API.</p>

<h2 id="additional-resources">Additional Resources</h2>
<ul>
  <li><a href="https://davidwalsh.name/fetch">David Walsh fetch API</a></li>
  <li><a href="https://css-tricks.com/using-fetch/">CSS Tricks Using Fetch</a></li>
</ul>

<p>Be aware that AJAX can also be used to make client side request to a server. Fetch has become more poplar in recent years as it is built into Javascript, works on almost all browsers, and doesn’t require jQuery. If you want to learn more check out this old lesson <a href="./archive/ajax-refresher.md">AJAX Refresher</a></p>
:ET