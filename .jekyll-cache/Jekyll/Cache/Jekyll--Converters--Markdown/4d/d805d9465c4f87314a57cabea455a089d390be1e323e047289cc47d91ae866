I"-<h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>Understand and Visualize a SQL join query</li>
  <li>Implement an active record query using join</li>
</ul>

<h2 id="warm-up">Warm Up</h2>

<p>For each of the following, what are the SQL and ActiveRecord commands we would use to get this information (in our SetList app):<br />
    - Get all songs<br />
    - Get the lengths of all songs<br />
    - Get the songs with a play count greater than 0<br />
    - Get the titles of the songs with a play count greater than zero, sorted alphabetically<br />
    - Get the length of the song with the most plays</p>

<h2 id="joining-tables">Joining Tables</h2>

<h3 id="the-sql-join-query">The SQL Join Query</h3>

<p>So far, we have looked at SQL and ActiveRecord queries that deal only with one table, or we have asked our database for information related to a single resource.  But you will sometimes need to run queries based on information from more than one table.  When we come up against this problem, we rely on <code class="highlighter-rouge">JOIN</code> queries to accomplish this goal.</p>

<p>At the highest level, a <code class="highlighter-rouge">JOIN</code> pulls information from multiple tables into one temporary table.  Let’s use our SetList app to see how this works.</p>

<p>In your terminal, run the following command to open your set_list_development database <code class="highlighter-rouge">rails dbconsole</code>, and let’s take a look at our <code class="highlighter-rouge">songs</code> and <code class="highlighter-rouge">artists</code> tables:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set_list_development=# SELECT * FROM songs;

id |      title      | length | play_count | artist_id
----+-----------------+--------+------------+-----------
 1 | And She Was     |    234 |         23 |         1
 2 | Wild Wild Life  |    456 |        894 |         1
 3 | Raspberry Beret |    340 |        434 |         2
(3 rows)
</code></pre></div></div>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set_list_development=# SELECT * FROM artists;

id |      name      
----+----------------
 1 | Talking Heads
 2 | Prince
 3 | Zac Brown Band
(3 rows)
</code></pre></div></div>

<p>Above, we see our songs and artists table - what happens if we <code class="highlighter-rouge">JOIN</code> these tables together?</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set_list_development=# SELECT artists.*, songs.* FROM songs JOIN artists ON artists.id = songs.artist_id;

id |     name      | id |      title      | play_count | length | artist_id
----+---------------+----+-----------------+------------+--------+-----------
 1 | Talking Heads |  1 | And She Was     |         23 |    234 |         1
 1 | Talking Heads |  2 | Wild Wild Life  |        894 |    456 |         1
 2 | Prince        |  3 | Raspberry Beret |        434 |    340 |         2
(3 rows)
</code></pre></div></div>

<p><strong>Turn and Talk</strong> What did this query do? How might you describe the return value of this query?</p>

<p>When we run this <code class="highlighter-rouge">JOIN</code>, we are <em>joining</em> the songs and artists tables together to form a return value that is a table that includes all the information from <em>both</em> tables. For each artist, we see a row for each song that they have, with the information from both the artists table and the songs table.</p>

<p>When creating a <code class="highlighter-rouge">JOIN</code> query, there are three parts essential to the query:</p>

<ol>
  <li><code class="highlighter-rouge">SELECT</code> - this is what indicates which columns will be included in the resulting table</li>
  <li><code class="highlighter-rouge">ON</code> - this tells the join <em>how</em> to join this two tables together, or what is the relationship between the two tables (most often, primary key = foreign key)</li>
  <li><code class="highlighter-rouge">JOIN</code> - the command to join to tables together!</li>
</ol>

<p>Looking at our joined table, what information could seem to be missing? What happened to <code class="highlighter-rouge">Zac Brown Band</code>?</p>

<p><strong>Turn and Talk</strong> Why are we not seeing <em>all</em> our artists on this joined table?</p>

<h3 id="types-of-join-queries">Types of Join Queries</h3>

<p>When we create <code class="highlighter-rouge">JOIN</code> queries, there are a handful of different join types that we can declare that will affect the resulting table.  Today, we are going to cover 3 of those join types: <strong>Left Join</strong>, <strong>Inner Join</strong>, and <strong>Right Join</strong></p>

<h4 id="inner-join">Inner Join</h4>

<p>The default <code class="highlighter-rouge">JOIN</code> type in SQL is an <strong>Inner JOIN</strong>.  An inner join will grab only the information from the two tables where the information matches the <code class="highlighter-rouge">ON</code> condition - in our example above, it will grab only information for artists who have songs, and their song information.  This relationship is often visualized like this:</p>

<p><img src="./images/inner_join.png" /></p>

<h4 id="left-join">Left Join</h4>

<p>The next most common <code class="highlighter-rouge">JOIN</code> type is a <strong>Left Join</strong>.  A left join will get all the records from one table, regardless of if they have corresponding rows in the joined table.  If we run a left join in our setlist app, it could look like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set_list_development=# SELECT artists.id, artists.name, songs.id, songs.title FROM artists LEFT JOIN songs ON songs.artist_id = artists.id;
 id |      name      | id |      title      
----+----------------+----+-----------------
  1 | Talking Heads  |  1 | And She Was
  1 | Talking Heads  |  2 | Wild Wild Life
  2 | Prince         |  3 | Raspberry Beret
  3 | Zac Brown Band |    |
(4 rows)
</code></pre></div></div>

<p>Now, we see ‘Zac Brown Band’ even though that artist has no songs.  We visualize this relationship like this:</p>

<p><img src="./images/left_join.png" /></p>

<h3 id="right-join">Right Join</h3>

<p>The last of these join types is a <strong>Right Join</strong> which will get only records from one table if they match with records from the joined table and will get all records from the joined table regardless of if they have a corresponding record from the starting table. We can visualize the join like this:</p>

<p><img src="./images/right_join.png" /></p>

<h3 id="joining-in-activerecord">Joining in ActiveRecord</h3>

<p>So what does all this look like in ActiveRecord?  Open a new tab in your terminal and open your console with <code class="highlighter-rouge">rails c</code>.</p>

<p>In ActiveRecord, similar to how we can create a SQL <code class="highlighter-rouge">WHERE</code> with <code class="highlighter-rouge">.where</code>, we can use <code class="highlighter-rouge">.joins</code> to create a SQL <code class="highlighter-rouge">JOIN</code> query!</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>irb(main):001:0&gt; Artist.joins(:songs)
  Artist Load (3.4ms)  SELECT  "artists".* FROM "artists" INNER JOIN "songs" ON "songs"."artist_id" = "artists"."id" LIMIT $1  [["LIMIT", 11]]

=&gt; #&lt;ActiveRecord::Relation [#&lt;Artist id: 1, name: "Talking Heads", created_at: "2019-05-02 14:51:17", updated_at: "2019-05-02 14:51:17"&gt;,
                             #&lt;Artist id: 1, name: "Talking Heads", created_at: "2019-05-02 14:51:17", updated_at: "2019-05-02 14:51:17"&gt;,
                             #&lt;Artist id: 2, name: "Prince", created_at: "2019-05-02 14:51:18", updated_at: "2019-05-02 14:51:18"&gt;]&gt;
</code></pre></div></div>

<p><strong>Turn and Talk</strong> Why are we not seeing any song information in this ActiveRecord::Relation?</p>

<p>Take a look at the SQL query that is generated with the ActiveRecord method call:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>SELECT  "artists".* FROM "artists" INNER JOIN "songs" ON "songs"."artist_id" = "artists"."id" LIMIT $1  [["LIMIT", 11]]
</code></pre></div></div>

<p>This is only SELECTing from our artists table.  If we want to change what is being SELECTed, we need to manually override the select like this:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>irb(main):014:0&gt; Artist.select('artists.*, songs.*').joins(:songs)
  Artist Load (1.3ms)  SELECT  artists.*, songs.* FROM "artists" INNER JOIN "songs" ON "songs"."artist_id" = "artists"."id" LIMIT $1  [["LIMIT", 11]]
</code></pre></div></div>

<p>Now, we are SELECTing from artists <em>and</em> songs, but has our return value changed? Unfortunately, no. Because we are starting our ActiveRecord query from our Artist model, ActiveRecord will try to create Artist objects from the resulting data; so, we don’t see the song information, but it is actually there!  We can access it on each of the resulting ‘artist’ objects:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>irb(main):015:0&gt; first_record = Artist.select('artists.*, songs.*').joins(:songs).first
  Artist Load (1.8ms)  SELECT  artists.*, songs.* FROM "artists" INNER JOIN "songs" ON "songs"."artist_id" = "artists"."id" ORDER BY "artists"."id" ASC LIMIT $1  [["LIMIT", 1]]
=&gt; #&lt;Artist id: 2, name: "Talking Heads", created_at: "2019-05-02 14:51:18", updated_at: "2019-05-02 14:51:18"&gt;

irb(main):016:0&gt; first_record.title
=&gt; "Wild Wild Life"

irb(main):017:0&gt; first_record.length
=&gt; 456

irb(main):018:0&gt; first_record.play_count
=&gt; 894
</code></pre></div></div>

<h2 id="practice">Practice</h2>

<p>Let’s see this in action by imagining that we might want to be able to get a list of artists who have songs longer than ‘400’.  Work with a partner to get this information using both SQL and ActiveRecord.</p>

<h4 id="sql">SQL</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>set_list_development=# SELECT artists.name FROM artists JOIN songs ON artists.id = songs.artist_id WHERE songs.length &gt; 400;

     name      
---------------
 Talking Heads
(1 row)
</code></pre></div></div>

<h4 id="activerecord">ActiveRecord</h4>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>irb(main):021:0&gt; Artist.joins(:songs).where('songs.length &gt; ?', 400)
  Artist Load (1.1ms)  SELECT  "artists".* FROM "artists" INNER JOIN "songs" ON "songs"."artist_id" = "artists"."id" WHERE (songs.length &gt; 400) LIMIT $1  [["LIMIT", 11]]
=&gt; #&lt;ActiveRecord::Relation [#&lt;Artist id: 1, name: "Talking Heads", created_at: "2019-05-02 14:51:17", updated_at: "2019-05-02 14:51:17"&gt;]&gt;
</code></pre></div></div>

<h2 id="checks-for-understanding">Checks for Understanding</h2>

<ol>
  <li>What are the three types of joins covered today? And, what do they return?</li>
  <li>What is the SQL query to get a list of Artists who have songs that have been played more than 20 times?</li>
  <li>What is the ActiveRecord query to get a list of Artists who have songs that have been played more than 20 times?</li>
  <li>Looking back at your LaughTracks project, what would be the SQL and ActiveRecord queries to get a count of specials for comedians of a certain age?</li>
</ol>
:ET