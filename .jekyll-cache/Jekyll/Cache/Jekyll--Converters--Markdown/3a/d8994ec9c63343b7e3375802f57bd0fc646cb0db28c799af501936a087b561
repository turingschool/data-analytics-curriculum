I"'<h1 id="cool-git-stuff-and-a-reminder-to-be-professional">Cool Git Stuff, and a Reminder to be Professional</h1>

<h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>A few extra git commands and HOW-TO ideas</li>
  <li>shell-based git configuration shortcuts for productivity</li>
  <li>professional use of git</li>
</ul>

<hr />

<h2 id="oh-noes-you-cloned-down-the-wrong-repo-now-what">Oh noes! You cloned down the wrong repo, now what?</h2>

<p>Hint: You don’t need to completely erase your work folder and start all over!</p>

<p>Let’s say you’ve forked a repo from Turing, but you’ve accidentally cloned the Turing repo instead of your own fork. Now what?</p>

<h3 id="enter-git-remotes">Enter: “git remotes”</h3>

<p>A “remote” in git is another git repo that is related to what you already have cloned on your system. The benefit here is that you can pull and push work to different repos.</p>

<p>Instructors may do this at Turing all the time, it’s also very common in the workplace.</p>

<ul>
  <li>we clone a Turing project to our laptop</li>
  <li>we fork a copy of the repo</li>
  <li>we add a ‘remote’ to the repo
    <ul>
      <li><code class="highlighter-rouge">git remote -v</code> will show you the remote “name” and the URL path to the repo</li>
      <li>Ian likes to change “origin” to something more meaningful, like “turing” if it’s the Turing URL, and “mine” if it’s his own GitHub account
        <ul>
          <li><code class="highlighter-rouge">git remote rename origin turing</code></li>
        </ul>
      </li>
    </ul>
  </li>
  <li>we make changes and push the work to our own fork
    <ul>
      <li><code class="highlighter-rouge">git push mine master</code></li>
    </ul>
  </li>
  <li>then we make a pull request from our fork to Turing’s repo</li>
</ul>

<hr />

<h2 id="did-you-know">Did you know…?</h2>

<p>If you fork somebody’s repo, and that other person later deletes their repo, you also lose your forked copy of that repo?</p>

<p>Never fear!</p>

<p>If you have cloned their repo or your forked copy to your local system, create a new repo on GitHub with the same name, and then run <code class="highlighter-rouge">git push -u (remote_name) master</code> and you have your own copy for reference later on!</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>hub create old-repo-name
created repository: iandouglas/old-repo-name
</code></pre></div></div>

<p>Normally this <code class="highlighter-rouge">hub create</code> command would set a new “origin” remote. If you <em>already</em> have an origin remote, <code class="highlighter-rouge">hub create</code> WILL NOT CHANGE your old remote name. You may need to add a new remote for your own GitHub account.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git remote rename origin old_origin
<span class="nv">$ </span>git remote add origin git@github.com:your_github_username/old-repo-name
</code></pre></div></div>

<p>And now we can save our work by pushing our local code to our repo on GitHub:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git push <span class="nt">-u</span> origin master
</code></pre></div></div>

<hr />

<h2 id="squashing-commits">Squashing Commits</h2>

<p>Many open-source contributions will want you to “squash” your commits to remove unnecessary “work in progress” markers
or commit messages that aren’t helpful for tracking your progress along the way. Some workplaces will encourage
squashing unhelpful commit messages, but will generally discourage squashing ALL commit messages to a single commit.</p>

<h3 id="scenario">Scenario</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># you've cloned a repo, and you make a feature branch</span>
<span class="nv">$ </span>git checkout <span class="nt">-b</span> new-branch

<span class="c"># you edit some files and leave for lunch but want to commit your work first</span>
<span class="nv">$ </span>git add &lt;list of files&gt;
<span class="nv">$ </span>git commit <span class="nt">-m</span><span class="s2">"morning work in progress"</span>

<span class="c"># after lunch you do more work and want to commit before you leave work for the day</span>
<span class="nv">$ </span>git add &lt;list of files&gt;
<span class="nv">$ </span>git commit <span class="nt">-m</span><span class="s2">"afternoon work in progress"</span>

<span class="c"># repeat for every day you work</span>
</code></pre></div></div>

<p>Suddenly your log history starts to look like:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>| * 60ae30c wip
| * d0129b5 wip
| * aed52c2 wip
| * c7a5ac7 wip
| * 124578a wip
| * 3562c99 wip
| * ee1d6a6 wip
| * d256033 wip
</code></pre></div></div>

<p>What if you could finish a portion of your work, undo all of those commit messages, and leave one meaningful commit
instead?</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># rewind 5 commits, but keep all altered files</span>
<span class="nv">$ </span>git reset HEAD~5

<span class="c"># now you can add/stage and commit all of that work in one commit</span>
<span class="nv">$ </span>git add &lt;list of files&gt;
<span class="nv">$ </span>git commit <span class="nt">-m</span><span class="s2">"database integration done, more work needed on UI"</span>
</code></pre></div></div>

<p>This is <strong>extremely</strong> helpful when rebasing as well, so you can squash all feature work down into fewer commits.</p>

<h3 id="disadvantages">Disadvantages</h3>

<ul>
  <li>You lose the incremental work history of how you’ve built your project.
    <ul>
      <li>You can still find them in your local work history (sometimes) but work you push to GitHub will lose that history.</li>
    </ul>
  </li>
  <li>Hiring managers and tech leads who evaluate your GitHub history may want to see your actual workflow so it doesn’t appear that you created all portions of a feature in one “perfect” commit.</li>
</ul>

<hr />

<h2 id="gitconfig--command-line-shortcuts-for-git">.gitconfig – Command Line shortcuts for git</h2>

<p>You probably already have a <code class="highlighter-rouge">.gitconfig</code> file in your <code class="highlighter-rouge">$HOME</code> folder (ie, <code class="highlighter-rouge">/Users/username/gitconfig</code>)</p>

<h2 id="aliases-for-shortcuts">Aliases for shortcuts</h2>

<p>Add a section to your <code class="highlighter-rouge">.gitconfig</code> to create shortcut aliases for things you do frequently</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[alias]
  co = checkout
  st = status
</code></pre></div></div>

<p>Save and close the file, and now you’ll have access to shorter commands such as:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git co your-branch
<span class="nv">$ </span>git st
</code></pre></div></div>

<p>Some cool shortcuts:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[alias]

  last = !sh -c 'test "$#" = 1 &amp;&amp; git log -$1 HEAD || git log -1 HEAD' -
  # What is it:  retrieve only the last 'n' log entries
  # Usage:       git last 5
  # Notes:       If you don't include a numeric value, it will default to 1


  br = branch -v
  # What is it:  show all local branches
  # Usage:       git br


  cleanup = !git branch --merged master | grep -v 'master$' | xargs git branch -d
  # What is it:  delete any local branch which has already been merged to master
  # Usage:       git cleanup


  unstage = reset HEAD --
  # What is it:  reverse any files you've staged for commits, without losing your work
  # Usage:       git unstage


  graph = log --oneline --decorate --all --graph
  # What is it:  see an ASCII-branched history of your repo
  # Usage:       git graph
</code></pre></div></div>

<p>Other Alias resources:</p>

<p>Be careful not to just “copy and paste” these and use them without understanding them:</p>

<ul>
  <li><a href="https://dev.to/megamattmiller/the-git-aliases-that-get-me-to-friday-1cmj">https://dev.to/megamattmiller/the-git-aliases-that-get-me-to-friday-1cmj</a></li>
  <li><a href="https://dev.to/nickytonline/my-git-aliases-5dea">https://dev.to/nickytonline/my-git-aliases-5dea</a></li>
  <li><a href="http://durdn.com/blog/2012/11/22/must-have-git-aliases-advanced-examples/">http://durdn.com/blog/2012/11/22/must-have-git-aliases-advanced-examples/</a></li>
</ul>

<hr />

<h2 id="being-professional-with-git">Being Professional with Git</h2>

<p>We all get frustrated, and sometimes we want to take it out on our poor, little github commit messages.</p>

<p>Be careful though: <a href="https://twitter.com/gitlost">https://twitter.com/gitlost</a> (warning, contains lots of profanity!)</p>

<p>Employers will likely be looking through your GitHub repos, seeing how you built your projects, as part of evaluating you as a potential candidate for a job. Do you REALLY want them seeing commit messages full of swearing, or loads and loads of “this isn’t working” / “this still isn’t working” / “why the #$%^ isn’t this working?!” commit messages?</p>

<p>No, of course not.</p>

<p>Employers also want to see what goes on in your group projects (like how well the workload was split among everyone) and how well you communicate with one another. Having civil and meaningful conversation with groupmates through GitHub comments (not just on Slack) is a great way to indicate to employers that you are happy to keep open and friendly communication going with your team.</p>
:ET