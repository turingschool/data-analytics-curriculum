I"C<h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>Students can explain the concept of acceptance testing</li>
  <li>Students can explain feature testing and how it relates to acceptance testing</li>
  <li>Students can translate a story into an executable acceptance test</li>
  <li>Students can describe the different perspectives of an acceptance/feature tester versus a unit-tester/implementer</li>
</ul>

<p>Mastery Expectation: HIGH. By the end of this lesson, students should feel completely confident in the definitions and expectations of topics covered here.</p>

<h2 id="plan">Plan</h2>

<h3 id="lecturediscussion-45-minutes">Lecture/Discussion (45 Minutes)</h3>

<p>Walk through the tutorial/discussion below to highlight key points and answer questions.</p>

<h3 id="group-activity-30-minutes">Group Activity (30 Minutes)</h3>

<p>In your project groups:</p>

<ol>
  <li>Pick a single story from your project tracker</li>
  <li>Individually sketch out an acceptance test using capybara syntax</li>
  <li>Compare/contrast your sketched test implementation to look for differences and similarities</li>
  <li>Together brainstorm features tests so you have one feature test per group member</li>
  <li>Each take one unique feature test and sketch and implementation</li>
  <li>If you have time, review each other’s sketches</li>
</ol>

<h3 id="group-review-15-minutes">Group Review (15 Minutes)</h3>

<p>We have one or two individuals show off what they and their group wrote. We look out for any questions or misunderstandings.</p>

<h2 id="tutorial">Tutorial</h2>

<p>Let’s recap and dive a little deeper into testing. We use the terms “acceptance tests” and “feature tests” to mean almost the same thing – with a nuanced difference.</p>

<h3 id="acceptance-tests-emulate-end-users">Acceptance Tests Emulate End Users</h3>

<p>Acceptance tests exercise your application <em>just like a real user</em>. They therefore depend on the full stack from your models up through your controllers, helpers, view templates, web server, database, and middleware.</p>

<p>Acceptance tests are typically a translation of a user story:</p>

<pre><code class="language-plain">As a [user]
When I [do action]
  and [do other action]
Then I observe [result 1]
  and observe [result 2]
</code></pre>

<p>Proper acceptance tests use your application as a <em>black box</em>. They know nothing about what happens under the hood, they just interact with the interface and observe the results.</p>

<p>Acceptance tests are the 30,000-foot view of your application. They’re focused on the happy-path, the business value driving the creation of the application.</p>

<p>When your user stories have been translated to acceptance tests and those tests pass, then your application is finished! Until the product owner writes more stories…</p>

<p><strong>Every completed story should have one or more acceptance tests that are a translation of the story into executable code</strong>.</p>

<h3 id="feature-tests-are-for-clients--developers">Feature Tests are for Clients &amp; Developers</h3>

<p>But there are often a lot of details a little bit under the surface. What about when things go wrong? What happens when a user tries to save an article without a title? Or a title that’s too short?</p>

<p>Maybe your product owner has infinite time to be writing stories for every edge case. But, more than likely, they need you to fill in the gaps, to anticipate what’s going to go wrong. We can use several feature tests to drive more of the development.</p>

<h3 id="breaking-down-an-example">Breaking Down an Example</h3>

<p>Let’s talk about creating an article on a blog.</p>

<h4 id="acceptance-test">Acceptance Test</h4>

<p>The acceptance test might go like this:</p>

<pre><code class="language-plain">As an authenticated user
  and I'm on the articles index
When I click the new article link
  and I enter a title
  and I enter a body
  and I click the submit button
Then I observe the title I entered
  and I observe the body I entered
</code></pre>

<p>That’s the happy path. Translated to Minitest and Capybara, that might go like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_an_authenticated_user_creates_an_article</span>
  <span class="n">login_as_user</span> <span class="c1"># you'd write this method elsewhere</span>
  <span class="n">visit</span> <span class="n">article_path</span>
  <span class="n">click_on</span><span class="p">(</span><span class="s1">'new-article'</span><span class="p">)</span>
  <span class="n">fill_in</span><span class="p">(</span><span class="s1">'title'</span><span class="p">,</span> <span class="ss">:with</span> <span class="o">=&gt;</span> <span class="s2">"My Tester Title"</span><span class="p">)</span>
  <span class="n">fill_in</span><span class="p">(</span><span class="s1">'body'</span><span class="p">,</span> <span class="ss">:with</span> <span class="o">=&gt;</span> <span class="s2">"My Tester Body"</span><span class="p">)</span>
  <span class="n">click_on</span><span class="p">(</span><span class="s1">'save'</span><span class="p">)</span>
  <span class="n">assert</span> <span class="n">page</span><span class="p">.</span><span class="nf">has_css?</span><span class="p">(</span><span class="s2">"#title"</span><span class="p">,</span> <span class="ss">:text</span> <span class="o">=&gt;</span> <span class="s2">"My Tester Title"</span><span class="p">)</span>
  <span class="n">assert</span> <span class="n">page</span><span class="p">.</span><span class="nf">has_css?</span><span class="p">(</span><span class="s2">"#body"</span><span class="p">,</span> <span class="ss">:text</span> <span class="o">=&gt;</span> <span class="s2">"My Tester Body"</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h4 id="feature-tests">Feature Tests</h4>

<p>The feature tests drill down just a bit deeper:</p>

<h5 id="create-and-redirect">Create and Redirect</h5>

<p>The concept of the feature could be characterized like this, even if we don’t write it as a story:</p>

<pre><code class="language-plain">As an authenticated user
  and I'm on the new article page
When I enter a title
  and I enter a body
  and I click the submit button
Then I am redirected to the article page
</code></pre>

<p>Seems pretty much the same? The detail about being redirected is key – a typical user doesn’t care whether their browser is redirected or not. They just want to see the content they expect. This test is starting to move towards characterizing the implemention.</p>

<p>Turing this ides into executable code:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_an_authenticated_user_creates_an_article</span>
  <span class="n">login_as_user</span>
  <span class="n">visit</span> <span class="n">new_article_path</span>
  <span class="n">fill_in</span><span class="p">(</span><span class="s1">'title'</span><span class="p">,</span> <span class="ss">:with</span> <span class="o">=&gt;</span> <span class="s2">"Hello, World"</span><span class="p">)</span>
  <span class="n">fill_in</span><span class="p">(</span><span class="s1">'body'</span><span class="p">,</span> <span class="ss">:with</span> <span class="o">=&gt;</span> <span class="s2">"My Tester Body"</span><span class="p">)</span>
  <span class="n">click_on</span><span class="p">(</span><span class="s1">'save'</span><span class="p">)</span>
  <span class="n">id_from_path</span> <span class="o">=</span> <span class="n">current_path</span><span class="p">.</span><span class="nf">scan</span><span class="p">(</span><span class="sr">/\d+$/</span><span class="p">).</span><span class="nf">first</span>
  <span class="n">assert_match</span> <span class="n">article_path</span><span class="p">(</span><span class="n">id_from_path</span><span class="p">),</span> <span class="n">current_path</span>
<span class="k">end</span>
</code></pre></div></div>

<h5 id="body-is-required">Body is Required</h5>

<p>Then I start thinking about problems that are likely to pop up:</p>

<pre><code class="language-plain">As an authenticated user
  and I'm on the new article page
When I enter a title
  but I do not enter a body
  and I click the submit button
Then I am returned to the form
  and I see an error message that a body is required
</code></pre>

<p>This requirement might get overlooked by the product owner, but as a responsible developer I need to be thinking about what happens when things go wrong. Implemented with Capybara:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_an_authenticated_user_creates_an_article</span>
  <span class="n">login_as_user</span>
  <span class="n">visit</span> <span class="n">new_article_path</span>
  <span class="n">fill_in</span><span class="p">(</span><span class="s1">'title'</span><span class="p">,</span> <span class="ss">:with</span> <span class="o">=&gt;</span> <span class="s2">"Hello, World"</span><span class="p">)</span>
  <span class="n">fill_in</span><span class="p">(</span><span class="s1">'body'</span><span class="p">,</span> <span class="ss">:with</span> <span class="o">=&gt;</span> <span class="s2">""</span><span class="p">)</span>
  <span class="n">click_on</span><span class="p">(</span><span class="s1">'save'</span><span class="p">)</span>
  <span class="n">assert_equal</span> <span class="n">new_article_path</span><span class="p">,</span> <span class="n">current_path</span>
  <span class="n">assert</span> <span class="n">page</span><span class="p">.</span><span class="nf">has_css?</span><span class="p">(</span><span class="s2">"#error"</span><span class="p">,</span> <span class="ss">:text</span> <span class="o">=&gt;</span> <span class="s2">"body"</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h5 id="titles-are-unique">Titles Are Unique</h5>

<p>Or a different kind of problem:</p>

<pre><code class="language-plain">As an authenticated user
  and I'm on the new article page
  and there's an article in the system with the title "Hello, World"
When I enter a title of "Hello, World"
  and I enter a body
  and I click the submit button
Then I am returned to the form
  and I see an error message that the title has already been used
</code></pre>

<p>Implemented with Capybara:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">test_an_authenticated_user_creates_an_article</span>
  <span class="n">login_as_user</span>
  <span class="n">visit</span> <span class="n">new_article_path</span>
  <span class="n">create_article</span><span class="p">(</span><span class="ss">:title</span> <span class="o">=&gt;</span> <span class="s2">"Hello, World"</span><span class="p">)</span> <span class="c1"># write this method elsewhere</span>
  <span class="n">fill_in</span><span class="p">(</span><span class="s1">'title'</span><span class="p">,</span> <span class="ss">:with</span> <span class="o">=&gt;</span> <span class="s2">"Hello, World"</span><span class="p">)</span>
  <span class="n">fill_in</span><span class="p">(</span><span class="s1">'body'</span><span class="p">,</span> <span class="ss">:with</span> <span class="o">=&gt;</span> <span class="s2">"My Tester Body"</span><span class="p">)</span>
  <span class="n">click_on</span><span class="p">(</span><span class="s1">'save'</span><span class="p">)</span>
  <span class="n">assert_equal</span> <span class="n">new_article_path</span><span class="p">,</span> <span class="n">current_path</span>
  <span class="n">assert</span> <span class="n">page</span><span class="p">.</span><span class="nf">has_css?</span><span class="p">(</span><span class="s2">"#error"</span><span class="p">,</span> <span class="ss">:text</span> <span class="o">=&gt;</span> <span class="s2">"title"</span><span class="p">)</span>
<span class="k">end</span>
</code></pre></div></div>

<h3 id="maintaining-the-veil">Maintaining the Veil</h3>

<p>Both acceptance and feature tests should know very little about how your application is setup internally. If the tests need data to exist before they can demonstrate functionality then the test needs to create that data first.</p>

<p>But that can be a real pain, not to mention slow. Imagine you’re writing a suite of tests focused on the admin functionality in your application. If you keep your suite conceptually pure, then <strong>every test</strong> needs to start with:</p>

<ul>
  <li>Register a new user</li>
  <li>Confirm a user</li>
  <li>Upgrade the user to an administrator (how does this even happen?)</li>
</ul>

<p>Each of those happens <em>before</em> you get to the meat of the test. You could easily wait a second for all that to complete, end up with a slow test suite, and either (A) waste development time or (B) stop running the tests. Both are bad.</p>

<h4 id="making-compromises">Making Compromises</h4>

<p>When you write these kinds of tests you’ll have to make compromises. But you want to <em>encapsulate</em> those cheats so you can easily change them later.</p>

<p>In the examples above, we used this method:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>login_as_user
</code></pre></div></div>

<p>You can assume what that method does, but how does it do it? From the test, <em>you don’t care</em>. By abstracting the steps for that method, the test can maintain a consistent level of abstraction from the application’s implementation.</p>

<p><em>Inside</em> the method, it very well might do something like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">login_as_user</span>
  <span class="n">visit</span> <span class="n">new_user_path</span>
  <span class="n">fill_in</span> <span class="s2">"name"</span><span class="p">,</span> <span class="ss">:with</span> <span class="o">=&gt;</span> <span class="s2">"Sample User"</span>
  <span class="n">fill_in</span> <span class="s2">"password"</span><span class="p">,</span> <span class="ss">:with</span> <span class="o">=&gt;</span> <span class="s2">"samplepass"</span>
  <span class="n">fill_in</span> <span class="s2">"password_confirmation"</span><span class="p">,</span> <span class="ss">:with</span> <span class="o">=&gt;</span> <span class="s2">"samplepass"</span>
  <span class="n">click_on</span> <span class="s2">"save"</span>
  <span class="n">visit</span> <span class="n">login_path</span>
  <span class="n">fill_in</span> <span class="s2">"name"</span><span class="p">,</span> <span class="ss">:with</span> <span class="o">=&gt;</span> <span class="s2">"Sample User"</span>
  <span class="n">fill_in</span> <span class="s2">"password"</span><span class="p">,</span> <span class="ss">:with</span> <span class="o">=&gt;</span> <span class="s2">"samplepass"</span>
  <span class="n">click_on</span> <span class="s2">"login"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>But that’s slow, right? You could also implement it in a way that reaches directly into the application to shorten the process:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">login_as_user</span>
  <span class="no">User</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">:name</span> <span class="o">=&gt;</span> <span class="s2">"Sample User"</span><span class="p">,</span> <span class="ss">:password</span> <span class="o">=&gt;</span> <span class="s2">"samplepass"</span><span class="p">)</span>
  <span class="n">visit</span> <span class="n">login_path</span>
  <span class="n">fill_in</span> <span class="s2">"name"</span><span class="p">,</span> <span class="ss">:with</span> <span class="o">=&gt;</span> <span class="s2">"Sample User"</span>
  <span class="n">fill_in</span> <span class="s2">"password"</span><span class="p">,</span> <span class="ss">:with</span> <span class="o">=&gt;</span> <span class="s2">"samplepass"</span>
  <span class="n">click_on</span> <span class="s2">"login"</span>
<span class="k">end</span>
</code></pre></div></div>

<p>This compromise saves a bit of test time but also emulates the user’s experience.</p>

<h4 id="diving-in">Diving In</h4>

<p>Once you have the feature test in place, it’s time to switch roles. You move over the the implementer, the developer who understands how things are put together on the inside. If helpful, you start writing unit tests. You build up functionality until that feature test passes.</p>

<p>Then you switch back to the outside perspective. Does the acceptance test now pass? If not, what could be the next feature test? Write it, then switch back to the implementer side with unit tests. Repeat until your acceptance test passes.</p>
:ET