I"|É<p>This lesson plan last updated to work with Rails 5.1.2 and Ruby 2.4.1</p>

<h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>Understand caching as a performance optimization tool</li>
  <li>Practice analyzing our applications to identify performance problems</li>
  <li>Practice using Rails‚Äô built-in caching facilities</li>
</ul>

<h2 id="discussion--what-is-caching">Discussion ‚Äì What is Caching?</h2>

<p>Frequently as developers we‚Äôll run into situations when we need to make
something in our programs faster.</p>

<p>With user-facing web applications in particular, we‚Äôre constrained
by a request/response cycle that needs to be kept fast ‚Äì anything over about 200ms
starts to feel slow and clunky to the user.</p>

<p>So we need to make something faster. We have a couple of choices:</p>

<ul>
  <li><strong>1:</strong> Speed up the underlying process</li>
  <li><strong>2:</strong> Figure out a way to get rid of the underlying process (at least some of the time)</li>
</ul>

<p>When looking at the list it seems like a no-brainer ‚Äì just choose number 1, make
your things fast, and then the problems go away!</p>

<p>Unfortunately it turns out that #1 is often pretty hard. In fact in some situations
it may be actually impossible (see <a href="https://en.wikipedia.org/wiki/NP-complete">NP-Completeness</a>).</p>

<p>So often in application development we turn to choice 2 ‚Äì caching.</p>

<h2 id="ok-but-what-actually-is-caching">Ok but what actually is caching</h2>

<p>In short, caching is an optimization technique focusing on
saving the results of a computation so that we can retrieve it again later
without having to re-do the original calculation.</p>

<p>To a certain extent, caching is a ‚Äúnon-optimizing optimization‚Äù ‚Äì we don‚Äôt actually make
the underlying pieces any faster, but we make the application <strong>seem</strong> faster by limiting
our usage of the slow pieces.</p>

<p>Let‚Äôs look at a simple example in ruby using a hypothetical pizza store:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PizzaShop</span>
  <span class="k">def</span> <span class="nf">make_me_a_pizza</span><span class="p">(</span><span class="n">type</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="s2">"cooking up your </span><span class="si">#{</span><span class="n">type</span><span class="si">}</span><span class="s2"> pizza"</span>
    <span class="nb">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
    <span class="s2">"One tasty </span><span class="si">#{</span><span class="n">type</span><span class="si">}</span><span class="s2"> pizza"</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="no">PizzaShop</span><span class="p">.</span><span class="nf">new</span><span class="p">.</span><span class="nf">make_me_a_pizza</span><span class="p">(</span><span class="s2">"anchovy"</span><span class="p">)</span>
<span class="n">cooking</span> <span class="n">up</span> <span class="n">your</span> <span class="n">anchovy</span> <span class="n">pizza</span>
<span class="c1"># (dramatic pause)</span>
<span class="o">=&gt;</span> <span class="s2">"One tasty anchovy pizza"</span>
</code></pre></div></div>

<p>As we can see, the pizza production process is currently pretty slow.
Perhaps our pizza chefs are napping on the job. Let‚Äôs see if we can speed it up
with a cache:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">PizzaShop</span>

  <span class="k">def</span> <span class="nf">pizza_cache</span>
    <span class="vi">@pizza_cache</span> <span class="o">||=</span> <span class="p">{}</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">make_me_a_pizza</span><span class="p">(</span><span class="n">type</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="s2">"cooking up your </span><span class="si">#{</span><span class="n">type</span><span class="si">}</span><span class="s2"> pizza"</span>
    <span class="c1">#first, check if this type of za is in the cache:</span>
    <span class="k">if</span> <span class="n">pizza_cache</span><span class="p">[</span><span class="n">type</span><span class="p">]</span>
      <span class="n">pizza_cache</span><span class="p">[</span><span class="n">type</span><span class="p">]</span>
    <span class="k">else</span>
      <span class="nb">sleep</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
      <span class="n">cooked_pizza</span> <span class="o">=</span> <span class="s2">"One tasty </span><span class="si">#{</span><span class="n">type</span><span class="si">}</span><span class="s2"> pizza"</span>
      <span class="n">pizza_cache</span><span class="p">[</span><span class="n">type</span><span class="p">]</span> <span class="o">=</span> <span class="n">cooked_pizza</span>
      <span class="n">cooked_pizza</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">shop</span> <span class="o">=</span> <span class="no">PizzaShop</span><span class="p">.</span><span class="nf">new</span>
<span class="n">shop</span><span class="p">.</span><span class="nf">make_me_a_pizza</span><span class="p">(</span><span class="s2">"anchovy"</span><span class="p">)</span>
<span class="n">cooking</span> <span class="n">up</span> <span class="n">your</span> <span class="n">anchovy</span> <span class="n">pizza</span>
<span class="c1"># (dramatic pause)</span>
<span class="o">=&gt;</span> <span class="s2">"One tasty anchovy pizza"</span>
<span class="n">shop</span><span class="p">.</span><span class="nf">make_me_a_pizza</span><span class="p">(</span><span class="s2">"anchovy"</span><span class="p">)</span>
<span class="n">cooking</span> <span class="n">up</span> <span class="n">your</span> <span class="n">anchovy</span> <span class="n">pizza</span>
<span class="c1"># (instantaneous)</span>
<span class="o">=&gt;</span> <span class="s2">"One tasty anchovy pizza"</span>
</code></pre></div></div>

<p>Let‚Äôs talk through it. We‚Äôve inserted a cache in the pizza-production-pathway.
The first time someone requests a pizza of a specific type, we still have the same
3-second delay. But after we make that pizza the first time, we store it.</p>

<p>After that, subsequent requests for the same pizza type can be served instantly.</p>

<h3 id="caching-limitations">Caching Limitations</h3>

<p>Let‚Äôs think about some of the limitations of our trivial cache example:</p>

<ul>
  <li>What happens if we request a different pizza type?</li>
  <li>What happens if we make a new pizza shop?</li>
  <li>What happens if we change the underlying technique of making a pizza?</li>
</ul>

<p>It‚Äôs important to remember that while caching is a very useful technique,
it does have limitations.</p>

<h3 id="discussion---caching-in-rails">Discussion - Caching in Rails?</h3>

<p>What sorts of things might we want to cache in a Rails app?
(try to list at least 4 common sources of performance problems in a typical web app)</p>

<p>Fortunately this is such a common use-case that Rails includes built-in support
for it via the cache helper. Let‚Äôs take a look.</p>

<h2 id="workshop--caching-in-rails">Workshop ‚Äì Caching in Rails</h2>

<p>For this exercise we‚Äôll use the storedom repo. Get set up with it via the
ever-familiar process:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/turingschool-examples/storedom-5 caching_strategies
cd caching_strategies
bundle
bundle exec rake db:{drop,setup}
</code></pre></div></div>

<p><strong>Demo ‚Äì looking for performance bottlenecks</strong></p>

<p><em>Observe while I run through the app and talk about looking for problems</em></p>

<p>Looks like we got some issues in the <code class="highlighter-rouge">Items#index</code> action. Let‚Äôs cache it</p>

<h3 id="step-1--enable-caching-in-development">Step 1 ‚Äì enable caching in development</h3>

<p>(by default rails turns off caching in development, so let‚Äôs turn that on)</p>

<p>In <code class="highlighter-rouge">config/environments/development.rb</code>:</p>

<p>Change this:</p>
<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">if</span> <span class="no">Rails</span><span class="p">.</span><span class="nf">root</span><span class="p">.</span><span class="nf">join</span><span class="p">(</span><span class="s1">'tmp/caching-dev.txt'</span><span class="p">).</span><span class="nf">exist?</span>
    <span class="n">config</span><span class="p">.</span><span class="nf">action_controller</span><span class="p">.</span><span class="nf">perform_caching</span> <span class="o">=</span> <span class="kp">true</span>

    <span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="ss">:memory_store</span>
    <span class="n">config</span><span class="p">.</span><span class="nf">public_file_server</span><span class="p">.</span><span class="nf">headers</span> <span class="o">=</span> <span class="p">{</span>
      <span class="s1">'Cache-Control'</span> <span class="o">=&gt;</span> <span class="s2">"public, max-age=</span><span class="si">#{</span><span class="mi">2</span><span class="p">.</span><span class="nf">days</span><span class="p">.</span><span class="nf">seconds</span><span class="p">.</span><span class="nf">to_i</span><span class="si">}</span><span class="s2">"</span>
    <span class="p">}</span>
  <span class="k">else</span>
    <span class="n">config</span><span class="p">.</span><span class="nf">action_controller</span><span class="p">.</span><span class="nf">perform_caching</span> <span class="o">=</span> <span class="kp">false</span>

    <span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="ss">:null_store</span>
  <span class="k">end</span>

</code></pre></div></div>

<p>to:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">config</span><span class="p">.</span><span class="nf">action_controller</span><span class="p">.</span><span class="nf">perform_caching</span> <span class="o">=</span> <span class="kp">true</span>

    <span class="n">config</span><span class="p">.</span><span class="nf">cache_store</span> <span class="o">=</span> <span class="ss">:memory_store</span>
    <span class="n">config</span><span class="p">.</span><span class="nf">public_file_server</span><span class="p">.</span><span class="nf">headers</span> <span class="o">=</span> <span class="p">{</span>
      <span class="s1">'Cache-Control'</span> <span class="o">=&gt;</span> <span class="s2">"public, max-age=</span><span class="si">#{</span><span class="mi">2</span><span class="p">.</span><span class="nf">days</span><span class="p">.</span><span class="nf">seconds</span><span class="p">.</span><span class="nf">to_i</span><span class="si">}</span><span class="s2">"</span>
    <span class="p">}</span>

</code></pre></div></div>

<p>What does <code class="highlighter-rouge">'Cache-Control' =&gt; "public, max-age=#{2.days.seconds.to_i}"</code> do?</p>

<p>(Don‚Äôt forget to restart your server after making this change)</p>

<p>Why do you need to restart your server?</p>

<h3 id="step-2--cache-those-items">Step 2 ‚Äì cache those items</h3>

<p>Let‚Äôs head over to the Items#index template (<code class="highlighter-rouge">app/views/items/index.html.erb</code>) and add some caching.
Again, rails anticipates this very common use-case, so they give us a helper to make it as easy
as possible. The caching helper looks like this:</p>

<p><code class="highlighter-rouge">cache { "some work to generate the cached data" }</code></p>

<p>The cache helper will look to see if the thing you are requesting has already been done. If so, it will serve
the result to you immediately. If not, it will generate it (using the provided block), and save the result in
the cache.</p>

<p><strong>Demonstration ‚Äì Caching <code class="highlighter-rouge">Item.all</code> render loop</strong></p>

<ul>
  <li>Wrap item iteration block in template in a cache block</li>
  <li>Reload the page twice to demonstrate the <code class="highlighter-rouge">Items.all</code> query disappearing from the logs</li>
  <li><strong>Question:</strong> Why does the query only disappear the <em>second</em> time we load the page?</li>
</ul>

<h3 id="step-3--items-count">Step 3 ‚Äì Items count</h3>

<p>We got rid of the <code class="highlighter-rouge">SELECT items.* from items</code> query by caching the item rendering, but we‚Äôre still seeing
a count query for displaying the number of items.</p>

<p>Let‚Äôs fix that one by adding a second cache block around the item header. Your template will look something
like this:</p>

<div class="language-erb highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"container"</span><span class="nt">&gt;</span>
  <span class="cp">&lt;%</span> <span class="n">cache</span> <span class="k">do</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"row"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"col-sm-12"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;h1&gt;</span><span class="cp">&lt;%=</span> <span class="vi">@items</span><span class="p">.</span><span class="nf">count</span> <span class="cp">%&gt;</span> Items<span class="nt">&lt;/h1&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
  <span class="nt">&lt;/div&gt;</span>
  <span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
  <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"row"</span><span class="nt">&gt;&lt;/div&gt;</span>
  <span class="cp">&lt;%</span> <span class="n">cache</span> <span class="k">do</span> <span class="cp">%&gt;</span>
  <span class="cp">&lt;%</span> <span class="vi">@items</span><span class="p">.</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">item</span><span class="o">|</span> <span class="cp">%&gt;</span>
    <span class="nt">&lt;div</span> <span class="na">class=</span><span class="s">"col-sm-3"</span><span class="nt">&gt;</span>
      <span class="nt">&lt;h5&gt;</span><span class="cp">&lt;%=</span> <span class="n">item</span><span class="p">.</span><span class="nf">name</span> <span class="cp">%&gt;</span><span class="nt">&lt;/h5&gt;</span>
      <span class="cp">&lt;%=</span> <span class="n">link_to</span><span class="p">(</span><span class="n">image_tag</span><span class="p">(</span><span class="n">item</span><span class="p">.</span><span class="nf">image_url</span><span class="p">),</span> <span class="n">item_path</span><span class="p">(</span><span class="n">item</span><span class="p">))</span> <span class="cp">%&gt;</span>
      <span class="nt">&lt;p&gt;</span>
        <span class="cp">&lt;%=</span> <span class="n">item</span><span class="p">.</span><span class="nf">description</span> <span class="cp">%&gt;</span>
      <span class="nt">&lt;/p&gt;</span>
    <span class="nt">&lt;/div&gt;</span>
  <span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
  <span class="cp">&lt;%</span> <span class="k">end</span> <span class="cp">%&gt;</span>
<span class="nt">&lt;/div&gt;</span>
</code></pre></div></div>

<p>Refresh the page to see what you‚Äôve done.</p>

<p><strong>Holy duplicating counts, batman!</strong> We did get rid of the additional count query. But now our page is all
messed up. It‚Äôs rendering the count information twice in place of the list of items.</p>

<p>What‚Äôs missing here is a <strong>cache key</strong>. We‚Äôre storing different pieces of data in our cache, and we need a way
to differentiate them.</p>

<p><strong>Cache Keys ‚Äì Unlocking the Path to Greatness</strong></p>

<p>We‚Äôll talk more about cache keys in a future lesson, but for now, think back to the <code class="highlighter-rouge">PizzaShop</code> example from above.</p>

<p>In that case the ‚Äúpizza type‚Äù we were providing was serving as a ‚Äúkey‚Äù ‚Äì a way of matching the specific piece of
information we requested with what had already been stored in the cache.</p>

<p>If we didn‚Äôt use pizza types to label the data in the cache, a user might come in asking for ‚Äúpepperoni‚Äù pizza and
get back ‚Äúanchovy and blue cheese‚Äù. Which is effectively what‚Äôs happening in our current example.</p>

<h3 id="step-4--differentiating-cached-data-with-keys">Step 4 ‚Äì Differentiating Cached Data With Keys</h3>

<p>Fortunately Rails anticipates our need again here.</p>

<p>By default the <code class="highlighter-rouge">cache</code> helper caches data by
controller action. That is, the current controller and action are used as the key. However, we
often will want to cache multiple different things per action. To do this, we need to give
some additional, optional parameters to the <code class="highlighter-rouge">cache</code> helper, like so:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">div</span> <span class="k">class</span><span class="o">=</span><span class="s2">"container"</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="sx">% cache(action: </span><span class="s2">"index"</span><span class="p">,</span> <span class="ss">action_suffix: </span><span class="s2">"items_count"</span><span class="p">)</span> <span class="k">do</span> <span class="sx">%&gt;
  &lt;div class="row"&gt;</span>
    <span class="o">&lt;</span><span class="n">div</span> <span class="k">class</span><span class="o">=</span><span class="s2">"col-sm-12"</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;&lt;</span><span class="sx">%= @items.count %&gt; Items&lt;/h1&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;% end %&gt;
&lt;% cache(action: "index", action_suffix: "items_list") do %&gt;
  &lt;div class=</span><span class="s2">"row"</span><span class="o">&gt;&lt;</span><span class="sr">/div&gt;
  &lt;% @items.each do |item| %&gt;
    &lt;div class="col-sm-3"&gt;
      &lt;h5&gt;&lt;%= item.name %&gt;&lt;/</span><span class="n">h5</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="sx">%= link_to(image_tag(item.image_url), item_path(item)) %&gt;
      &lt;p&gt;
        &lt;%=</span> <span class="n">item</span><span class="p">.</span><span class="nf">description</span> <span class="sx">%&gt;
      &lt;/p&gt;</span>
    <span class="o">&lt;</span><span class="sr">/div&gt;
  &lt;% end %&gt;
&lt;% end %&gt;
&lt;/</span><span class="n">div</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>Refresh the page and you should see it rendering correctly again. Additionally, check
your server logs to see that the server is now reading and writing 2 distinct fragments.</p>

<p>Caching different portions of the page individually like this is often referred to as ‚Äúfragment caching‚Äù</p>

<h4 id="cache-keys--alternate-api">Cache Keys ‚Äì Alternate API</h4>

<p>Sometimes explicitly providing an ‚Äúaction‚Äù and ‚Äúsuffix‚Äù label
can be a bit tedious. Fortunately the <code class="highlighter-rouge">cache</code> helper also
accepts a simple string as a key (similar to our pizza example).</p>

<p>So alternatively, we could have written our cache keys like this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">div</span> <span class="k">class</span><span class="o">=</span><span class="s2">"container"</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="sx">% cache("items-count") </span><span class="k">do</span> <span class="sx">%&gt;
  &lt;div class="row"&gt;</span>
    <span class="o">&lt;</span><span class="n">div</span> <span class="k">class</span><span class="o">=</span><span class="s2">"col-sm-12"</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;&lt;</span><span class="sx">%= @items.count %&gt; Items&lt;/h1&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;% end %&gt;
&lt;% cache("items-list") do %&gt;
  &lt;div class=</span><span class="s2">"row"</span><span class="o">&gt;&lt;</span><span class="sr">/div&gt;
  &lt;% @items.each do |item| %&gt;
    &lt;div class="col-sm-3"&gt;
      &lt;h5&gt;&lt;%= item.name %&gt;&lt;/</span><span class="n">h5</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="sx">%= link_to(image_tag(item.image_url), item_path(item)) %&gt;
      &lt;p&gt;
        &lt;%=</span> <span class="n">item</span><span class="p">.</span><span class="nf">description</span> <span class="sx">%&gt;
      &lt;/p&gt;</span>
    <span class="o">&lt;</span><span class="sr">/div&gt;
  &lt;% end %&gt;
&lt;% end %&gt;
&lt;/</span><span class="n">div</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>Just remember ‚Äì the burden is on us as the developer to make sure
these keys are properly unique. Otherwise we‚Äôll be right back
where we started with duplicated pieces of markup showing up
in the wrong places.</p>

<p>And keep in mind that cache keys are shared over the entire application. So if we have something called ‚Äúitems-list‚Äù on our index page
as well as something called ‚Äúitems-list‚Äù on our show page, they <em>will</em> collide. This can be a very frustrating source of bugs.</p>

<h2 id="your-turn--caching-order-count-and-orders-list">Your Turn ‚Äì Caching Order Count and Orders List</h2>

<p>Apply the same techniques we just used on Items#index to Orders#index</p>

<ul>
  <li>Load the page and observe what‚Äôs going on in your server logs. Especially pay attention
to the response time and any SQL queries that are being executed</li>
  <li>Use the <code class="highlighter-rouge">cache</code> helper to individually cache the count and list of orders. Make sure
to use the <code class="highlighter-rouge">action</code> and <code class="highlighter-rouge">action_suffix</code> parameters to differentiate your fragments.</li>
  <li>Once you‚Äôre done, reload the page and watch for differences in the log output. You should
see fewer SQL queries and probably also a small improvement in response time.</li>
</ul>

<h3 id="step-6--cache-invalidation-a-better-way">Step 6 ‚Äì Cache Invalidation: A Better Way</h3>

<p>We‚Äôll actually want to look at another caching mechanism ‚Äì using an explicit cache key.
Using an explicit key requires a bit more forethought, but it gives us more control over the expiry
conditions.</p>

<p>Furthermore, it can give us a cleaner solution than having to manually expire cache fragments
from within our models (which shouldn‚Äôt be concerned with things like caching in the first place).</p>

<p><strong>Discussion</strong> - Let‚Äôs think about what information might be useful for generating a cache key for
our list of items.</p>

<p>Ultimately we can infer whether there have been any item updates based on these pieces of information:</p>

<ul>
  <li>The maximum ‚Äúupdated_at‚Äù timestamp across all items</li>
  <li>The count of all items</li>
</ul>

<p>Let‚Äôs change our
the caching implementations in our view templates to use this approach:</p>

<p>In <code class="highlighter-rouge">app/views/items/index.html.erb</code>:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">div</span> <span class="k">class</span><span class="o">=</span><span class="s2">"container"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="sx">% cache </span><span class="s2">"items-count-</span><span class="si">#{</span><span class="no">Item</span><span class="p">.</span><span class="nf">count</span><span class="si">}</span><span class="s2">-</span><span class="si">#{</span><span class="no">Item</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="ss">:updated_at</span><span class="p">)</span><span class="si">}</span><span class="s2">"</span> <span class="k">do</span> <span class="sx">%&gt;
  &lt;div class="row"&gt;</span>
    <span class="o">&lt;</span><span class="n">div</span> <span class="k">class</span><span class="o">=</span><span class="s2">"col-sm-12"</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;&lt;</span><span class="sx">%= @items.count %&gt; Items&lt;/h1&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;% end %&gt;
  &lt;div class=</span><span class="s2">"row"</span><span class="o">&gt;&lt;</span><span class="sr">/div&gt;
  &lt;% cache "items-list-</span><span class="si">#{</span><span class="no">Item</span><span class="p">.</span><span class="nf">count</span><span class="si">}</span><span class="sr">-</span><span class="si">#{</span><span class="no">Item</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="ss">:updated_at</span><span class="p">)</span><span class="si">}</span><span class="sr">" do %&gt;
  &lt;% @items.each do |item| %&gt;
    &lt;div class="col-sm-3"&gt;
      &lt;h5&gt;&lt;%= item.name %&gt;&lt;/</span><span class="n">h5</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="sx">%= link_to(image_tag(item.image_url), item_path(item)) %&gt;
      &lt;p&gt;
        &lt;%=</span> <span class="n">item</span><span class="p">.</span><span class="nf">description</span> <span class="sx">%&gt;
      &lt;/p&gt;</span>
    <span class="o">&lt;</span><span class="sr">/div&gt;
  &lt;% end %&gt;
  &lt;% end %&gt;
&lt;/</span><span class="n">div</span><span class="o">&gt;</span>
</code></pre></div></div>

<p><strong>Discussion</strong> ‚Äì Talk about explicit/manual cache keys.</p>

<p>Are there any tradeoffs involved in this approach? What
are the potential downsides?</p>

<ul>
  <li>We‚Äôre incurring a higher cost now whenever we want to check
the cache key (since we have to first check the count and max timestamp of the items)</li>
  <li>In exchange for this penalty, we get more accurate cache updating without having to include manual expiration callbacks
elsewhere in our code.</li>
  <li>On the other hand, the manual expiration approach allows
us to achieve faster <em>reads</em> in exchange for clunkier <em>writes</em></li>
</ul>

<p>As with everything in software development, we simply have to weigh these pros and cons to decide which tradeoff is more worthwhile.</p>

<p>In some situations, it may be perfectly fine to <em>not explicitly update the cache at all</em>. Instead, we might simply say ‚Äúlet this cache expire after 30 minutes‚Äù, regardless of what data changes
may have taken place.</p>

<p><strong>One More Thing ‚Äì Refactoring With a Cache Key Helper</strong></p>

<p>It‚Äôs kind of a drag to have this string interpolation for generating the cache keys
just hanging out in our templates. Let‚Äôs use a helper to pull it out:</p>

<p>(In <code class="highlighter-rouge">app/helpers/application_helper.rb</code>)</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">module</span> <span class="nn">ApplicationHelper</span>
  <span class="k">def</span> <span class="nf">cache_key_for</span><span class="p">(</span><span class="n">model_class</span><span class="p">,</span> <span class="n">label</span> <span class="o">=</span> <span class="s2">""</span><span class="p">)</span>
    <span class="n">prefix</span> <span class="o">=</span> <span class="n">model_class</span><span class="p">.</span><span class="nf">to_s</span><span class="p">.</span><span class="nf">downcase</span><span class="p">.</span><span class="nf">pluralize</span>
    <span class="n">count</span> <span class="o">=</span> <span class="n">model_class</span><span class="p">.</span><span class="nf">count</span>
    <span class="n">max_updated</span> <span class="o">=</span> <span class="n">model_class</span><span class="p">.</span><span class="nf">maximum</span><span class="p">(</span><span class="ss">:updated_at</span><span class="p">)</span>
    <span class="p">[</span><span class="n">prefix</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">max_updated</span><span class="p">].</span><span class="nf">join</span><span class="p">(</span><span class="s2">"-"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre></div></div>

<p>And now we can use that helper in our template instead of interpolating things in-place:</p>

<p>(In <code class="highlighter-rouge">app/views/items/index.html.erb</code>):</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="n">div</span> <span class="k">class</span><span class="o">=</span><span class="s2">"container"</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="sx">% cache </span><span class="n">cache_key_for</span><span class="p">(</span><span class="no">Item</span><span class="p">,</span> <span class="s2">"count"</span><span class="p">)</span> <span class="k">do</span> <span class="sx">%&gt;
  &lt;div class="row"&gt;</span>
    <span class="o">&lt;</span><span class="n">div</span> <span class="k">class</span><span class="o">=</span><span class="s2">"col-sm-12"</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="n">h1</span><span class="o">&gt;&lt;</span><span class="sx">%= @items.count %&gt; Items&lt;/h1&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;% end %&gt;
  &lt;div class=</span><span class="s2">"row"</span><span class="o">&gt;&lt;</span><span class="sr">/div&gt;
  &lt;% cache cache_key_for(Item, "list") do %&gt;
  &lt;% @items.each do |item| %&gt;
    &lt;div class="col-sm-3"&gt;
      &lt;h5&gt;&lt;%= item.name %&gt;&lt;/</span><span class="n">h5</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="sx">%= link_to(image_tag(item.image_url), item_path(item)) %&gt;
      &lt;p&gt;
        &lt;%=</span> <span class="n">item</span><span class="p">.</span><span class="nf">description</span> <span class="sx">%&gt;
      &lt;/p&gt;</span>
    <span class="o">&lt;</span><span class="sr">/div&gt;
  &lt;% end %&gt;
  &lt;% end %&gt;
&lt;/</span><span class="n">div</span><span class="o">&gt;</span>
</code></pre></div></div>

<h2 id="your-turn-key-based-expiration-for-orders">Your Turn: Key-Based Expiration for Orders</h2>

<p>Take the techniques we just used to move Items#index from manual expiration
to key-based expiration. Additionally, tidy up the remaining bits of code
we left around from <code class="highlighter-rouge">Item</code>:</p>

<ul>
  <li>Use the <code class="highlighter-rouge">cache_key_for</code> helper to generate explicit cache keys for the 2 cached
fragments in Orders#index</li>
  <li>Remove the associated cache callbacks from <code class="highlighter-rouge">Item</code> and <code class="highlighter-rouge">Order</code></li>
  <li>Make sure that things are still updating properly when you create or update
an order.</li>
</ul>

<h2 id="next-steps--if-you-finish-all-of-the-steps-above-consider-the-following-challenges">Next Steps ‚Äì If you finish all of the steps above, consider the following challenges</h2>

<ul>
  <li>Russian-doll caching: Currently we‚Äôre caching all of the items and orders as a single blob.
Can you update your solution to cache the records as a group <em>as well as</em> each individual
record by itself? Refer to <a href="http://guides.rubyonrails.org/caching_with_rails.html#fragment-caching">this section of the Rails guides</a>
to get started.</li>
  <li>Dependent update ‚Äì Currently we‚Äôre expiring the order display when an order is updated,
but what would happen if an item associated with an order was updated (perhaps it changes
its name)? At that point the order listing would be incorrect. Fortunately ActiveRecord
gives us a <code class="highlighter-rouge">touch</code> option on <code class="highlighter-rouge">belongs_to</code> associations to help in this situation. Consult
<a href="http://guides.rubyonrails.org/association_basics.html#touch">this section</a> of the Rails Guides
to see how it works. Add this to your Item&lt;-&gt;Order association to get order display to update
when a relevant item is updated.</li>
  <li>A different storage mechanism: We haven‚Äôt really touched on the question of where the
cached data is stored. By default rails actually uses the file system to store cached
data. Can you update it to use Memcached instead? You‚Äôll want to use <a href="http://guides.rubyonrails.org/caching_with_rails.html#activesupport-cache-memcachestore">this section</a>
of the Rails guides as well as some googling to get started. Some of the issues
you‚Äôll need to address include: installing memcached (via brew); using the dalli
gem to access it; configuring rails to use memcached as its cache store.</li>
</ul>
:ET