I"~[<h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>Write SQL statements using <code class="highlighter-rouge">select</code>, <code class="highlighter-rouge">where</code>, <code class="highlighter-rouge">order</code>, <code class="highlighter-rouge">limit</code>, and <code class="highlighter-rouge">distinct</code>.</li>
  <li>Translate SQL statements into ActiveRecord</li>
</ul>

<h2 id="vocabulary">Vocabulary</h2>

<ul>
  <li>SQL</li>
  <li>ActiveRecord</li>
  <li>Tables</li>
  <li>Rows</li>
  <li>Columns</li>
  <li>Keyword Arguments</li>
</ul>

<h2 id="review-intermission-work">Review Intermission Work</h2>

<ul>
  <li>With a partner:
    <ul>
      <li>Review the “Checks for Understanding” from the <a href="../intermission_work/sql">SQL Intermission Work</a></li>
    </ul>
  </li>
  <li>Review CFU questions as a class</li>
</ul>

<h1 id="lecture">Lecture</h1>

<p>In this lesson, we will be writing both raw SQL and ActiveRecord. In order to see both, we are going to open two tabs in Terminal in our SetList app (you can do this with the <code class="highlighter-rouge">cmd + t</code> shortcut).</p>

<p>In the first tab, open a connection to our SetList database:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ rails dbconsole
</code></pre></div></div>

<p>The default convention for your database name is whatever your app name is appended with <code class="highlighter-rouge">_development</code>.</p>

<p>Use <code class="highlighter-rouge">select * from songs;</code> to see what data we’ve seeded into our database. You can also open up your database in Postico to see what data we’ve seeded.</p>

<p>In the second tab, open up the Rails console with <code class="highlighter-rouge">rails console</code> or <code class="highlighter-rouge">rails c</code>. This will allow us to interact with our application directly. We can use this to execute ActiveRecord queries.</p>

<h2 id="select-all-records-from-a-table">Select all records from a table</h2>

<h3 id="sql">SQL</h3>

<p>From our psql connection we can get all of the Song entries in the database with:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">songs</span><span class="p">;</span>
</code></pre></div></div>

<p>Whenever we are querying the database (as opposed to inserting or modifying), we need to specify both <strong>what</strong> we want and <strong>where</strong> we want it from. We use <code class="highlighter-rouge">select</code> to specify what we want (in this case <code class="highlighter-rouge">*</code> meaning “everything”). We use <code class="highlighter-rouge">from</code> to specify where we want it from (in this case the <code class="highlighter-rouge">songs</code> table).</p>

<p>Every sql statement we use to query the database will have a <code class="highlighter-rouge">select</code> and a <code class="highlighter-rouge">from</code> clause.</p>

<h3 id="activerecord">ActiveRecord</h3>

<p>Let’s take a look at the equivalent ActiveRecord for this sql query:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Song</span><span class="p">.</span><span class="nf">all</span>
</code></pre></div></div>

<p>Under the hood, ActiveRecord is transforming our Ruby into sql. We can see this using the <code class="highlighter-rouge">to_sql</code> command:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Song</span><span class="p">.</span><span class="nf">all</span><span class="p">.</span><span class="nf">to_sql</span>
<span class="o">=&gt;</span> <span class="s2">"SELECT </span><span class="se">\"</span><span class="s2">songs</span><span class="se">\"</span><span class="s2">.* FROM </span><span class="se">\"</span><span class="s2">songs</span><span class="se">\"</span><span class="s2">"</span>
</code></pre></div></div>

<p>And we see that the sql is functionally the same (although AR is using <code class="highlighter-rouge">songs.*</code> rather than just <code class="highlighter-rouge">*</code>).</p>

<p>A couple of things to note here:</p>

<ul>
  <li>In ActiveRecord, we use the model, <code class="highlighter-rouge">Song</code>, to start our queries, even though the table is called <code class="highlighter-rouge">songs</code>.</li>
  <li>We don’t have to write the <code class="highlighter-rouge">from</code> clause in ActiveRecord. ActiveRecord will assume that you are working with the table associated with the model you’re using. In this case, the <code class="highlighter-rouge">Song</code> model is associated with the <code class="highlighter-rouge">songs</code> table.</li>
  <li>We also don’t have to write the <code class="highlighter-rouge">select</code> clause. ActiveRecord assumes you are selecting everything from the table you’re working with.</li>
</ul>

<h2 id="selecting-specific-columns">Selecting specific columns</h2>

<h3 id="sql-1">SQL</h3>

<p>Sometimes, you don’t want to select <em>everything</em> from a table. For instance, you might just want to get all of the song titles:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="n">songs</span><span class="p">.</span><span class="n">title</span> <span class="k">from</span> <span class="n">songs</span><span class="p">;</span>
</code></pre></div></div>

<p>This is important because you can optimize your queries by only selecting what you need.</p>

<p>A key point here: our sql statements <strong>return new tables</strong>. This table has a single column, the title. This is not a table that is saved in a database, but one that we can use in-memory.</p>

<h3 id="activerecord-1">ActiveRecord</h3>

<p>We can do the same thing in AR with:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Song</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:title</span><span class="p">)</span>
</code></pre></div></div>

<p>We can do the same thing with a string:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Song</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"title"</span><span class="p">)</span>
</code></pre></div></div>

<p>Previously, we saw that AR will automatically select everything when we did <code class="highlighter-rouge">Song.all</code>. If we provide a <code class="highlighter-rouge">select</code> clause, it will override that.</p>

<p>Notice that this is returning an instance of <code class="highlighter-rouge">ActiveRecord::Relation</code>. We know our sql statements return tables, which ActiveRecord represents as <code class="highlighter-rouge">ActiveRecord::Relation</code> objects. You can think of it as an Array where each element is a row. We can interact with it like so:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="n">songs</span> <span class="o">=</span> <span class="no">Song</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="s2">"title"</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;ActiveRecord::Relation [#&lt;Song id: nil, title: "Don't Stop Believin'"&gt;, #&lt;Song id: nil, title: "Don't Worry Be Happy"&gt;, #&lt;Song id: nil, title: "Chicken Fried"&gt;, #&lt;Song id: nil, title: "Radioactive"&gt;]&gt;</span>

<span class="o">&gt;</span> <span class="n">songs</span><span class="p">.</span><span class="nf">first</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Song id: nil, title: "Don't Stop Believin'"&gt;</span>

<span class="o">&gt;</span> <span class="n">songs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;Song id: nil, title: "Don't Worry Be Happy"&gt;</span>
</code></pre></div></div>

<p>Notice how each of the Songs in this relation is missing values for <code class="highlighter-rouge">id</code>, <code class="highlighter-rouge">length</code>, and <code class="highlighter-rouge">play_count</code>. That’s because we only selected the <code class="highlighter-rouge">title</code>. This is equivalent to how the sql statement returned a table with one column.</p>

<h3 id="pluck">Pluck</h3>

<p>It’s important to understand how to work with <code class="highlighter-rouge">ActiveRecord::Relation</code> objects, but if you just want all the values out of a column as an Array, ActiveRecord has a shortcut:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;</span> <span class="no">Song</span><span class="p">.</span><span class="nf">pluck</span><span class="p">(</span><span class="ss">:title</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="p">[</span><span class="s2">"Don't Stop Believin'"</span><span class="p">,</span> <span class="s2">"Don't Worry Be Happy"</span><span class="p">,</span> <span class="s2">"Chicken Fried"</span><span class="p">,</span> <span class="s2">"Radioactive"</span><span class="p">]</span>
</code></pre></div></div>

<h2 id="selecting-specific-rows">Selecting specific rows</h2>

<h3 id="sql-2">SQL</h3>

<p>In the previous examples, we were selecting data from all rows, but what if we only want specific rows? For example, what if we wanted to get Songs with a title of “Radioactive”?</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">songs</span> <span class="k">where</span> <span class="n">songs</span><span class="p">.</span><span class="n">title</span> <span class="o">=</span> <span class="s1">'Radioactive'</span><span class="p">;</span>
</code></pre></div></div>

<p>Note that we can’t interchange double and single quotes in sql.</p>

<p>We can also do comparisons in sql. What if we wanted to get songs with a length greater than 200?</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">songs</span> <span class="k">where</span> <span class="n">songs</span><span class="p">.</span><span class="k">length</span> <span class="o">&gt;</span> <span class="mi">200</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="activerecord-2">ActiveRecord</h3>

<p>We can use <code class="highlighter-rouge">where</code> clauses in ActiveRecord as well:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Song</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="ss">title: </span><span class="s2">"Radioactive"</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;ActiveRecord::Relation [#&lt;Song id: 4, title: "Radioactive", length: 10000, play_count: 623547, created_at: "2019-04-22 22:22:01", updated_at: "2019-04-22 22:22:01"&gt;]&gt;</span>
</code></pre></div></div>

<p>Again, notice how this is returning an <code class="highlighter-rouge">ActiveRecord::Relation</code> even though there is only one matching row.</p>

<p>When using a <code class="highlighter-rouge">where</code> in AR, you can use <strong>keyword arguments</strong> to specify a column/value match you are looking for.</p>

<p>Our second example, however, is a bit different:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Song</span><span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"length &gt; 90"</span><span class="p">)</span>
<span class="o">=&gt;</span> <span class="c1">#&lt;ActiveRecord::Relation [#&lt;Song id: 1, title: "Don't Stop Believin'", length: 251, play_count: 760847, created_at: "2019-04-22 22:22:00", updated_at: "2019-04-22 22:22:00"&gt;, #&lt;Song id: 2, title: "Don't Worry Be Happy", length: 280, play_count: 65862, created_at: "2019-04-22 22:22:00", updated_at: "2019-04-22 22:22:00"&gt;, #&lt;Song id: 4, title: "Radioactive", length: 10000, play_count: 623547, created_at: "2019-04-22 22:22:01", updated_at: "2019-04-22 22:22:01"&gt;]&gt;</span>
</code></pre></div></div>

<p>Because we are looking for a comparison (“greater than 200”) rather than an exact match, we can’t use the keyword argument syntax. Instead, we have to write out the sql in strings. <strong>Any ActiveRecord method that takes a String argument will insert that string as-is into the SQL</strong>. This is why it is so important to know sql when learning ActiveRecord. As our queries get more complex, we will have to tell AR the exact sql we want to execute.</p>

<h2 id="ordering-rows">Ordering rows</h2>

<h3 id="sql-3">SQL</h3>

<p>If we want our returned table to be in a certain order, for example alphabetical by title:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">songs</span> <span class="k">order</span> <span class="k">by</span> <span class="n">title</span><span class="p">;</span>
</code></pre></div></div>

<p>And if we want it in descending order:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">songs</span> <span class="k">order</span> <span class="k">by</span> <span class="n">title</span> <span class="k">desc</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="activerecord-3">ActiveRecord</h3>

<p>The AR syntax is very similar:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Song</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">:title</span><span class="p">)</span>
</code></pre></div></div>

<p>Descending:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Song</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="ss">title: :desc</span><span class="p">)</span>
</code></pre></div></div>

<p>Again, we can use Strings to write the sql manually:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Song</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"title"</span><span class="p">)</span>
<span class="no">Song</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"title desc"</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="limiting-rows">Limiting rows</h2>

<h3 id="sql-4">SQL</h3>

<p>Sometimes, you may only need so many rows. For example, if we need 2 songs:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="o">*</span> <span class="k">from</span> <span class="n">songs</span> <span class="k">limit</span> <span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="active-record">Active Record</h3>

<p>We can do the same thing in AR:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Song</span><span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>You may be asking yourself, what is the point of limiting our output? We could just grab all the data and then select what we need using Ruby. The key here is that <strong>the Database is more efficient than Ruby</strong>. In general, relational database are built to optimize queries. The rule of thumb is, if you can do it in the database, you should. For example, you shouldn’t do this:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">songs</span> <span class="o">=</span> <span class="no">Song</span><span class="p">.</span><span class="nf">all</span>
<span class="n">first_two</span> <span class="o">=</span> <span class="p">[</span><span class="n">songs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">songs</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
</code></pre></div></div>

<p>If we had a million songs in our database, we would be making our database do the extra work of retrieving a million rows when we only needed two.</p>

<h2 id="distinct-rows">Distinct rows</h2>

<h3 id="sql-5">SQL</h3>

<p>If we want to get distinct (aka unique) rows:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="k">distinct</span> <span class="o">*</span> <span class="k">from</span> <span class="n">songs</span><span class="p">;</span>
</code></pre></div></div>

<p>Note that since all of our Songs have a unique id, there will never be completely duplicate rows, so this will do exactly the same thing as <code class="highlighter-rouge">select * from songs;</code>, even if we have Songs with the exact same title, length, and play count.</p>

<p>We can see this in action if we have two Songs with duplicate titles in our DB, and then do:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="k">distinct</span> <span class="n">songs</span><span class="p">.</span><span class="n">title</span> <span class="k">from</span> <span class="n">songs</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="activerecord-4">ActiveRecord</h3>

<p>We can do this in ActiveRecord with:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Song</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:title</span><span class="p">).</span><span class="nf">distinct</span>
</code></pre></div></div>

<h2 id="putting-it-all-together">Putting it all together</h2>

<p>Let’s say we want to get the titles of the two Songs with the longest length that have at least 60,000 plays. Let’s break this down:</p>

<ul>
  <li>“get the titles” = <code class="highlighter-rouge">select songs.title from songs</code></li>
  <li>“of the two songs” = <code class="highlighter-rouge">limit 2</code></li>
  <li>“with the longest length” = <code class="highlighter-rouge">order by length desc</code></li>
  <li>“that have at least 60,000 plays” = <code class="highlighter-rouge">where play_count &gt;= 60000</code></li>
</ul>

<p>We can write the sql like this:</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">select</span> <span class="n">songs</span><span class="p">.</span><span class="n">title</span> <span class="k">from</span> <span class="n">songs</span>
<span class="k">where</span> <span class="n">play_count</span> <span class="o">&gt;=</span> <span class="mi">60000</span>
<span class="k">order</span> <span class="k">by</span> <span class="k">length</span> <span class="k">desc</span>
<span class="k">limit</span> <span class="mi">2</span><span class="p">;</span>
</code></pre></div></div>

<p>As your sql/AR statements get longer, it is helpful to write each clause on its own line.</p>

<p>Once you know the sql you want to execute, then we can translate to ActiveRecord. The below is the ActiveRecord version of the above.</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Song</span><span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:title</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"play_count &gt;= 60000"</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"length desc"</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div></div>

<p>You’ll notice that, unlike sql, the order of the ActiveRecord methods does not matter. For example, we can reverse the order and achieve the same output:</p>

<div class="language-ruby highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="no">Song</span><span class="p">.</span><span class="nf">limit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="s2">"length desc"</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">where</span><span class="p">(</span><span class="s2">"play_count &gt;= 60000"</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">select</span><span class="p">(</span><span class="ss">:title</span><span class="p">)</span>
</code></pre></div></div>

<p>This is illustrating a very important fact about ActiveRecord queries. <strong>ActiveRecord will take methods chained together and execute them as a single SQL statement</strong>. This behavior is different than what we normally see in Ruby where chained methods execute left to right, and the next method is called on the return value of the previous method.</p>

<h2 id="practice">Practice</h2>

<p>Write the following in SQL, then ActiveRecord. See the beginning of the lesson plan for help opening psql and rails console connections.</p>

<ol>
  <li>Get all songs</li>
  <li>Get all the song lengths</li>
  <li>Get the songs with a play count greater than zero.</li>
  <li>Get the titles of the songs with a play count greater than zero.</li>
  <li>Get the titles of the songs with a play count greater than zero, sorted alphabetically.</li>
  <li>Get the titles of the songs with a play count greater than zero, sorted reverse alphabetically.</li>
  <li>Get the titles of the two songs with a play count greater than zero, sorted reverse alphabetically.</li>
  <li>Get the length of the song with the most plays.</li>
</ol>

<h2 id="checks-for-understanding">Checks for Understanding</h2>

<p>In your own words, what do each of the following ActiveRecord methods do?</p>

<ul>
  <li>select</li>
  <li>where</li>
  <li>all</li>
  <li>order</li>
  <li>first</li>
  <li>pluck</li>
  <li>limit</li>
  <li>distinct</li>
  <li>last</li>
</ul>
:ET