I"ú<h2 id="learning-goals">Learning Goals</h2>

<ul>
  <li>Understand how the insertion sort algorithm works</li>
  <li>Understand the advantages/disadvantages of insertion sort</li>
  <li>Continue to hone &amp; refine your problem solving skills</li>
</ul>

<h2 id="warm-up">Warm Up</h2>

<p>Watch the instructor take an array of unsorted numbers, <code class="highlighter-rouge">[ 1, 0, 4, 3, 2 ]</code>, and sort them one by one.  Pay attention to both the numbers compared and the order in which those comparisons are made.</p>

<p><em>Follow Up:</em></p>

<ul>
  <li>On a high level, write in your notebook what you saw and how you think the algorithm works.</li>
  <li>Discuss with the person next to you what the algorithm is for insertion sort.</li>
</ul>

<h2 id="insertion-sort">Insertion Sort</h2>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt="Graphical Example of Insertion Sort" /></p>

<p>Insertion sort works by adding items to a sorted array. Typically sorting is done in place inside the array which needs sorting. The first element in the array becomes the sorted array. We iterate through the set to be sorted, pulling one element at a time, then inserting it into its correct position in the sorted section of the array.</p>

<p>You can <a href="https://www.youtube.com/watch?v=8oJS1BMKE64">see another visualization of the algorithm here</a>.</p>

<h3 id="breakdown">Breakdown</h3>

<p>Here is a breakdown of what you saw earlier:</p>

<h4 id="pass-1">Pass 1</h4>

<p>A list with only one item is always sorted, so we start our sorted list with the first element in our array:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>original array: [ 1, 0, 4, 3, 2 ]

                [ sorted        | unsorted   ]
original array: [ 1,            | 0, 4, 3, 2 ]
</code></pre></div></div>

<h4 id="pass-2">Pass 2</h4>

<p>We pull the first unsorted element, the <code class="highlighter-rouge">0</code>, and compare it to the last element of the sorted set, <code class="highlighter-rouge">1</code>. Since <code class="highlighter-rouge">0</code> is less than <code class="highlighter-rouge">1</code>, we swap it with the <code class="highlighter-rouge">1</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsorted:      [0, 4, 3, 2]
to insert:     0

                [ sorted        | unsorted   ]
before insert:  [ 1,            | 0, 4, 3, 2 ]

                [ sorted        | unsorted   ]
after insert:   [ 0, 1,         | 4, 3, 2    ]

</code></pre></div></div>

<h4 id="pass-3">Pass 3</h4>

<p>We pull the first unsorted element, the <code class="highlighter-rouge">4</code>, and compare it to the last element of the sorted set, <code class="highlighter-rouge">1</code>. Since <code class="highlighter-rouge">4</code> is greater than <code class="highlighter-rouge">1</code>, we add the <code class="highlighter-rouge">4</code> to the end of the sorted array.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsorted:      [4, 3, 2]
to insert:     4

                [ sorted        | unsorted   ]
before insert:  [ 0, 1,         | 4, 3, 2    ]

                [ sorted        | unsorted   ]
after insert:   [ 0, 1, 4,      | 3, 2       ]
</code></pre></div></div>

<h4 id="pass-4">Pass 4</h4>

<p>We pull the first unsorted element, the <code class="highlighter-rouge">3</code>, and compare it to the last element of the sorted set, <code class="highlighter-rouge">4</code>. Since <code class="highlighter-rouge">3</code> is less than <code class="highlighter-rouge">4</code>, we swap the <code class="highlighter-rouge">3</code> and <code class="highlighter-rouge">4</code>. We then compare the <code class="highlighter-rouge">3</code> with the previous position of the sorted set, <code class="highlighter-rouge">1</code>. Since <code class="highlighter-rouge">3</code> is greater than <code class="highlighter-rouge">1</code> we have the <code class="highlighter-rouge">3</code> in the correct position.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsorted:      [3, 2]
to insert:     3

                [ sorted        | unsorted   ]
before insert:  [ 0, 1, 4,      | 3, 2       ]

                [ sorted        | unsorted   ]
after insert:   [ 0, 1, 3, 4,   | 2          ]
</code></pre></div></div>

<h4 id="pass-5">Pass 5</h4>

<p>We pull the first unsorted element, the <code class="highlighter-rouge">2</code>, and compare it to the last element of the sorted set, <code class="highlighter-rouge">4</code>. Since <code class="highlighter-rouge">2</code> is less than <code class="highlighter-rouge">4</code> we swap the <code class="highlighter-rouge">2</code> and <code class="highlighter-rouge">4</code>. We then compare the <code class="highlighter-rouge">2</code> with the previous position of the sorted set, <code class="highlighter-rouge">3</code>. Since <code class="highlighter-rouge">2</code> is less than <code class="highlighter-rouge">3</code>, we swap the <code class="highlighter-rouge">2</code> and <code class="highlighter-rouge">3</code>. Then we look at the previous position of the sorted set, <code class="highlighter-rouge">1</code>. Since <code class="highlighter-rouge">2</code> is greater than <code class="highlighter-rouge">1</code> we have the <code class="highlighter-rouge">2</code> in the correct position.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>unsorted:      [2]
to insert:     2

                [ sorted        | unsorted   ]
before insert:  [ 0, 1, 3, 4,   | 2          ]

                [ sorted        | unsorted   ]
after insert:   [ 0, 1, 2, 3, 4 |            ]
</code></pre></div></div>

<p>Since we have no more elements in the unsorted section of our array, we are done with the algorithm.</p>

<h2 id="performance">Performance</h2>

<h3 id="advantages">Advantages</h3>

<ul>
  <li>Implementation compared to other sorting algorithms is simple</li>
  <li>More efficient than other sorting algorithms like <code class="highlighter-rouge">bubble sort</code> or <code class="highlighter-rouge">selection sort</code></li>
  <li>Is effecient for small data sets that are already mostly sorted</li>
</ul>

<h3 id="disadvantages">Disadvantages</h3>
<ul>
  <li>Very impractical for sorting large arrays of data
    <ul>
      <li>The threshold can vary, but itâ€™s typically only good for arrays of 10-50 values</li>
      <li>Arrays with larger datasets are better sorted with algorithms like <code class="highlighter-rouge">merge sort</code> and <code class="highlighter-rouge">quicksort</code></li>
    </ul>
  </li>
</ul>

<p>As a result, a hybrid approach is often implemented for optimization, using a simpler algorithm like <code class="highlighter-rouge">insertion sort</code> for smaller datasets.</p>

<h2 id="your-turn-implementation">Your Turn: Implementation</h2>

<p>Using Repl, implement a sorting function that takes an array as an argument and returns the sorted array using the <code class="highlighter-rouge">insertion sort</code> algorithm.  (feel free to use the language you are most comfortable with)</p>

<p><strong>Note:</strong> For now, do NOT look up solutions!  Itâ€™s easy to find solutions to many sorting algorithms on the web which can be useful when comparing your implementation later, but for now focus on taking what you already know about how <code class="highlighter-rouge">insertion sort</code> works and use your problem solving skills to implement that functionality.</p>

<p>Start with a smaller dataset for now as you start out implementing the functionality.  For more advanced testing, you will need to generate arrays of numbers to see how large of an array your <code class="highlighter-rouge">insertion sort</code> function can sort.</p>
:ET